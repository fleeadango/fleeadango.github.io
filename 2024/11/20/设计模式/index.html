<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>吉林大学设计模式复习总结笔记 | fleeadango-tech-blog</title><meta name="author" content="fleeadango"><meta name="copyright" content="fleeadango"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="还是练手速吧，这门课当时考场上手快写断了  课程背景及意义软件设计模式和面向对象的关系12345软件设计模式与面向对象是紧密相关的，是面向对象技术越来越广泛的应用及发展到一定阶段之后的产物设计模式是一套被反复使用、多数人知晓的、经过分类编目的、面向对象程序设计经验的总结，是在面向对象技术不断发展壮大基础上产生的。设计模式之于面向对象软件开发的作用就有如数据结构之于面向过程软件开发的作用。">
<meta property="og:type" content="article">
<meta property="og:title" content="吉林大学设计模式复习总结笔记">
<meta property="og:url" content="http://example.com/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="fleeadango-tech-blog">
<meta property="og:description" content="还是练手速吧，这门课当时考场上手快写断了  课程背景及意义软件设计模式和面向对象的关系12345软件设计模式与面向对象是紧密相关的，是面向对象技术越来越广泛的应用及发展到一定阶段之后的产物设计模式是一套被反复使用、多数人知晓的、经过分类编目的、面向对象程序设计经验的总结，是在面向对象技术不断发展壮大基础上产生的。设计模式之于面向对象软件开发的作用就有如数据结构之于面向过程软件开发的作用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fleeadango/blog_pics@master/img/avatar4blog.jpg">
<meta property="article:published_time" content="2024-11-20T04:12:23.000Z">
<meta property="article:modified_time" content="2025-05-30T06:20:25.641Z">
<meta property="article:author" content="fleeadango">
<meta property="article:tag" content="课程复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/fleeadango/blog_pics@master/img/avatar4blog.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "吉林大学设计模式复习总结笔记",
  "url": "http://example.com/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
  "image": "https://cdn.jsdelivr.net/gh/fleeadango/blog_pics@master/img/avatar4blog.jpg",
  "datePublished": "2024-11-20T04:12:23.000Z",
  "dateModified": "2025-05-30T06:20:25.641Z",
  "author": [
    {
      "@type": "Person",
      "name": "fleeadango",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '吉林大学设计模式复习总结笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://cdn.jsdelivr.net/gh/fleeadango/blog_pics@master/img/preview.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">fleeadango-tech-blog</span></a><a class="nav-page-title" href="/"><span class="site-name">吉林大学设计模式复习总结笔记</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">吉林大学设计模式复习总结笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-20T04:12:23.000Z" title="发表于 2024-11-20 12:12:23">2024-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-30T06:20:25.641Z" title="更新于 2025-05-30 14:20:25">2025-05-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>还是练手速吧，这门课当时考场上手快写断了</p>
</blockquote>
<h1 id="课程背景及意义"><a href="#课程背景及意义" class="headerlink" title="课程背景及意义"></a>课程背景及意义</h1><h2 id="软件设计模式和面向对象的关系"><a href="#软件设计模式和面向对象的关系" class="headerlink" title="软件设计模式和面向对象的关系"></a>软件设计模式和面向对象的关系</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">软件设计模式与面向对象是紧密相关的，是面向对象技术越来越广泛的应用及发展到一定阶段之后的产物</span><br><span class="line"></span><br><span class="line">设计模式是一套被反复使用、多数人知晓的、经过分类编目的、面向对象程序设计经验的总结，是在面向对象技术不断发展壮大基础上产生的。</span><br><span class="line"></span><br><span class="line">设计模式之于面向对象软件开发的作用就有如数据结构之于面向过程软件开发的作用。</span><br></pre></td></tr></table></figure>



<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Coad等给出了一个定义：“面向对象=对象+类+继承+通信”</span><br><span class="line"></span><br><span class="line">面向对象(Object Oriented)既是软件编程范式，又是软件开发方法。</span><br><span class="line"></span><br><span class="line">面向对象是相对于面向过程来讲的，它把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。</span><br><span class="line"></span><br><span class="line">现如今面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。</span><br><span class="line"></span><br><span class="line">面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。</span><br><span class="line"></span><br><span class="line">面向对象是软件开发领域的主流技术：</span><br><span class="line">	大部分编程语言都是面向对象编程语言，比如 Java、C++、Go、Python、C#、Ruby、JavaScript、Objective-C、Scala、PHP、Perl 等等。</span><br><span class="line">   大部分程序员在开发项目的时候，都是基于面向对象编程语言进行的面向对象编程。</span><br><span class="line">   OOM - Object-Oriented Method(面向对象方法)贯穿于软件开发生命周期的各个阶段：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">面向对象的目标是程序可维护、可复用、可扩展、灵活性。</span><br><span class="line">	可维护：要改，只需更改要改之字</span><br><span class="line"> 	可复用：并非用完这次就无用，可以在后来的印刷中重复使用</span><br><span class="line"> 	可扩展：若要加字，只需另刻字加入即可</span><br><span class="line"> 	灵活性：字的排列其实有可能是竖排有可能是横排，只需将活字移动就可做到满足排列需求</span><br><span class="line"></span><br><span class="line">面向对象起源于1967年在挪威设计的Simula 67编程语言。</span><br><span class="line"></span><br><span class="line">通常将面向对象编程语言称为 OOPL，使用 OOPL进行编程称为面向对象编程（OOP）。</span><br><span class="line"></span><br><span class="line">OOP使得大规模软件的可复用构件群的创建成为可能，这些被称为类库或者框架。</span><br><span class="line">另外，创建可重用构件群时使用的固定的设计思想被提炼为设计模式。</span><br><span class="line"></span><br><span class="line">使用图形来表示利用 OOP 结构创建的软件结构的方法称为统一建模语言（Unified Modeling Language，UML）</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109171454660.png" alt="image-20241109171454660"></p>
<h1 id="面向对象设计与复用"><a href="#面向对象设计与复用" class="headerlink" title="面向对象设计与复用"></a>面向对象设计与复用</h1><h2 id="什么是面向设计"><a href="#什么是面向设计" class="headerlink" title="什么是面向设计"></a>什么是面向设计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象设计的任务是对面向对象分析的结果作进一步的规范化整理，以便能够被面向对象编程直接接受。</span><br></pre></td></tr></table></figure>



<h2 id="面向对象设计的层次"><a href="#面向对象设计的层次" class="headerlink" title="面向对象设计的层次"></a>面向对象设计的层次</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">框架级设计-框架模式</span><br><span class="line">类设计-软件设计模式</span><br><span class="line">代码设计-微模式</span><br></pre></td></tr></table></figure>





<h3 id="框架级设计"><a href="#框架级设计" class="headerlink" title="框架级设计"></a>框架级设计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">框架是从一类特定软件中提取出来的可复用的一组相互协作的类，通常定义了该类软件的体系结构</span><br><span class="line">  </span><br><span class="line">框架级设计考虑如何将可重用的类进行合理的分组，并说明它们是如何协同工作的</span><br><span class="line"></span><br><span class="line">框架级设计可以用“包”来表示类的分组</span><br><span class="line"></span><br><span class="line">可以根据一些原则对类进行合理的划分，并把类分配到包中。在更高抽象层次上来进行设计</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三层逻辑框架</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109172043743.png" alt="image-20241109172043743"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">关于包设计的6个原则，包的创建，相互关系的管理以及包的使用：</span><br><span class="line"></span><br><span class="line">包的内聚性3个原则，用来指导如何把类划分到包中的</span><br><span class="line">    重用发布等价原则</span><br><span class="line">    共同重用原则</span><br><span class="line">    共同封闭原则</span><br><span class="line">包的耦合性3个原则，用来处理包之间的相互关系的。</span><br><span class="line">    无环依赖原则</span><br><span class="line">    稳定依赖原则</span><br><span class="line">    稳定抽象原则</span><br></pre></td></tr></table></figure>



<h3 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类是逻辑的，代码是物理的，是类的具体实现</span><br><span class="line"></span><br><span class="line"> 代码设计主要考虑代码的形式、部署方式和位置、代码的性能、可靠性和可移植性等等</span><br><span class="line"></span><br><span class="line">代码一般有如下几种形式：</span><br><span class="line">    源代码，.cpp .c .java等等</span><br><span class="line">    二进制代码，.lib  .obj .class等等</span><br><span class="line">    可执行代码，.exe .dll等等</span><br></pre></td></tr></table></figure>



<h3 id="类设计"><a href="#类设计" class="headerlink" title="类设计"></a>类设计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">对象(object)是问题域中一些事物的抽象</span><br><span class="line"></span><br><span class="line">类是对象特征的描述，一个类刻画了一组具有相同属性特征和行为特征的对象</span><br><span class="line">    </span><br><span class="line">类的设计包括了：</span><br><span class="line">    类的组织与表示</span><br><span class="line">    	类的发现 - 果篮里装了苹果、香蕉、葡萄、桃</span><br><span class="line">		聚类分析 - 苹果、香蕉、葡萄、桃</span><br><span class="line">		类的再抽象 - 水果，链表模板</span><br><span class="line">		类的拆分 - 果篮里的鲜花</span><br><span class="line">		类的可见性 - 果篮的编织材料</span><br><span class="line">		类的复用性 - 内紧外松，降低类间的耦合度，提高内聚度</span><br><span class="line">    行为的组织与表示</span><br><span class="line">    	行为的参与者 - 老鼠吃各种水果，犬吠人/门/车</span><br><span class="line">		行为的分组与接口 - 吃苹果、吃香蕉... 吃水果</span><br><span class="line">		行为的分解 - 剥皮、吃果肉、吐核，抽象与封装</span><br><span class="line">		行为的可见性 - 吐核，应用程序加载文件</span><br><span class="line">		行为的返回结果 - 吃水果返回空、吃没吃、吃多少</span><br><span class="line">		行为的差异 - 吃不同水果有什么不同</span><br><span class="line">    属性的组织与表示</span><br><span class="line">    	属性的类型 - 内置、自定义</span><br><span class="line">		只读/只写属性 - setter、getter</span><br><span class="line">		不变属性 - 中国公民的身份证</span><br><span class="line">		类属性与实例属性 - 扑克牌的背面图案</span><br><span class="line">		属性的可见性 - 通常不可见</span><br><span class="line">   		属性的概念通常还要结合编程语言来考虑</span><br><span class="line"></span><br><span class="line">类设计中难点在于变化的存在</span><br><span class="line">职责的变化</span><br><span class="line">    接口、功能的变化，如：功能的增加，参数个数及类型的变化，可访问性的变化等等</span><br><span class="line">实现的变化</span><br><span class="line">    数据表示的变化，如数据的类型、数量、可访问性、组织形式等</span><br><span class="line">    行为的变化，如行为过程、行为结果等</span><br><span class="line"></span><br><span class="line">变化的适应方式</span><br><span class="line">	修改既有代码</span><br><span class="line">   		缺点：</span><br><span class="line">   			能否获取</span><br><span class="line">   			修改实现的顾虑、 </span><br><span class="line">   			修改接口的顾虑</span><br><span class="line">	扩展既有代码 - 面向对象设计的基本原则</span><br><span class="line">    	继承方式扩展</span><br><span class="line">        依赖方式扩展</span><br><span class="line">    	关联方式扩展</span><br><span class="line">    	聚合方式扩展</span><br><span class="line">    	组合方式扩展</span><br><span class="line"></span><br><span class="line">关系模型是复用的基础</span><br><span class="line">面向对象设计过程中，为达到可复用等目标，基于这些关系模型/工具，在面向对象设计原则指导下，不断迭代优化设计。针对反复出现的问题和场景，积累提炼出面向对象设计经验，经过验证后成为设计模式。</span><br><span class="line">关系模型是工具基础 - 设计模式要使用或者借助这些关系模型</span><br><span class="line">设计原则是行为准则 - 设计模式要尽可能遵守这些设计原则</span><br></pre></td></tr></table></figure>



<h2 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h2><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependency</span><br><span class="line"></span><br><span class="line">对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。</span><br><span class="line"></span><br><span class="line">就是一个类 A 使用到了另一个类 B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是 B 类的变化会影响到 A。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表现在代码层面，类 B 被类 A 在某个方法中使用，例如：局部变量，方法中的参数，对静态方法的调用等</span><br></pre></td></tr></table></figure>



<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">机器生产零件</span><br><span class="line">充电电池通过充电器来充电</span><br><span class="line">自行车通过打气筒来充气</span><br><span class="line">人借助螺丝刀拧螺丝</span><br><span class="line">人借用船过河</span><br><span class="line">艺术家鉴赏艺术品</span><br><span class="line">警察抓小偷</span><br><span class="line">小猫钓鱼</span><br><span class="line">学生读书</span><br><span class="line">某人买车</span><br></pre></td></tr></table></figure>



<h4 id="UML表示方法"><a href="#UML表示方法" class="headerlink" title="UML表示方法"></a>UML表示方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚线箭头，类 A 指向类 B。</span><br><span class="line"></span><br><span class="line">依赖谁就指向谁</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109173550713.png" alt="image-20241109173550713"></p>
<h4 id="依赖关系的几种表现形式"><a href="#依赖关系的几种表现形式" class="headerlink" title="依赖关系的几种表现形式"></a>依赖关系的几种表现形式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单向依赖</span><br><span class="line"></span><br><span class="line">自身依赖</span><br><span class="line"></span><br><span class="line">双向依赖</span><br></pre></td></tr></table></figure>







<h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">association</span><br><span class="line"></span><br><span class="line">对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。</span><br><span class="line"></span><br><span class="line">关联关系体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">客户和订单(1:N)</span><br><span class="line">公司和员工(1:N)</span><br><span class="line">主人和汽车(1:N)</span><br><span class="line">师傅和徒弟(1:N)</span><br><span class="line">丈夫和妻子(1:1)</span><br><span class="line">飞机和航班(1:N)</span><br><span class="line">学生和课程(N:N)</span><br></pre></td></tr></table></figure>



<h4 id="UML表示方法-1"><a href="#UML表示方法-1" class="headerlink" title="UML表示方法"></a>UML表示方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UML 表示方法：实线箭头，类 A 指向类 B，表示单向关联。如果使用双箭头或不使用箭头表示双向关联。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241110113555260.png" alt="image-20241110113555260"></p>
<h4 id="关联关系的几种表现形式"><a href="#关联关系的几种表现形式" class="headerlink" title="关联关系的几种表现形式"></a>关联关系的几种表现形式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单向关联：</span><br><span class="line">只有某一方拥有另一方的引用，这样只有拥有对方者可以调用对方的公共属性和方法。</span><br><span class="line"></span><br><span class="line">双向关联</span><br><span class="line">双方都拥有对方的引用，都可以调用对方的公共属性和方法。</span><br></pre></td></tr></table></figure>







<h3 id="聚合-聚集关系"><a href="#聚合-聚集关系" class="headerlink" title="聚合&#x2F;聚集关系"></a>聚合&#x2F;聚集关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aggregation</span><br><span class="line"></span><br><span class="line">当对象 B 被加入到对象 A 中，成为对象 A 的组成部分时，对象 A 和对象 B 之间为聚合关系。聚合是关联关系的一种特例。</span><br><span class="line">聚合指的是整体与部分之间的关系，体现的是整体与部分、拥有的关系，即 has-a 的关系，此时整体与部分之间是可分离的，可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在代码层面，聚合和关联关系是一致的，只能从语义级别来区分；</span><br></pre></td></tr></table></figure>



<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">自行车和车把、响铃、轮胎</span><br><span class="line">汽车和引擎、轮胎、刹车装置</span><br><span class="line">计算机和主板、CPU、内存、硬盘</span><br><span class="line">航母编队和航母、驱护舰艇、舰载机、潜艇</span><br><span class="line">课题组和科研人员</span><br></pre></td></tr></table></figure>



<h4 id="UML表示方法-2"><a href="#UML表示方法-2" class="headerlink" title="UML表示方法"></a>UML表示方法</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241110114522654.png" alt="image-20241110114522654"></p>
<h3 id="组合-合成关系"><a href="#组合-合成关系" class="headerlink" title="组合&#x2F;合成关系"></a>组合&#x2F;合成关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">composition</span><br><span class="line"></span><br><span class="line">组合也是关联关系的一种特例，体现的是一种 contains-a 的关系，这种关系比聚合更强，也称为强聚合；</span><br><span class="line">同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。整体类负责部分类对象的生存与消亡。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码层面，组合和关联关系是一致的，只能从语义级别来区分。</span><br><span class="line">组合跟聚合几乎相同，唯一的区别就是“部分”不能脱离“整体”单独存在，就是说， “部分”的生命期不能比“整体”还要长。</span><br></pre></td></tr></table></figure>





<h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">公司和部门</span><br><span class="line">人和大脑、四肢</span><br><span class="line">窗口和标题栏、菜单栏、状态栏</span><br></pre></td></tr></table></figure>



<h4 id="UML表示方法-3"><a href="#UML表示方法-3" class="headerlink" title="UML表示方法"></a>UML表示方法</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241110115144671.png" alt="image-20241110115144671"></p>
<h3 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">generalization</span><br><span class="line"></span><br><span class="line">泛化是一种一般与特殊、一般与具体之间关系的描述，具体描述建立在一般描述的基础之上，并对其进行了扩展。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在代码层面，泛化是通过继承实现的</span><br></pre></td></tr></table></figure>





<h4 id="UML表示方法-4"><a href="#UML表示方法-4" class="headerlink" title="UML表示方法"></a>UML表示方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空心三角形箭头的实线，子类指向父类</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241110115354699.png" alt="image-20241110115354699"></p>
<h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">realization</span><br><span class="line"></span><br><span class="line">实现是一种类与接口的关系，表示类是接口所有特征和行为的实现。从广义上来说，类模板和模板类也是一种实现关系。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在代码层面，实现一般通过类实现接口来描述</span><br><span class="line">泛化和实现的区别就在于子类是否继承了父类的实现，如有继承则关系为泛化，反之为实现。</span><br></pre></td></tr></table></figure>





<h4 id="UML表示方法-5"><a href="#UML表示方法-5" class="headerlink" title="UML表示方法"></a>UML表示方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空心三角形箭头的虚线，实现类指向接口。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241110115709172.png" alt="image-20241110115709172"></p>
<h3 id="类间关系强弱程度"><a href="#类间关系强弱程度" class="headerlink" title="类间关系强弱程度"></a>类间关系强弱程度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泛化/实现&gt;组合&gt;聚合&gt;关联&gt;依赖。</span><br></pre></td></tr></table></figure>



<h3 id="适应变化实现复用的策略"><a href="#适应变化实现复用的策略" class="headerlink" title="适应变化实现复用的策略"></a>适应变化实现复用的策略</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">综合使用组合和继承，参考上面关系模型的各种扩展型</span><br><span class="line"></span><br><span class="line">组合优先</span><br></pre></td></tr></table></figure>







<h2 id="类的设计原则"><a href="#类的设计原则" class="headerlink" title="类的设计原则"></a>类的设计原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Open-Closed Principle   OCP</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在进行面向对象设计中，设计类或其他软件实体时，应该遵循：对扩展开放（open），对修改关闭（closed）的设计原则</span><br><span class="line"></span><br><span class="line">开闭原则是判断面向对象设计是否正确的最基本的原理之一。</span><br><span class="line"></span><br><span class="line">开闭原则强调接口是稳定的，可复用的，但接口的实现是可变的</span><br><span class="line"></span><br><span class="line">软件系统的功能上的可扩展性要求模块是扩展开放的。</span><br><span class="line">软件系统的功能上的稳定性，持续性要求是修改关闭的。</span><br></pre></td></tr></table></figure>





<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">系统设计需要遵循开闭原则的原因：</span><br><span class="line">	稳定性。开闭原则要求扩展功能不修改原来的代码，这可以让软件系统在变</span><br><span class="line">化中保持稳定。</span><br><span class="line">	扩展性。开闭原则要求对扩展开放，通过扩展提供新的或改变原有的功能，</span><br><span class="line">	</span><br><span class="line">软件系统的功能上的可扩展性要求模块是扩展开放的。</span><br><span class="line">软件系统的功能上的稳定性，持续性要求是修改关闭的。</span><br></pre></td></tr></table></figure>



<h4 id="开闭原则的相对性"><a href="#开闭原则的相对性" class="headerlink" title="开闭原则的相对性"></a>开闭原则的相对性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">软件系统的构建是一个需要不断重构的过程，在这个过程中，模块的功能抽象，模块与模块间的关系，都不会从一开始就非常清晰明了，所以构建 100%满足开闭原则的软件系统是相当困难的，这就是开闭原则的相对性。</span><br><span class="line">但在设计过程中，通过对模块功能的抽象（接口定义），模块之间的关系的抽象（通过接口调用），抽象与实现的分离（面向接口的程序设计）等，可以尽量接近满足开闭原则。</span><br></pre></td></tr></table></figure>







<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Liskov Substitution Principle   LSP</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">所有引用基类的地方必须能透明地使用其派生类的对象。</span><br><span class="line"></span><br><span class="line">里氏替换原则 LSP 是使代码符合开闭原则的一个重要保证</span><br><span class="line"></span><br><span class="line">LSP 体现了：</span><br><span class="line">	类的继承原则：如果一个派生类对象可能会在替换基类对象的地方出现运行错误，则该派生类不应该从该基类继承，或者说，应该重新设计它们之间的关系。</span><br><span class="line">	动作正确性保证：从另一个侧面上保证了符合 LSP 设计原则的类的扩展不会给已有的系统引入新的错误</span><br></pre></td></tr></table></figure>





<h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">只有满足以下 2 个条件的 OO 设计才可被认为是满足了 LSP 原则：</span><br><span class="line">	不应该在代码中出现 if/else 之类对派生类类型进行判断的条件。</span><br><span class="line">	派生类对象应当可以替换基类对象并出现在基类对象能够出现的任何地方，</span><br><span class="line">	</span><br><span class="line">或者说如果我们把代码中使用基类对象的地方用它的派生类对象来代替，代码还能正常工作。</span><br></pre></td></tr></table></figure>



<h4 id="违反LSP如何修改"><a href="#违反LSP如何修改" class="headerlink" title="违反LSP如何修改"></a>违反LSP如何修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果两个具体的类 A，B 之间的关系违反了 LSP 的设计，那么根据具体的情况可以在下面的两种重构方案中选择一种：</span><br><span class="line">	创建一个新的抽象类 C，作为两个具体类的基类，将 A，B 的共同行为移动到 C 中来解决问题。</span><br><span class="line">	从 B 到 A 的继承关系改为关联关系。</span><br><span class="line">	</span><br><span class="line">在进行设计的时候，我们尽量从抽象类继承，而不是从具体类继承。</span><br></pre></td></tr></table></figure>







<h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（最少知道原则）</span><br><span class="line">Law of Demeter   LoD</span><br><span class="line"></span><br><span class="line">迪米特原则可以简单说成：talk only to your immediate friends，只与你直接的朋友们通信，不要跟”陌生人”说话。进一步可理解为两个层次：</span><br><span class="line">	一个软件实体应当尽可能少地与其他软件实体发生相互作用（只和你的”朋友” 通信）。</span><br><span class="line">	每一个软件实体对其他软件实体都只有最少的知识，而且局限于那些与本软件实体密切相关的软件实体（跟”朋友”通信越少越好，具体来说就是一个类对自己依赖的其它类知道的越少越好）。</span><br></pre></td></tr></table></figure>





<h4 id="“朋友”的判定条件"><a href="#“朋友”的判定条件" class="headerlink" title="“朋友”的判定条件"></a>“朋友”的判定条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">朋友圈的确定，”朋友”条件：</span><br><span class="line">1）当前对象本身（this）</span><br><span class="line">2）以参数形式传入到当前对象方法中的对象（依赖）</span><br><span class="line">3）当前对象的实例变量直接引用的对象（关联）</span><br><span class="line">4）当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友（聚集）</span><br><span class="line">5）当前对象所创建的对象（组合）</span><br><span class="line">任何一个对象，如果满足上面条件之一，就是当前对象的”朋友”，否则就是”陌生人</span><br></pre></td></tr></table></figure>



<h4 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迪米特原则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</span><br></pre></td></tr></table></figure>



<h4 id="应用迪米特法则可能造成的后果"><a href="#应用迪米特法则可能造成的后果" class="headerlink" title="应用迪米特法则可能造成的后果"></a>应用迪米特法则可能造成的后果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">迪米特原则不希望类之间建立直接的接触。如果真的有需要建立联系，也希望能建立较少的联系，或者通过中介类来转达。</span><br><span class="line">因此，应用迪米特原则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系，这在一定程度上增加了系统的复杂度。</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个类公开的 public 属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少 public 方法和属性，是否可以修改为 private 等。</span><br><span class="line">如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，就放置在本类中。如果放在其他类中，反而可能增加类间关系</span><br></pre></td></tr></table></figure>







<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Single Responsibility Principle   SRP</span><br><span class="line"></span><br><span class="line">永远不要让一个类存在多个改变的理由。换句话说，如果一个类需要改变，改变它的理由永远只有一个。如果存在多个改变它的理由，就需要重新设计该类</span><br><span class="line"></span><br><span class="line">单一职责原则的核心含意是：只能让一个类有且仅有一个职责。这也是单一职责原则的命名含义</span><br><span class="line"></span><br><span class="line">单一职责原则从职责（改变理由）的侧面上为我们对类（接口）的抽象的颗粒度建立了判断基准：在为系统设计类（接口）的时候应该保证它们的单一职责性。</span><br></pre></td></tr></table></figure>





<h4 id="为什么一个类不能有多于一个以上的职责"><a href="#为什么一个类不能有多于一个以上的职责" class="headerlink" title="为什么一个类不能有多于一个以上的职责"></a>为什么一个类不能有多于一个以上的职责</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果一个类具有一个以上的职责，那么就会有多个不同的原因引起该类变化，而这种变化将影响到该类不同职责的使用者（不同用户）：</span><br><span class="line">	一方面，如果一个职责使用了外部类库，则使用另外一个职责的用户却也不得不包含这个未被使用的外部类库。</span><br><span class="line">	另一方面，某个用户由于某个原因需要修改其中一个职责，另外一个职责的用户也将受到影响，他将不得不重新编译和配置。</span><br><span class="line"></span><br><span class="line">这违反了设计的开闭原则，也不是我们所期望的。</span><br></pre></td></tr></table></figure>







<h3 id="接口分隔原则"><a href="#接口分隔原则" class="headerlink" title="接口分隔原则"></a>接口分隔原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Interface Segregation Principle   ISP</span><br><span class="line"></span><br><span class="line">不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。</span><br><span class="line"></span><br><span class="line">它包含了 2 层意思：</span><br><span class="line">	接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户不使用的方法塞进同一个接口里。 如果一个接口的方法没有被使用到，则说明该接口过胖，应该将其分割成几个功能专一的接口。</span><br><span class="line">	接口的依赖（继承）原则：如果一个接口 a 继承另一个接口 b，则接口 a 相当于继承了接口 b 的方法，那么继承了接口 b 后的接口 a 也应该遵循上述原则：不应该包含用户不使用的方法。 反之，则说明接口 a 被 b 给污染了，应该重新设计它们的关系</span><br><span class="line">	</span><br><span class="line">接口分隔原则从对接口的使用上为我们对接口抽象的颗粒度建立了判断基准：在为系统设计接口的时候，使用多个专门的接口代替单一的胖接口。</span><br></pre></td></tr></table></figure>





<h4 id="为什么要遵守接口分割原则"><a href="#为什么要遵守接口分割原则" class="headerlink" title="为什么要遵守接口分割原则"></a>为什么要遵守接口分割原则</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果用户被迫依赖他们不使用的接口，当接口发生改变时，他们也不得不跟着改变。换而言之，一个用户依赖了未使用但被其他用户使用的接口，当其他用户修改该接口时，依赖该接口的所有用户都将受到影响。这显然违反了开闭原则，也不是我们所期望的。</span><br></pre></td></tr></table></figure>



<h4 id="单一职责原则与接口隔离原则的共同点"><a href="#单一职责原则与接口隔离原则的共同点" class="headerlink" title="单一职责原则与接口隔离原则的共同点"></a>单一职责原则与接口隔离原则的共同点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两者都是为了提高内聚性、降低耦合性，体现了封装的思想；</span><br><span class="line"></span><br><span class="line">最终表现出来的都是将接口约束到最小功能。</span><br></pre></td></tr></table></figure>



<h4 id="单一职责原则与接口隔离原则的区别"><a href="#单一职责原则与接口隔离原则的区别" class="headerlink" title="单一职责原则与接口隔离原则的区别"></a>单一职责原则与接口隔离原则的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">针对内容、思考角度的区别：</span><br><span class="line"></span><br><span class="line">单一职责原则针对的是模块、类、接口的设计</span><br><span class="line">单一职责原则是从软件实体本身的职责/功能是否单一来考虑</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接口隔离原则更侧重于接口的设计</span><br><span class="line">接口隔离原则主要是从用户的角度来考虑接口约束问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实际应用上的区别：</span><br><span class="line"></span><br><span class="line">例如一个接口的职责可能包含多个方法，这多个方法都放在一个接口中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约束“不使用的方法不要访问”，按照单一职责原则是允许的，按照接口隔离原则是不允许的，因为它要求“尽量使用多个专门的接口”。而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问。</span><br></pre></td></tr></table></figure>







<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Dependency Inversion Principle   DIP</span><br><span class="line"></span><br><span class="line">高层模块不应该依赖于低层模块，二者都应该依赖于抽象</span><br><span class="line">抽象不应该依赖于细节，细节应该依赖于抽象</span><br><span class="line"></span><br><span class="line">面向对象程序设计相对于面向过程（结构化）程序设计而言，依赖关系被倒置了。</span><br><span class="line">因为传统的结构化程序设计中，高层模块总是依赖于低层模块。</span><br></pre></td></tr></table></figure>





<h4 id="Bad-Design的定义"><a href="#Bad-Design的定义" class="headerlink" title="Bad Design的定义"></a>Bad Design的定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Robert C. Martin 在原文中给出了“Bad Design”的定义：</span><br><span class="line">1. 系统很难改变，因为每个改变都会影响其他很多部分。</span><br><span class="line">2. 当你对某地方做一修改，系统的看似无关的其他部分都不工作了。</span><br><span class="line">3. 系统很难被另外一个应用重用，因为很难将要重用的部分从系统中分离开来。</span><br><span class="line"></span><br><span class="line">导致“Bad Design”的很大原因是“高层模块”过分依赖“低层模块”。</span><br><span class="line"></span><br><span class="line">一个良好的设计应该是系统的每一部分都是可替换的。</span><br><span class="line"></span><br><span class="line">如果“高层模块”过分依赖“低层模块”，一方面一旦“低层模块”需要替换或者修改，“高层模块”将受到影响；另一方面，高层模块很难重用</span><br></pre></td></tr></table></figure>



<h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在高层模块与低层模块之间，引入一个抽象接口层</span><br><span class="line"></span><br><span class="line">抽象接口是对低层模块的抽象，低层模块继承或实现该抽象接口。</span><br><span class="line">这样，高层模块不直接依赖低层模块，而是依赖抽象接口层。抽象接口也不依赖低层模块的实现细节，而是低层模块依赖（继承或实现）抽象接口。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241110133602614.png" alt="image-20241110133602614"></p>
<h4 id="带来的启发"><a href="#带来的启发" class="headerlink" title="带来的启发"></a>带来的启发</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">启发 1：依赖于抽象</span><br><span class="line"> 任何对象都不应该持有一个指向具体类的指针或引用</span><br><span class="line"> 任何类都不应该从具体类派生</span><br><span class="line"></span><br><span class="line">启发 2：设计接口而非设计实现</span><br><span class="line"> 使用继承/实现避免对具体类的直接绑定</span><br><span class="line">•抽象类/接口：</span><br><span class="line">倾向于较少的变化</span><br><span class="line">抽象是关键点，它易于修改和扩展</span><br><span class="line">不要强制修改那些抽象接口/类</span><br><span class="line">•例外</span><br><span class="line">有些类不可能变化</span><br><span class="line">在可以直接使用具体类的情况下，不需要插入抽象层</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启发 3：避免传递依赖</span><br><span class="line"> 避免高层依赖于低层</span><br><span class="line"> 使用抽象类/接口和继承/实现来有效地消除传递依赖</span><br></pre></td></tr></table></figure>









<h3 id="组合-聚合复用原则"><a href="#组合-聚合复用原则" class="headerlink" title="组合&#x2F;聚合复用原则"></a><strong>组合</strong>&#x2F;聚合复用原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Composite/Aggregate Reuse Principle   CARP</span><br><span class="line"></span><br><span class="line">又称合成复用原则（Composite Reuse Principle，CRP）</span><br><span class="line"></span><br><span class="line">尽量使用组合/聚合而非继承来达到复用目的</span><br><span class="line">在一个新的对象中使用一些已有的对象，使之成为新对象的一部分，然后新的对象通过向这些对象委托功能达到复用这些对象的目的。</span><br></pre></td></tr></table></figure>



<h4 id="Coad条件"><a href="#Coad条件" class="headerlink" title="Coad条件"></a>Coad条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">只有当以下的 Coad 条件全部被满足时，才应当使用继承关系</span><br><span class="line"></span><br><span class="line">1）派生类是基类的一个特殊种类，而不是基类的一个角色，也就是区分&quot;has a&quot;和&quot;is a&quot;。只有&quot;is a&quot;关系才符合继承关系，&quot;has a&quot;关系应当用聚合来描述。</span><br><span class="line">2）永远不会出现需要将派生类换成另外一个类的派生类的情况。如果不能肯定将来是否会变成另外一个派生类的话，就不要使用继承。</span><br><span class="line">3）派生类具有扩展基类的责任，而不是具有置换掉（override）或注销掉（nullify）基类的责任。如果一个派生类需要大量的置换掉基类的行为，那么这个类就不应该是这个基类的派生类。</span><br><span class="line">4）只有在分类学角度上有意义时，才可以使用继承。</span><br><span class="line"></span><br><span class="line">只有两个类满足里氏替换原则的时候，才可能是&quot;is a&quot; 关系。也就是说，如果两个类是&quot;has a&quot;关系，但是设计成了继承，那么肯定违反里氏替换原则。</span><br></pre></td></tr></table></figure>



<h4 id="通过组合-聚合复用的优缺点"><a href="#通过组合-聚合复用的优缺点" class="headerlink" title="通过组合&#x2F;聚合复用的优缺点"></a>通过组合&#x2F;聚合复用的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) 新对象存取成员对象的唯一方法是通过成员对象的接口；</span><br><span class="line">2) 这种复用是黑箱复用，因为成员对象的内部细节是新对象所看不见的；</span><br><span class="line">3) 这种复用更好地支持封装性；</span><br><span class="line">4) 这种复用实现上的相互依赖性比较小；</span><br><span class="line">5) 每一个新的类可以将焦点集中在一个任务上；</span><br><span class="line">6) 这种复用可以在运行时间内动态进行，新对象可以动态的引用与子对象类型相同的对象。</span><br><span class="line">7) 作为复用手段可以应用到几乎任何环境中去</span><br></pre></td></tr></table></figure>



<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是系统中会有较多的对象需要管理</span><br></pre></td></tr></table></figure>







<h4 id="通过继承来进行复用的优缺点"><a href="#通过继承来进行复用的优缺点" class="headerlink" title="通过继承来进行复用的优缺点"></a>通过继承来进行复用的优缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新的实现较为容易，因为基类的大部分功能可以通过继承的关系自动进入派生类。</span><br><span class="line"></span><br><span class="line">修改和扩展继承而来的实现较为容易。</span><br></pre></td></tr></table></figure>



<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">继承复用破坏封装性，因为继承将基类的实现细节暴露给派生类。由于基类的内部细节常常是对于派生类透明的，所以这种复用是透明的复用，又称“白箱” 复用。</span><br><span class="line"></span><br><span class="line">如果基类发生改变，那么派生类的实现也不得不发生改变。从基类继承而来的实现是静态的，不可能在运行时间内发生改变，没有足够的灵活性</span><br></pre></td></tr></table></figure>





















<h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><h2 id="模式的诞生与定义"><a href="#模式的诞生与定义" class="headerlink" title="模式的诞生与定义"></a>模式的诞生与定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">模式起源于建筑业而非软件业</span><br><span class="line"></span><br><span class="line">模式(Pattern)之父——美国加利佛尼亚大学环境结构中心研究所所长Christopher Alexander博士</span><br><span class="line"></span><br><span class="line">模式是在特定环境中解决问题的一种方案</span><br><span class="line"></span><br><span class="line">模式</span><br><span class="line">Context（模式可适用的前提条件）</span><br><span class="line">Theme或Problem（在特定条件下要解决的目标问题）</span><br><span class="line">Solution（对目标问题求解过程中各种物理关系的记述）</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="设计模式的诞生与发展"><a href="#设计模式的诞生与发展" class="headerlink" title="设计模式的诞生与发展"></a>设计模式的诞生与发展</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">软件工程界开始关注Christopher Alexander等在这一住宅、公共建筑与城市规划领域的重大突破</span><br><span class="line">最早将该模式的思想引入软件工程方法学的是1991-1992年以“四人组(Gang of Four，GoF，分别是Erich Gamma, Richard Helm, Ralph Johnson和John Vlissides)”自称的四位著名软件工程学者</span><br><span class="line">他们在1994年归纳发表了23种在软件开发中使用频率较高的设计模式，旨在用模式来统一沟通面向对象方法在分析、设计和实现间的鸿沟。</span><br><span class="line"></span><br><span class="line">软件模式是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板</span><br><span class="line"></span><br><span class="line">软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等</span><br><span class="line"></span><br><span class="line">软件模式可以认为是对软件开发这一特定“问题”的“解法”的某种统一表示，即软件模式等于一定条件下的出现的问题以及解法</span><br><span class="line"></span><br><span class="line">软件模式的基础结构由4个部分构成：</span><br><span class="line">	问题描述</span><br><span class="line">	前提条件（环境或约束条件）</span><br><span class="line">	解法</span><br><span class="line">	效果</span><br><span class="line"></span><br><span class="line">软件模式与具体的应用领域无关</span><br><span class="line">在模式发现过程中需要遵循大三律(Rule of Three)，即只有经过三个以上不同类型（或不同领域）的系统的校验，一个解决方案才能从候选模式升格为模式。</span><br></pre></td></tr></table></figure>



<h2 id="设计模式的定义"><a href="#设计模式的定义" class="headerlink" title="设计模式的定义"></a>设计模式的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设计模式是针对重复出现的设计问题的一种经过实践验证的解决方案</span><br><span class="line"></span><br><span class="line">设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可复用代码、让代码更容易被他人理解、保证代码可靠性等</span><br></pre></td></tr></table></figure>



<h2 id="设计模式的基本要素"><a href="#设计模式的基本要素" class="headerlink" title="设计模式的基本要素"></a>设计模式的基本要素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设计模式一般有如下几个基本要素：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式</span><br><span class="line"></span><br><span class="line">关键元素包括以下四个方面：</span><br><span class="line">	模式名称 (Pattern name) </span><br><span class="line">	问题 (Problem) </span><br><span class="line">	解决方案 (Solution) </span><br><span class="line">	效果 (Consequences) </span><br></pre></td></tr></table></figure>



<h2 id="设计模式的两大主题"><a href="#设计模式的两大主题" class="headerlink" title="设计模式的两大主题"></a>设计模式的两大主题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统复用与系统扩展</span><br></pre></td></tr></table></figure>



<h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">根据其目的（模式是用来做什么的）可分为</span><br><span class="line">	创建型(Creational)</span><br><span class="line">		主要用于创建对象</span><br><span class="line">	结构型(Structural)</span><br><span class="line">		主要用于处理类或对象的组合</span><br><span class="line">	行为型(Behavioral)</span><br><span class="line">		主要用于描述对类或对象怎样交互和怎样分配职责</span><br><span class="line">		</span><br><span class="line">根据范围，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为</span><br><span class="line">	类模式</span><br><span class="line">		处理类和子类之间的关系，这些关系通过继承建立，在编		 译时刻就被确定下来，是属于静态的。 </span><br><span class="line">	对象模式</span><br><span class="line">		处理对象间的关系，这些关系在运行时刻变化，更具动态	     性。</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">GoF设计模式如下</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241110140107292.png" alt="image-20241110140107292"></p>
<h2 id="设计模式的优点"><a href="#设计模式的优点" class="headerlink" title="设计模式的优点"></a>设计模式的优点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">设计模式融合了众多专家的经验，并以一种标准的形式供广大开发人员所用，它提供了一套通用的设计词汇和一种通用的语言以方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。</span><br><span class="line">对于使用不同编程语言的开发和设计人员可以通过设计模式来交流系统设计方案，每一个模式都对应一个标准的解决方案，设计模式可以降低开发人员理解系统的复杂度。</span><br><span class="line"></span><br><span class="line">设计模式使人们可以更加简单方便地复用成功的设计，将已证实的技术表述成设计模式会使新系统开发者更加容易理解其设计思路，并避免那些导致不可重用的设计方案。</span><br><span class="line"></span><br><span class="line">设计模式使得设计方案更加灵活，且易于修改。 </span><br><span class="line"></span><br><span class="line">设计模式的使用将提高软件系统的开发效率和软件质量，且在一定程度上节约设计成本。 </span><br><span class="line"></span><br><span class="line">设计模式有助于初学者更深入地理解面向对象思想，一方面可以帮助初学者更加方便地阅读和学习现有类库与其他系统中的源代码，另一方面还可以提高软件的设计水平和代码质量。</span><br></pre></td></tr></table></figure>







<h1 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关注的是对象的创建，将创建对象(类的实例化)的过程进行了抽象和封装，分离了对象创建和对象使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建型模式有两个重要的特点：</span><br><span class="line">	客户不知道对象的具体类是什么（除非看源代码）</span><br><span class="line">	隐藏了对象实例是如何被创建和组织的</span><br></pre></td></tr></table></figure>









<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Simple Factory Pattern</span><br><span class="line"></span><br><span class="line">在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</span><br><span class="line"></span><br><span class="line">一种类创建型模式</span><br><span class="line"></span><br><span class="line">又称为静态工厂方法(Static Factory Method)</span><br><span class="line"></span><br><span class="line">要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</span><br><span class="line">最大的优点在于实现对象的创建和对象的使用分离</span><br><span class="line">最大的缺点在于工厂类不够灵活</span><br></pre></td></tr></table></figure>





<h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮，按钮源自同一个基类。</span><br><span class="line">不知道这些具体按钮类的名字，只知道表示该按钮类的一个参数，需要提供一个调用方便的方法，把该参数传入方法能够返回一个相应的按钮对象</span><br></pre></td></tr></table></figure>



<h4 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义工厂类：负责实现创建各种实例的内部逻辑</span><br><span class="line">定义抽象产品类：各种对象的父类，负责描述所有实例共有的公共接口</span><br><span class="line">定义具体产品类：继承抽象产品类</span><br></pre></td></tr></table></figure>



<h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107141739278.png" alt="image-20241107141739278"></p>
<h4 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h4><h5 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</span><br><span class="line"></span><br><span class="line">客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</span><br><span class="line"></span><br><span class="line">通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</span><br></pre></td></tr></table></figure>



<h5 id="模式缺点"><a href="#模式缺点" class="headerlink" title="模式缺点"></a>模式缺点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</span><br><span class="line"></span><br><span class="line">使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</span><br><span class="line"></span><br><span class="line">系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</span><br><span class="line"></span><br><span class="line">简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</span><br></pre></td></tr></table></figure>







<h4 id="模式适用环境"><a href="#模式适用环境" class="headerlink" title="模式适用环境"></a>模式适用环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</span><br><span class="line"></span><br><span class="line">客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数</span><br></pre></td></tr></table></figure>





<h5 id="现实应用"><a href="#现实应用" class="headerlink" title="现实应用"></a>现实应用</h5><h6 id="1-JDK类库中日期工具类"><a href="#1-JDK类库中日期工具类" class="headerlink" title="1.JDK类库中日期工具类"></a>1.JDK类库中日期工具类</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</span><br><span class="line"></span><br><span class="line">注意：静态工厂方法不止1个</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107142854864.png" alt="image-20241107142854864"></p>
<h6 id="2-java加密技术"><a href="#2-java加密技术" class="headerlink" title="2.java加密技术"></a>2.java加密技术</h6><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107142936836.png" alt="image-20241107142936836"></p>
<h4 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h4><h5 id="简单工厂模式的简化"><a href="#简单工厂模式的简化" class="headerlink" title="简单工厂模式的简化"></a>简单工厂模式的简化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在有些情况下工厂类可以由抽象产品角色扮演，一个抽象产品类同时也是子类的工厂，也就是说把静态工厂方法写到抽象产品类中。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107143035906.png" alt="image-20241107143035906"></p>
<h4 id="模式本质"><a href="#模式本质" class="headerlink" title="模式本质"></a>模式本质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现简单工厂模式的难点就在于 “如何选择”实现</span><br></pre></td></tr></table></figure>







<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Factory Method Pattern</span><br><span class="line"></span><br><span class="line">在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</span><br><span class="line"></span><br><span class="line">一种类创建模式</span><br><span class="line"></span><br><span class="line">又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式。</span><br><span class="line"></span><br><span class="line">基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。</span><br><span class="line"></span><br><span class="line">工厂方法模式很好的体现了“依赖倒置原则”。</span><br></pre></td></tr></table></figure>



<h4 id="解决的问题-1"><a href="#解决的问题-1" class="headerlink" title="解决的问题"></a>解决的问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这违背了“开闭原则”</span><br><span class="line">为了在不修改具体工厂类的情况下引进新的产品</span><br></pre></td></tr></table></figure>



<h4 id="解决的方法-1"><a href="#解决的方法-1" class="headerlink" title="解决的方法"></a>解决的方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义抽象产品类：产品对象的共同父类或接口</span><br><span class="line">定义具体产品类：实现抽象产品接口，对应一种具体产品</span><br><span class="line">定义抽象工厂类：具体工厂的共同父类或接口，声明工厂方法</span><br><span class="line">定义具体工厂类：继承抽象工厂类，实现工厂方法，返回一个具体产品类的实例</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107192145065.png" alt="image-20241107192145065"></p>
<h4 id="模式优缺点-1"><a href="#模式优缺点-1" class="headerlink" title="模式优缺点"></a>模式优缺点</h4><h5 id="模式优点-1"><a href="#模式优点-1" class="headerlink" title="模式优点"></a>模式优点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</span><br><span class="line"></span><br><span class="line">基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。</span><br><span class="line">它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。</span><br><span class="line">工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</span><br><span class="line"></span><br><span class="line">使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</span><br></pre></td></tr></table></figure>



<h5 id="模式缺点-1"><a href="#模式缺点-1" class="headerlink" title="模式缺点"></a>模式缺点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</span><br><span class="line"></span><br><span class="line">由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</span><br></pre></td></tr></table></figure>







<h4 id="模式适用环境-1"><a href="#模式适用环境-1" class="headerlink" title="模式适用环境"></a>模式适用环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</span><br><span class="line"></span><br><span class="line">一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</span><br><span class="line"></span><br><span class="line">将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</span><br></pre></td></tr></table></figure>





<h5 id="现实应用-1"><a href="#现实应用-1" class="headerlink" title="现实应用"></a>现实应用</h5><h6 id="1-Java消息服务"><a href="#1-Java消息服务" class="headerlink" title="1.Java消息服务"></a>1.Java消息服务</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMS(Java Messaging Service) </span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107194017128.png" alt="image-20241107194017128"></p>
<h6 id="2-JDBC中的工厂方法"><a href="#2-JDBC中的工厂方法" class="headerlink" title="2.JDBC中的工厂方法"></a>2.JDBC中的工厂方法</h6><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107194045742.png" alt="image-20241107194045742"></p>
<h4 id="模式扩展-1"><a href="#模式扩展-1" class="headerlink" title="模式扩展"></a>模式扩展</h4><h5 id="使用多个工厂方法"><a href="#使用多个工厂方法" class="headerlink" title="使用多个工厂方法"></a>使用多个工厂方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求</span><br></pre></td></tr></table></figure>



<h5 id="产品对象的重复使用"><a href="#产品对象的重复使用" class="headerlink" title="产品对象的重复使用"></a>产品对象的重复使用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工厂对象将已经创建过的产品保存到一个集合（如数组、List等）中，然后根据客户对产品的请求，对集合进行查询。</span><br><span class="line">如果有满足要求的产品对象，就直接将该产品返回客户端；</span><br><span class="line">如果集合中没有这样的产品对象，那么就创建一个新的满足要求的产品对象，然后将这个对象在增加到集合中，再返回给客户端</span><br></pre></td></tr></table></figure>



<h5 id="多态性的丧失和模式的退化"><a href="#多态性的丧失和模式的退化" class="headerlink" title="多态性的丧失和模式的退化"></a>多态性的丧失和模式的退化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了</span><br><span class="line">如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生了退化</span><br><span class="line">当只有一个具体工厂，在具体工厂中可以创建所有的产品对象</span><br><span class="line">并且工厂方法设计为静态方法时，工厂方法模式就退化成简单工厂模式。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h4 id="模式本质-1"><a href="#模式本质-1" class="headerlink" title="模式本质"></a>模式本质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">延迟到子类来选择实现</span><br></pre></td></tr></table></figure>







<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Abstract Factory Pattern</span><br><span class="line"></span><br><span class="line">提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</span><br><span class="line"></span><br><span class="line">一种对象创建型模式</span><br><span class="line"></span><br><span class="line">抽象工厂模式又称为Kit模式</span><br><span class="line"></span><br><span class="line">抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态</span><br></pre></td></tr></table></figure>





<h4 id="解决的问题-2"><a href="#解决的问题-2" class="headerlink" title="解决的问题"></a>解决的问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在工厂方法模式中，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。</span><br><span class="line">但是有时候我们需要系统所提供的工厂生产的具体产品并不只是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品</span><br></pre></td></tr></table></figure>



<h4 id="解决的方式"><a href="#解决的方式" class="headerlink" title="解决的方式"></a>解决的方式</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109122427068.png" alt="image-20241109122427068"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义抽象工厂类：定义一组方法，每一个方法对应一个产品等级结构</span><br><span class="line">定义具体工厂类：继承抽象工厂类，实现其声明的生成抽象产品的方法，每一个产品都位于某个产品等级结构中</span><br><span class="line">定义抽象产品类：为每种产品声明接口，定义产品的抽象业务方法</span><br><span class="line">定义具体产品类：定义具体产品对象，实现抽象产品接口中定义的业务方法</span><br></pre></td></tr></table></figure>



<h4 id="模式结构-2"><a href="#模式结构-2" class="headerlink" title="模式结构"></a>模式结构</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107195938628.png" alt="image-20241107195938628"></p>
<h4 id="模式优缺点-2"><a href="#模式优缺点-2" class="headerlink" title="模式优缺点"></a>模式优缺点</h4><h5 id="模式优点-2"><a href="#模式优点-2" class="headerlink" title="模式优点"></a>模式优点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。</span><br><span class="line">所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</span><br><span class="line">另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</span><br><span class="line"></span><br><span class="line">当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</span><br><span class="line"></span><br><span class="line">增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</span><br></pre></td></tr></table></figure>



<h5 id="模式缺点-2"><a href="#模式缺点-2" class="headerlink" title="模式缺点"></a>模式缺点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</span><br><span class="line"></span><br><span class="line">开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）</span><br></pre></td></tr></table></figure>







<h4 id="模式适用环境-2"><a href="#模式适用环境-2" class="headerlink" title="模式适用环境"></a>模式适用环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</span><br><span class="line"></span><br><span class="line">系统中有多于一个的产品族，而每次只使用其中某一产品族。</span><br><span class="line"></span><br><span class="line">属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</span><br><span class="line"></span><br><span class="line">系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</span><br></pre></td></tr></table></figure>





<h5 id="现实应用-2"><a href="#现实应用-2" class="headerlink" title="现实应用"></a>现实应用</h5><h5 id="1-Java-SE-AWT"><a href="#1-Java-SE-AWT" class="headerlink" title="1.Java SE AWT"></a>1.Java SE AWT</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">抽象窗口工具包</span><br><span class="line">在Java语言的AWT中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。 </span><br></pre></td></tr></table></figure>



<h5 id="2-软件系统更换界面主题"><a href="#2-软件系统更换界面主题" class="headerlink" title="2.软件系统更换界面主题"></a>2.软件系统更换界面主题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。</span><br></pre></td></tr></table></figure>







<h4 id="模式扩展-2"><a href="#模式扩展-2" class="headerlink" title="模式扩展"></a>模式扩展</h4><h5 id="开闭原则的倾斜性"><a href="#开闭原则的倾斜性" class="headerlink" title="开闭原则的倾斜性"></a>开闭原则的倾斜性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</span><br><span class="line">	(1) 增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</span><br><span class="line">	(2) 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</span><br><span class="line"></span><br><span class="line">抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</span><br></pre></td></tr></table></figure>



<h5 id="工厂模式的退化"><a href="#工厂模式的退化" class="headerlink" title="工厂模式的退化"></a>工厂模式的退化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；</span><br><span class="line"></span><br><span class="line">当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</span><br></pre></td></tr></table></figure>







<h4 id="模式本质-2"><a href="#模式本质-2" class="headerlink" title="模式本质"></a>模式本质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择产品簇的实现</span><br></pre></td></tr></table></figure>





















<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Builder Pattern</span><br><span class="line"></span><br><span class="line">将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型就可以构建它们，用户不需要知道内部的具体构建细节。</span><br><span class="line"></span><br><span class="line">一种对象创建型模式。</span><br><span class="line"></span><br><span class="line">根据中文翻译的不同，建造者模式又可以称为生成器模式。</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-3"><a href="#解决的问题-3" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大量复杂对象拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。 </span><br><span class="line">希望对于这些复杂对象，用户只需要指定复杂对象的类型，就可以返还客户端一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，</span><br></pre></td></tr></table></figure>



<h3 id="解决的方式-1"><a href="#解决的方式-1" class="headerlink" title="解决的方式"></a>解决的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义抽象建造者类：为创建一个产品对象的各个部件定义抽象接口</span><br><span class="line">定义具体建造者类：继承抽象建造者，实现抽象接口，实现各部件的构造和装配方式，定义创建的复杂对象，提供方法返回该对象</span><br><span class="line">定义指挥者类：与抽象建造者存在关联关系，保存一个抽象建造者的引用，定义construct方法并在其中调用建造者的方法来完成复杂对象的建造</span><br><span class="line">定义产品类：是被构建的复杂对象，包含多个部件</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-3"><a href="#模式结构-3" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109131932073.png" alt="image-20241109131932073"></p>
<h3 id="模式优缺点-3"><a href="#模式优缺点-3" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-3"><a href="#模式优点-3" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</span><br><span class="line"></span><br><span class="line">每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</span><br><span class="line"></span><br><span class="line">可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</span><br><span class="line"></span><br><span class="line">增加新的具体建造者无须修改原有的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-3"><a href="#模式缺点-3" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</span><br><span class="line"></span><br><span class="line">如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-3"><a href="#模式适用环境-3" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</span><br><span class="line"></span><br><span class="line">需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</span><br><span class="line"></span><br><span class="line">对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</span><br><span class="line"></span><br><span class="line">隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品对象。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-3"><a href="#现实应用-3" class="headerlink" title="现实应用"></a>现实应用</h4><h5 id="1-JavaMail"><a href="#1-JavaMail" class="headerlink" title="1.JavaMail"></a>1.JavaMail</h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109134412228.png" alt="image-20241109134412228"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在实际应用中，可以对上面代码进行重构，自行创建建造者类，如“成功注册邮件”建造者，“广告邮件”建造者，并增加抽象建造者和指挥者，用户可以用来创建所需的不同邮件对象。 </span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109134451352.png" alt="image-20241109134451352"></p>
<h5 id="2-游戏中不同类型的地图或人物"><a href="#2-游戏中不同类型的地图或人物" class="headerlink" title="2.游戏中不同类型的地图或人物"></a>2.游戏中不同类型的地图或人物</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-3"><a href="#模式扩展-3" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="建造者模式的简化"><a href="#建造者模式的简化" class="headerlink" title="建造者模式的简化"></a>建造者模式的简化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">省略抽象建造者角色：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。 </span><br><span class="line"></span><br><span class="line">省略指挥者角色：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色。</span><br><span class="line"></span><br><span class="line">把指挥者类和抽象建造者进行合并，简化了系统结构，但同时也加重了抽象建造者类的职责，也不符合单一职责原则，如果construct()过于复杂，建议还是封装到指挥者类中。</span><br></pre></td></tr></table></figure>



<h4 id="建造者模式与抽象工厂模式的比较"><a href="#建造者模式与抽象工厂模式的比较" class="headerlink" title="建造者模式与抽象工厂模式的比较"></a>建造者模式与抽象工厂模式的比较</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">与抽象工厂模式相比，建造者模式返回一个组装好的完整产品</span><br><span class="line">在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象</span><br><span class="line"></span><br><span class="line">而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</span><br><span class="line">而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装和建造过程，它侧重于一步步构造一个复杂对象，返回一个完整的对象。  </span><br></pre></td></tr></table></figure>





<h4 id="建造者模式的本质"><a href="#建造者模式的本质" class="headerlink" title="建造者模式的本质"></a>建造者模式的本质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分离整体构建算法和部件构造</span><br></pre></td></tr></table></figure>





















<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Prototype Pattern</span><br><span class="line"></span><br><span class="line">用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节.</span><br><span class="line">基本工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝原型自己来实现创建过程。</span><br><span class="line"></span><br><span class="line">一种对象创建型模式 </span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-4"><a href="#解决的问题-4" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，更方便、更高效且节省资源</span><br></pre></td></tr></table></figure>



<h3 id="解决的方式-2"><a href="#解决的方式-2" class="headerlink" title="解决的方式"></a>解决的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义抽象原型类：定义具有克隆自己的方法的接口</span><br><span class="line">定义具体原型类：继承抽象原型类，实现具体的克隆方法</span><br><span class="line">定义客户类：客户类中只需要直接实例化或通过工厂方法等方式创建一个对象，再通过调用该对象的克隆方法复制得到多个相同的对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Java语言中的原型模式实现很简单：</span><br><span class="line">java中的所有类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。</span><br><span class="line">因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆</span><br><span class="line"></span><br><span class="line">能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制</span><br><span class="line">如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。 </span><br><span class="line"></span><br><span class="line">一般而言，clone()方法满足： </span><br><span class="line">	(1) 对任何的对象x，都有x.clone() !=x，即克隆对象与原对象不是同一个对象。</span><br><span class="line">	(2) 对任何的对象x，都有x.clone().getClass()==x.getClass()，即克隆对象与原对象的类型一样。</span><br><span class="line">	(3) 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-4"><a href="#模式结构-4" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109160234865.png" alt="image-20241109160234865"></p>
<h3 id="模式优缺点-4"><a href="#模式优缺点-4" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-4"><a href="#模式优点-4" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。</span><br><span class="line"></span><br><span class="line">扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。 </span><br><span class="line"></span><br><span class="line">原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，</span><br><span class="line">而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</span><br><span class="line"></span><br><span class="line">可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-4"><a href="#模式缺点-4" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。</span><br><span class="line"></span><br><span class="line">在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-4"><a href="#模式适用环境-4" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建新对象成本较大</span><br><span class="line">如创建对象的构造函数非常的复杂，在执行这个构造函数时会消耗较多的CPU或内存资源，同时，这个构造函数中的一些信息又没有什么变化，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其属性稍作修改。</span><br><span class="line"></span><br><span class="line">如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。</span><br><span class="line">相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。</span><br><span class="line"></span><br><span class="line">需要避免创建一个与产品类层次平行的工厂类层次时，并且类的实例对象只能有几个不同状态组合中的一种时，建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-4"><a href="#现实应用-4" class="headerlink" title="现实应用"></a>现实应用</h4><h5 id="1-复制和粘贴"><a href="#1-复制和粘贴" class="headerlink" title="1.复制和粘贴"></a>1.复制和粘贴</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的应用，复制得到的对象与原型对象是两个类型相同但内存地址不同的对象，通过原型模式可以大大提高对象的创建效率</span><br><span class="line">很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的应用，复制得到的对象与原型对象是两个类型相同但内存地址不同的对象，通过原型模式可以大大提高对象的创建效率</span><br></pre></td></tr></table></figure>



<h5 id="2-Struts2中的Action对象创建"><a href="#2-Struts2中的Action对象创建" class="headerlink" title="2.Struts2中的Action对象创建"></a>2.Struts2中的Action对象创建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在Struts2中为了保证线程的安全性，Action对象的创建使用了原型模式</span><br><span class="line">访问一个已经存在的Action对象时将通过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个Action中都有自己的成员变量，避免Struts1因使用单例模式而导致的并发和同步问题。</span><br></pre></td></tr></table></figure>



<h5 id="3-Spring中bean实例的创建"><a href="#3-Spring中bean实例的创建" class="headerlink" title="3.Spring中bean实例的创建"></a>3.Spring中bean实例的创建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Spring中，用户也可以采用原型模式来创建新的bean实例，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-4"><a href="#模式扩展-4" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="带原型管理器的原型模式"><a href="#带原型管理器的原型模式" class="headerlink" title="带原型管理器的原型模式"></a>带原型管理器的原型模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原型管理器(Prototype Manager)</span><br><span class="line">将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象。</span><br><span class="line">如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程，以便扩展。 </span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109162441051.png" alt="image-20241109162441051"></p>
<h4 id="相似对象的复制"><a href="#相似对象的复制" class="headerlink" title="相似对象的复制"></a>相似对象的复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">很多情况下，复制所得到的对象与原型对象并不是完全相同的，它们的某些属性值存在异同。</span><br><span class="line">通过原型模式获得相同对象后可以再对其属性进行修改，从而获取所需对象。</span><br><span class="line">如多个学生对象的信息的区别在于性别、姓名和年龄，而专业、学院、学校等信息都相同，为了简化创建过程，可以通过原型模式来实现相似对象的复制。 </span><br></pre></td></tr></table></figure>



<h4 id="浅克隆和深克隆"><a href="#浅克隆和深克隆" class="headerlink" title="浅克隆和深克隆"></a>浅克隆和深克隆</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浅克隆复制对象的字段值：对于基本数据类型，则复制值；对于复合数据类型，仅复制该字段值，如数组变量则复制地址，对于对象变量则复制对象的reference</span><br><span class="line">深克隆与浅克隆的区别在于对复合数据类型的复制。若对象中的某个字段为复合类型，在克隆对象的时候，需要为该字段重新创建一个对象。</span><br></pre></td></tr></table></figure>



<h4 id="原型模式与拷贝构造比较"><a href="#原型模式与拷贝构造比较" class="headerlink" title="原型模式与拷贝构造比较"></a>原型模式与拷贝构造比较</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对比拷贝构造，通过原型对象创建新的对象，就不再需要关心/知道这个对象本身的类型，如复印机。</span><br><span class="line">对比拷贝构造，原型模式有助于符合里氏替换原则，如水果篮里放入水果副本。</span><br></pre></td></tr></table></figure>







<h3 id="模式本质-3"><a href="#模式本质-3" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">克隆生成对象</span><br></pre></td></tr></table></figure>



















<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Singleton Pattern</span><br><span class="line"></span><br><span class="line">单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</span><br><span class="line"></span><br><span class="line">一种对象创建型模式。</span><br><span class="line"></span><br><span class="line">单例模式有三个要点：</span><br><span class="line">	一是某个类只能有一个实例；</span><br><span class="line">	二是它必须自行创建这个实例；</span><br><span class="line">	三是它必须自行向整个系统提供这个实例</span><br><span class="line"></span><br><span class="line">单例模式又名单件模式或单态模式。</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-5"><a href="#解决的问题-5" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于系统中的某些类来说，只有一个实例很重要</span><br><span class="line">如何保证一个类只有一个实例并且这个实例易于被访问呢</span><br><span class="line">定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。</span><br><span class="line">一个更好的解决办法是让类自身负责保存它的唯一实例</span><br></pre></td></tr></table></figure>



<h3 id="解决的方式-3"><a href="#解决的方式-3" class="headerlink" title="解决的方式"></a>解决的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单例类的构造函数为私有；</span><br><span class="line">提供一个自身的静态私有成员变量；</span><br><span class="line">提供一个公有的静态工厂方法。</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-5"><a href="#模式结构-5" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109163844037.png" alt="image-20241109163844037"></p>
<h3 id="模式优缺点-5"><a href="#模式优缺点-5" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-5"><a href="#模式优点-5" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提供了对唯一实例的受控访问。</span><br><span class="line">因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的机制。</span><br><span class="line"></span><br><span class="line">由于在系统内存中只存在一个对象，因此可以节约系统资源</span><br><span class="line">对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</span><br><span class="line"></span><br><span class="line">允许可变数目的实例。</span><br><span class="line">我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-5"><a href="#模式缺点-5" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</span><br><span class="line"></span><br><span class="line">单例类的职责过重，在一定程度上违背了“单一职责原则”。</span><br><span class="line">因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</span><br><span class="line"></span><br><span class="line">滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出。</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-5"><a href="#模式适用环境-5" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</span><br><span class="line"></span><br><span class="line">客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</span><br><span class="line"></span><br><span class="line">在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="现实应用-5"><a href="#现实应用-5" class="headerlink" title="现实应用"></a>现实应用</h4><h5 id="1-Java-lang-Runtime类"><a href="#1-Java-lang-Runtime类" class="headerlink" title="1.Java.lang.Runtime类"></a>1.Java.lang.Runtime类</h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109164337681.png" alt="image-20241109164337681"></p>
<h5 id="2-数据库中自动编号的主键编号生成器"><a href="#2-数据库中自动编号的主键编号生成器" class="headerlink" title="2.数据库中自动编号的主键编号生成器"></a>2.数据库中自动编号的主键编号生成器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个具有自动编号主键的表可以有多个用户同时使用，但数据库中只能有一个地方分配下一个主键编号，否则会出现主键重复，因此该主键编号生成器必须具备唯一性，可以通过单例模式来实现</span><br></pre></td></tr></table></figure>



<h5 id="3-默认情况下Spring创建bean实例"><a href="#3-默认情况下Spring创建bean实例" class="headerlink" title="3.默认情况下Spring创建bean实例"></a>3.默认情况下Spring创建bean实例</h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109164527600.png" alt="image-20241109164527600"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Spring中，bean是有范围属性的，这个范围是时间、空间维度的，叫做scope，一个bean如果存在于应用的整个生命期内，就是一个shared bean instance，它的scope值是singleton，如果一个bean只存在于应用生命期的一段时间内，是一个prototype bean instance，它的scope值就是prototype。</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-5"><a href="#模式扩展-5" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="饿汉式单例类"><a href="#饿汉式单例类" class="headerlink" title="饿汉式单例类"></a>饿汉式单例类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">饿汉式单例类在自己被加载时就将自己实例化。</span><br><span class="line"></span><br><span class="line">单从资源利用效率角度来讲，这个比懒汉式单例类稍差些。</span><br><span class="line">从速度和反应时间角度来讲，则比懒汉式单例类稍好些。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109164836905.png" alt="image-20241109164836905"></p>
<h4 id="懒汉式单例类"><a href="#懒汉式单例类" class="headerlink" title="懒汉式单例类"></a>懒汉式单例类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">懒汉式单例类在实例化时，必须处理好在多个线程同时首次引用此类时的访问限制问题</span><br><span class="line">特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过同步化机制进行控制。</span><br><span class="line">public static synchronized Singleton get Instance()</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241109164930590.png" alt="image-20241109164930590"></p>
<h3 id="模式本质-4"><a href="#模式本质-4" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制实例数目</span><br></pre></td></tr></table></figure>





















<h1 id="结构性模式"><a href="#结构性模式" class="headerlink" title="结构性模式"></a>结构性模式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">描述如何将类或对象结合在一起形成更大的结构</span><br></pre></td></tr></table></figure>





<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="类结构模式"><a href="#类结构模式" class="headerlink" title="类结构模式"></a>类结构模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关心类的组合，多个类组合成一个更大的系统</span><br><span class="line"></span><br><span class="line">一般只存在继承关系和实现关系</span><br></pre></td></tr></table></figure>



<h3 id="对象结构模式"><a href="#对象结构模式" class="headerlink" title="对象结构模式"></a>对象结构模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关心类与对象的组合</span><br><span class="line"></span><br><span class="line">通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法，根据合成复用原则，在系统中尽量使用关联关系来替代继承关系。</span><br><span class="line"></span><br><span class="line">大部分结构型模式都是对象结构型模式</span><br></pre></td></tr></table></figure>







<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Adapter Pattern</span><br><span class="line"></span><br><span class="line">将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，别名为包装器</span><br><span class="line"></span><br><span class="line">既可以作为类结构型模式，也可以作为对象结构型模式</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-6"><a href="#解决的问题-6" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现有类可以满足客户类的功能需要，但提供的接口不一定是客户类所期望的，可能是类内方法名与目标类中定义的方法名不一致等原因导致的，适配器模式对现有接口进行转化，保证对现有类的重用</span><br><span class="line"></span><br><span class="line">适配器可以使由于接口不兼容而不能交互的类一起工作</span><br></pre></td></tr></table></figure>



<h3 id="解决方式-1"><a href="#解决方式-1" class="headerlink" title="解决方式"></a>解决方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义目标类：一个抽象类或接口，定义客户所需接口</span><br><span class="line">定义客户类：</span><br><span class="line">定义适配器：一个包装类，包装不兼容接口的对象</span><br><span class="line">定义适配者：被适配的类</span><br><span class="line"></span><br><span class="line">实现适配器：继承目标类，将客户类的请求转化为对适配者的相应接口的调用，当客户类调用适配器的方法时，在适配器类内部调用适配者类的方法</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-6"><a href="#模式结构-6" class="headerlink" title="模式结构"></a>模式结构</h3><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241022192024368.png" alt="image-20241022192024368"></p>
<h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241022192053856.png" alt="image-20241022192053856"></p>
<h3 id="模式优缺点-6"><a href="#模式优缺点-6" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将目标类和适配者类解耦：引入一个适配器类来重用现有的适配者类，无需修改原有代码</span><br><span class="line"></span><br><span class="line">增加了类的透明性和复用性：将具体的实现封装在适配者类中，对于客户端透明，提高了适配者的复用性</span><br><span class="line"></span><br><span class="line">灵活性和扩展性都非常好：可以通过使用配置文件来便利地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类</span><br><span class="line"></span><br><span class="line">完全符合“开闭原则”</span><br></pre></td></tr></table></figure>





<h5 id="对于类适配器而言"><a href="#对于类适配器而言" class="headerlink" title="对于类适配器而言"></a>对于类适配器而言</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">适配器类是适配者类的子类，所以可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强</span><br></pre></td></tr></table></figure>



<h5 id="对于对象适配器而言"><a href="#对于对象适配器而言" class="headerlink" title="对于对象适配器而言"></a>对于对象适配器而言</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个对象适配器可以把适配者类和它的子类都适配到目标接口，即可以把多个不同的适配者适配到同一个目标</span><br></pre></td></tr></table></figure>







<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">见下方</span><br></pre></td></tr></table></figure>





<h5 id="对于类适配器而言-1"><a href="#对于类适配器而言-1" class="headerlink" title="对于类适配器而言"></a>对于类适配器而言</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于不支持多重继承的语言，一次最多只能适配一个适配者类，并且目标抽象类只能为抽象类，不能为具体类，不能将一个适配者类和它的子类都是配到目标接口</span><br></pre></td></tr></table></figure>



<h5 id="对于对象适配器而言-1"><a href="#对于对象适配器而言-1" class="headerlink" title="对于对象适配器而言"></a>对于对象适配器而言</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与类适配器模式相比，置换适配者类的方法比较麻烦，需要先实现一个适配者类的子类置换适配者类的方法，再把适配者类的子类当做真正的适配者进行适配</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-6"><a href="#模式适用环境-6" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统需要适用现有的类，但其接口不符合系统的需要</span><br><span class="line"></span><br><span class="line">想建立一个可以重复使用的类（适配器类），用来与一些彼此没有太大关联的类（目标类和适配者类），及一些可能在未来引进的类（适配者类的子类）一起工作</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-6"><a href="#现实应用-6" class="headerlink" title="现实应用"></a>现实应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JDBC驱动软件</span><br><span class="line"></span><br><span class="line">JDK类库中的InputStreamAdapter类</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-6"><a href="#模式扩展-6" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Default Adapter Pattern</span><br><span class="line"></span><br><span class="line">或缺省适配器模式、接口适配器模式、单接口适配器模式</span><br></pre></td></tr></table></figure>





<h5 id="解决的问题-7"><a href="#解决的问题-7" class="headerlink" title="解决的问题"></a>解决的问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个接口不想使用其所有方法时，即不需要全部实现接口提供的方法时如何实现适配器</span><br></pre></td></tr></table></figure>



<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现抽象类实现接口：为该接口中每个方法提供一个默认实现，即空方法，该抽象类的子类可有选择地覆盖父类地某些方法来实现需求</span><br></pre></td></tr></table></figure>



<h5 id="模式结构-7"><a href="#模式结构-7" class="headerlink" title="模式结构"></a>模式结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">自上到下分别为</span><br><span class="line">适配者接口：声明大量方法</span><br><span class="line"></span><br><span class="line">默认适配器类：该模式的核心类，使用空方法形式实现在ServiceInterface接口中声明的方法，通常定义为抽象类，对其实例化无意义</span><br><span class="line"></span><br><span class="line">具体业务类：是上一个类的子类，可以直接有选择性地覆盖在适配器中定义的方法</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241022205050570.png" alt="image-20241022205050570"></p>
<h5 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK中提供的适配器类WindowAdapter实现WindowLinsener接口，为该接口中每一个方法都提供了一个空实现，此时事件处理类可以继承WindowAdapter类，而无需为接口中的每个方法都提供实现</span><br></pre></td></tr></table></figure>







<h4 id="双向适配器模式"><a href="#双向适配器模式" class="headerlink" title="双向适配器模式"></a>双向适配器模式</h4><h5 id="解决的问题-8"><a href="#解决的问题-8" class="headerlink" title="解决的问题"></a>解决的问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以在目标类的用户可以调用适配者方法的同时，让适配者类的使用者也可以调用目标类中的方法</span><br></pre></td></tr></table></figure>



<h5 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现适配器类：在适配器中同时包含对目标类和适配者类的引用</span><br></pre></td></tr></table></figure>



<h5 id="模式结构-8"><a href="#模式结构-8" class="headerlink" title="模式结构"></a>模式结构</h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241022210622966.png" alt="image-20241022210622966"></p>
<h4 id="智能适配器模式"><a href="#智能适配器模式" class="headerlink" title="智能适配器模式"></a>智能适配器模式</h4><h5 id="解决的问题-9"><a href="#解决的问题-9" class="headerlink" title="解决的问题"></a>解决的问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在转换匹配的过程中，在转换调用的前后实现一些功能处理，进一步还可以按需复用不同的适配者</span><br></pre></td></tr></table></figure>







<h4 id="适配多个适配者模式"><a href="#适配多个适配者模式" class="headerlink" title="适配多个适配者模式"></a>适配多个适配者模式</h4><h5 id="解决的问题-10"><a href="#解决的问题-10" class="headerlink" title="解决的问题"></a>解决的问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在转换匹配的过程中，适配多个适配者，在实现目标接口时，要调用多个模块的功能。适配多个适配者才能满足目标接口要求</span><br></pre></td></tr></table></figure>







<h3 id="模式本质-5"><a href="#模式本质-5" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换匹配，复用功能</span><br></pre></td></tr></table></figure>





















<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Bridge Pattern</span><br><span class="line"></span><br><span class="line">将抽象部分与它的实现部分分离，使他们都可以独立地变化</span><br><span class="line"></span><br><span class="line">一种对象结构型模式</span><br><span class="line"></span><br><span class="line">又称柄体模式或接口模式</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-11"><a href="#解决的问题-11" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理具有多变化维度的实体的建模</span><br></pre></td></tr></table></figure>



<h3 id="解决方式-2"><a href="#解决方式-2" class="headerlink" title="解决方式"></a>解决方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义抽象类：一般为抽象类而不是接口，其中定义了一个实现类接口类型的对象，并维护该对象，两者之间是关联关系。既可以包含抽象业务方法，也可以包含具体业务方法。</span><br><span class="line">定义扩充抽象类：扩充由抽象类定义的接口，通常为具体类，实现抽象类中的抽象业务方法，也可调用实现类接口中的业务方法</span><br><span class="line">定义实现类接口：通常只提供基本操作，子类来提供方法的具体实现，从而抽象类可以调用实现类子类中的方式，这样就用关联关系替代了继承关系</span><br><span class="line">定义具体实现类：具体实现实现类接口中方法，向抽象类提供具体的业务方法</span><br><span class="line"></span><br><span class="line">若有两个独立变化维度，通常将普通业务方法和与之关系最密切的维度设计为“抽象”类层次，另一个维度设计为“实现类”层次</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-9"><a href="#模式结构-9" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241023171958983.png" alt="image-20241023171958983"></p>
<h3 id="模式优缺点-7"><a href="#模式优缺点-7" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用对象间的关联关系解耦了抽象和实现之间固有的绑定关系。使得抽象和实现可以沿着各自的维度来变化，即将抽象和实现分开到不同的继承层次结构中</span><br><span class="line"></span><br><span class="line">与多重/多层继承方案相比，遵守了“单一职责原则”，复用性较好，极大减少了子类的个数</span><br><span class="line"></span><br><span class="line">提高了系统的可拓展性，任意拓展多维度中的一个都不需要修改原有系统，符合“开闭原则”</span><br></pre></td></tr></table></figure>



<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统理解和设计难度较大，需要一开始就在抽象层上建立关联关系</span><br><span class="line"></span><br><span class="line">正确识别出独立变化的维度需要经验</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-7"><a href="#模式适用环境-7" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个类存在多个独立变化的维度，且存在独立扩展需求的维度</span><br><span class="line"></span><br><span class="line">不希望由于多重/多层继承导致类个数急剧增加的系统</span><br></pre></td></tr></table></figure>



<h4 id="现实应用-7"><a href="#现实应用-7" class="headerlink" title="现实应用"></a>现实应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java语言通过Java虚拟机实现了平台的无关性</span><br><span class="line"></span><br><span class="line">Java在AWT中的每一个GUI构件中都提供了一个Peer构件，实现了Peer架构，为Java桌面软件提供了所在操作系统的LookAndFeel，即视感</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-7"><a href="#模式扩展-7" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="适配器模式与桥接模式联用"><a href="#适配器模式与桥接模式联用" class="headerlink" title="适配器模式与桥接模式联用"></a>适配器模式与桥接模式联用</h4><h5 id="解决的问题-12"><a href="#解决的问题-12" class="headerlink" title="解决的问题"></a>解决的问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">适配器所适配的类往往是一个黑盒，通常开发人员不想也不能改变这个给被适配的类，也不能控制其扩展，所以加入桥接模式可以提高系统的扩展性</span><br><span class="line"></span><br><span class="line">或者在完成桥接模式的设计和实现后，为与现存的类能一起工作，通过适配器模式来引入已有类对系统进行扩展。</span><br></pre></td></tr></table></figure>







<h3 id="模型本质"><a href="#模型本质" class="headerlink" title="模型本质"></a>模型本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分离抽象和实现</span><br></pre></td></tr></table></figure>





















<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Composite Pattern</span><br><span class="line"></span><br><span class="line">组合多个对象形成树形结构以表示“整体-部分”关系的层次结构， 组合模式对单个对象（叶子）和组合对象（容器）的使用具有一致性</span><br><span class="line"></span><br><span class="line">对象结构型模式</span><br><span class="line"></span><br><span class="line">又称“整体-部分”模式</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-13"><a href="#解决的问题-13" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运用面向对象的方式来处理如目录结构、菜单、公司组织结构等树形结构，使得客户端可以一致性地处理整个树形结构或者树形结构的一部分，也可以一致性地处理树形结构中的叶子节点（不包含子节点的节点）和容器节点（包含子节点的节点）</span><br></pre></td></tr></table></figure>



<h3 id="解决方式-3"><a href="#解决方式-3" class="headerlink" title="解决方式"></a>解决方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义抽象组件：接口或抽象类，为叶子组件和容器组件对象声明接口，包含所有子类共有行为的声明和实现，访问及管理它的子组件的方法，如增删查找</span><br><span class="line">定义叶子组件：实现在从抽象组件中定义的行为，通过异常等方式处理有关子组件的方法</span><br><span class="line">定义容器组件：提供一个集合存储子节点，实现在抽象组件中定义的行为，业务方法中可以递归调用子节点的业务方法</span><br><span class="line">定义客户类：针对抽象组件类进行编程</span><br><span class="line"></span><br><span class="line">容器组件和抽象组件之间建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成树形结构</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-10"><a href="#模式结构-10" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241023191836114.png" alt="image-20241023191836114"></p>
<h3 id="模式优缺点-8"><a href="#模式优缺点-8" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义了包含基本对象和组合对象的类层次结构</span><br><span class="line"></span><br><span class="line">统一了组合对象和叶子对象</span><br><span class="line"></span><br><span class="line">简化了客户端调用</span><br><span class="line"></span><br><span class="line">且更容易扩展，无论是添加容器还是叶子类</span><br></pre></td></tr></table></figure>



<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">很难限制组合中的组件类型，很难限制容器中只能包含特定类型的组件（如只能包含其它容器节点或只能包含叶子节点或其他需求），组件类型的检测依赖运行期间的动态监测</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-8"><a href="#模式适用环境-8" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果想表示对象的整体-部分层次结构，可以选用组合模式，把整体和部分的操作统一起来，使得层次结构实现更简单，从外部来使用这个层次结构也简单。</span><br><span class="line">如果希望统一的使用组合结构中的所有对象，可以选用组合模式，这正是组合模式提供的主要功能。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-8"><a href="#现实应用-8" class="headerlink" title="现实应用"></a>现实应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XML文档是树形结构，XML解析工具也通过组合模式对XML文档进行解析</span><br><span class="line"></span><br><span class="line">操作系统的目录结构</span><br><span class="line"></span><br><span class="line">JDK的AWT/Swing也是经典的组合模式，就是Component和那些具体的类</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-8"><a href="#模式扩展-8" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="透明组合模式"><a href="#透明组合模式" class="headerlink" title="透明组合模式"></a>透明组合模式</h4><h5 id="解决的问题-14"><a href="#解决的问题-14" class="headerlink" title="解决的问题"></a>解决的问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即组合模式的标准形式</span><br></pre></td></tr></table></figure>



<h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">确保所有的组件类都有相同接口</span><br></pre></td></tr></table></figure>



<h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不够安全，调用叶子对象中管理子组件的方法在没有提供相应错误处理代码的情况下可能会出错</span><br></pre></td></tr></table></figure>







<h4 id="安全组合模式"><a href="#安全组合模式" class="headerlink" title="安全组合模式"></a>安全组合模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在抽象组件中没有声明任何用于管理成员对象的方法，只在容器类中声明并实现这些方法</span><br></pre></td></tr></table></figure>



<h5 id="好处-1"><a href="#好处-1" class="headerlink" title="好处"></a>好处</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安全。叶子对象根本调用不到管理子组件的方法</span><br></pre></td></tr></table></figure>



<h5 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不够透明，客户端无法完全针对抽象编程，要区别对待叶子和容器组件</span><br></pre></td></tr></table></figure>







<h4 id="更复杂的组合模式"><a href="#更复杂的组合模式" class="headerlink" title="更复杂的组合模式"></a>更复杂的组合模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对叶子节点和容器节点进行抽象，定义更多子类</span><br></pre></td></tr></table></figure>







<h3 id="模式本质-6"><a href="#模式本质-6" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">统一叶子对象和组合对象</span><br></pre></td></tr></table></figure>





















<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Decorator Pattern</span><br><span class="line"></span><br><span class="line">动态地给一个对象增加一些额外的职责</span><br><span class="line"></span><br><span class="line">对象结构型模式</span><br><span class="line"></span><br><span class="line">又称“油漆工模式”</span><br><span class="line"></span><br><span class="line">符合合成复用原则</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-15"><a href="#解决的问题-15" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">替代通过继承机制这种静态的，用户不能控制增加行为的方式和时机的为类或对象增加行为或新功能的方式，即使用对象之间的关联关系来取代类之间的继承关系来扩充原有类的功能</span><br></pre></td></tr></table></figure>



<h3 id="解决方式-4"><a href="#解决方式-4" class="headerlink" title="解决方式"></a>解决方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">定义抽象组件：具体组件和抽象装饰类的共同父类，声明具体组件中实现的业务方法，使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象。</span><br><span class="line">定义具体组件：抽象组件类的子类，定义具体的组件对象，实现抽象组件中声明的方法。</span><br><span class="line">定义抽象装饰类：抽象组件类的子类，定义为具体组件增加职责的方法，在子类中实现。维护一个指向抽象组件对象的引用。可以调用和扩展组件对象的方法。</span><br><span class="line">定义具体装饰类：抽象装饰类的子类，实现具体装饰方法</span><br><span class="line"></span><br><span class="line">我们可以将一个具体组件或者一个被修饰后的组件注入到抽象装饰类中进行进一步扩展</span><br><span class="line"></span><br><span class="line">核心在于抽象装饰类的设计</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-11"><a href="#模式结构-11" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241024102340028.png" alt="image-20241024102340028"></p>
<h3 id="模式优缺点-9"><a href="#模式优缺点-9" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比继承更灵活，在程序运行中动态组合装饰的对象</span><br><span class="line"></span><br><span class="line">符合合成复用功能，将一系列复杂的功能分散到每个装饰器中，简化了装饰器的实现，同时使装饰的组合更灵活。</span><br><span class="line"></span><br><span class="line">优化高层定义，只需定义最基本的功能，使用时组合相应的装饰器来完成需要的功能</span><br></pre></td></tr></table></figure>



<h4 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若功能复杂，考虑单个装饰器只能实现一个功能，细粒度对象数量多，占用更多系统资源以至影响程序性能</span><br><span class="line"></span><br><span class="line">比继承更容易出现错误，同时排查错误也很困难，多次装饰的对象需要逐级排查</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-9"><a href="#模式适用环境-9" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要在不影响其它对象前提下，动态、透明地给单个对象添加职责</span><br><span class="line"></span><br><span class="line">当不能采用继承的方式对系统进行扩展或采用继承不利于系统扩展和维护时</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-9"><a href="#现实应用-9" class="headerlink" title="现实应用"></a>现实应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javax.swing中通过装饰模式动态给一些组件增加新的行为或改善其外观显示</span><br><span class="line"></span><br><span class="line">JDK中的JavaIO,提供了FilterInputStream这样的抽象装饰类来装饰一些组件类。</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-9"><a href="#模式扩展-9" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="透明装饰系统"><a href="#透明装饰系统" class="headerlink" title="透明装饰系统"></a>透明装饰系统</h4><h5 id="解决的问题-16"><a href="#解决的问题-16" class="headerlink" title="解决的问题"></a>解决的问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端完全针对抽象编程，不能声明具体组件类型和具体装饰类型</span><br></pre></td></tr></table></figure>







<h4 id="半透明装饰模式"><a href="#半透明装饰模式" class="headerlink" title="半透明装饰模式"></a>半透明装饰模式</h4><h5 id="解决的问题-17"><a href="#解决的问题-17" class="headerlink" title="解决的问题"></a>解决的问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法</span><br></pre></td></tr></table></figure>







<h4 id="装饰模式的简化"><a href="#装饰模式的简化" class="headerlink" title="装饰模式的简化"></a>装饰模式的简化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尽量保持装饰类的接口和被装饰类的接口相同，便于客户端一致管理，故应该尽量使用透明装饰模式</span><br><span class="line">尽量保证具体组件类是一个“轻类”，不要把太多行为放在具体组件类中。</span><br><span class="line">若只有一个具体组件类，抽象装饰类可以作为该具体组件类的直接子类</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241024122455137.png" alt="image-20241024122455137"></p>
<h3 id="模式本质-7"><a href="#模式本质-7" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动态组合</span><br><span class="line"></span><br><span class="line">动态是手段，组合才是目的</span><br><span class="line"></span><br><span class="line">这里的组合有两个意思，一个是动态功能的组合，也就是动态进行装饰器的组合；另外一个是指对象组合，通过对象组合为被装饰对象透明的增加功能。</span><br></pre></td></tr></table></figure>





















<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Facade Pattern</span><br><span class="line"></span><br><span class="line">为子系统中的一组接口提供一个统一的入口，定义了一个高层接口，使得子系统更加容易使用。子系统是一个广义的概念，可以是一个类，一个功能模块，系统的一个组成部分或一个完整的系统。</span><br><span class="line"></span><br><span class="line">对象结构型模式</span><br><span class="line"></span><br><span class="line">又称门面模式</span><br><span class="line"></span><br><span class="line">是迪米特原则的一种具体实现，降低客户类与子系统的耦合度和原系统的复杂度</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-18"><a href="#解决的问题-18" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端在不与系统中多个模块交互的的情况下可以组合多模块提供的功能来实现自己所需的功能</span><br></pre></td></tr></table></figure>



<h3 id="解决方式-5"><a href="#解决方式-5" class="headerlink" title="解决方式"></a>解决方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义外观角色：客户端调用其方法，其将客户端的请求委派到相应子系统对象处理</span><br><span class="line">定义子系统角色：可以不是一个单独的类，而是一个类的集合，可以被客户端直接调用或被外观角色调用，不区分客户端或外观角色</span><br><span class="line"></span><br><span class="line">注意，不要试图通过外观类为子系统增加新行为</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-12"><a href="#模式结构-12" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241024124944799.png" alt="image-20241024124944799"></p>
<h3 id="模式优缺点-10"><a href="#模式优缺点-10" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，简化了客户端代码</span><br><span class="line"></span><br><span class="line">实现了子系统和客户端的松耦合，可以在不影响客户类的情况下，实现子系统内部的维护和扩展，是实现代码重构以达到“迪米特法则”要求的有力工具</span><br><span class="line"></span><br><span class="line">只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类</span><br><span class="line"></span><br><span class="line">合理使用可以划分访问的层次，可以将暴露外部的功能集中到外观中，方便客户端使用的同时隐藏了内部的细节</span><br></pre></td></tr></table></figure>



<h4 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不能很好地限制客户端直接使用子系统类，同时对访问子系统做出的限制减少了额可变性和灵活性</span><br><span class="line"></span><br><span class="line">设计不当的话增加新的子系统可能需要修改外观类的源代码，违背开闭原则</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-10"><a href="#模式适用环境-10" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当为一个复杂子系统提供一个简单接口时</span><br><span class="line"></span><br><span class="line">客户端与多个子系统间依赖性强，需要解耦时</span><br><span class="line"></span><br><span class="line">层次化结构中需要定义每一层的入口，且层和层之间不直接产生联系，而通过外观类建立联系时</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-10"><a href="#现实应用-10" class="headerlink" title="现实应用"></a>现实应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简化JDBC繁琐的连接数据库到获取结果集的代码，定义一个JDBCFacade类</span><br><span class="line"></span><br><span class="line">JavaEE框架中SessionFacade的实现</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-10"><a href="#模式扩展-10" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="单系统多外观类"><a href="#单系统多外观类" class="headerlink" title="单系统多外观类"></a>单系统多外观类</h4><h5 id="解决的问题-19"><a href="#解决的问题-19" class="headerlink" title="解决的问题"></a>解决的问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个系统需要多个外观类分别集成不同子系统，并统一对外提供接口</span><br></pre></td></tr></table></figure>







<h4 id="抽象外观类的引入"><a href="#抽象外观类的引入" class="headerlink" title="抽象外观类的引入"></a>抽象外观类的引入</h4><h5 id="解决的问题-20"><a href="#解决的问题-20" class="headerlink" title="解决的问题"></a>解决的问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了避免增加，删除或更换与外观类交互的子系统类导致外观类或客户端源代码的修改，违背开闭原则</span><br></pre></td></tr></table></figure>



<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端针对抽象外观类编程，新增的业务需求对应新的子系统对象，增加新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码来更换外观类的目的</span><br></pre></td></tr></table></figure>







<h3 id="模式本质-8"><a href="#模式本质-8" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">封装交互，简化调用</span><br></pre></td></tr></table></figure>





















<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Proxy Pattern</span><br><span class="line"></span><br><span class="line">给某一个对象提供一个代理，由代理对象控制对原对象的引用</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-21"><a href="#解决的问题-21" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端不想或不能直接访问一个对象，需要一个第三者来实现间接访问</span><br></pre></td></tr></table></figure>



<h3 id="解决方式-6"><a href="#解决方式-6" class="headerlink" title="解决方式"></a>解决方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义抽象主题角色：一个抽象类，声明真实主题和代理主题的共同接口，保证客户端在处理真实主题和代理主题的一致性</span><br><span class="line">定义真实主题角色：继承抽象主题类，定义代理角色代表的真实对象，实现真实的业务操作</span><br><span class="line">定义代理主题角色：继承抽象主题类，包含对真实主题的引用，提供一个与真实主题角色相同的接口，可以控制对真实主题的使用，可以在需要时创建和删除真实主题对象，可以对真实主题对象的使用加以越是，也可以在调用真实主题操作之前或之后执行其它操作</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-13"><a href="#模式结构-13" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241024204757732.png" alt="image-20241024204757732"></p>
<h3 id="模式优缺点-11"><a href="#模式优缺点-11" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-6"><a href="#模式优点-6" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</span><br><span class="line"></span><br><span class="line">客户端可以针对抽象主题进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。</span><br><span class="line"></span><br><span class="line">远程代理：为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。</span><br><span class="line"></span><br><span class="line">虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，在一定程度上节省系统的运行开销。</span><br><span class="line"></span><br><span class="line">缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。</span><br><span class="line"></span><br><span class="line">保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-6"><a href="#模式缺点-6" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</span><br><span class="line"></span><br><span class="line">实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-11"><a href="#模式适用环境-11" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">远程代理：</span><br><span class="line">当客户端需要访问远程主机中的对象时可以使用远程代理。</span><br><span class="line"></span><br><span class="line">虚拟代理：</span><br><span class="line">当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。</span><br><span class="line"></span><br><span class="line">缓冲代理：当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。</span><br><span class="line"></span><br><span class="line">保护代理：</span><br><span class="line">当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。</span><br><span class="line"></span><br><span class="line">智能引用代理：当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-11"><a href="#现实应用-11" class="headerlink" title="现实应用"></a>现实应用</h4><h5 id="1-java-RMI"><a href="#1-java-RMI" class="headerlink" title="1. java RMI"></a>1. java RMI</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Remote Method Invocation，远程方法调用)</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241105111154896.png" alt="image-20241105111154896"></p>
<h5 id="2-Spring框架中的AOP技术"><a href="#2-Spring框架中的AOP技术" class="headerlink" title="2. Spring框架中的AOP技术"></a>2. Spring框架中的AOP技术</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在Spring AOP中应用了动态代理(Dynamic Proxy)技术，动态代理是一种较为高级的代理模式。 </span><br><span class="line"></span><br><span class="line">对于标准代理模式：</span><br><span class="line">各个角色在编译前就已存在，并且指定好了谁代理谁，执行效率高。因此也被称为静态代理模式。当有多个真实主题对象需要代理时，需要建立多个代理类。</span><br><span class="line">编译前就确定了谁代理谁，系统的灵活性差。</span><br><span class="line"></span><br><span class="line">对于动态代理模式：</span><br><span class="line">可以基于反射技术采用Java JDK提供的相应机制实现动态代理模式。</span><br><span class="line">当有多个真实主题对象时，只需要一个动态代理类即可， 避免了创建多个静态代理类的麻烦。</span><br><span class="line">可以在运行时根据实际需要为某个真实主题对象动态地创建一个代理对象，系统更加灵活。</span><br><span class="line">缺点是效率低，比静态代理慢一点，可读性差，不好理解。</span><br><span class="line">JDK动态代理只能对实现了接口的类进行代理。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java中动态代理的具体实现：</span><br><span class="line">JDK动态代理相关类位于java.lang.reflect包</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java中动态代理的具体实现</span><br><span class="line">JDK动态代理相关类位于java.lang.reflect包</span><br><span class="line">	InvocationHandler接口：</span><br><span class="line">	它是动态代理类对象所对应的调用处理程序类的接口，该接口中定义了如下方法：</span><br><span class="line">	public Object invoke (Object proxy, Method method, Object[] args)throws Throwable;</span><br><span class="line">	proxy表示代理类，method表示需要代理的方法，args表示代理方法的参数数组。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Proxy类：</span><br><span class="line">该类即为动态代理类，该类最常用的方法为：</span><br><span class="line">public static Object newProxyInstance (ClassLoader loader, 	Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException;</span><br><span class="line">该方法根据传入的参数返回一个动态创建的代理类对象，loader表示主题类(目标类)的类加载器，interfaces表示主题类(目标类)的接口列表，h表示调用处理程序对象，所有对代理类对象方法的调用都被委托给对象h，由对象h的invoke()进行相应的处理。</span><br></pre></td></tr></table></figure>





<h5 id="3-远程代理"><a href="#3-远程代理" class="headerlink" title="3.远程代理"></a>3.远程代理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DCOM（Distribute Component Object Model，分布式组件对象模型）、Web Service、Java RMI、CORBA中都应用了远程代理模式。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241105113457924.png" alt="image-20241105113457924"></p>
<h5 id="4-虚拟代理"><a href="#4-虚拟代理" class="headerlink" title="4.虚拟代理"></a>4.虚拟代理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对大图浏览的控制</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户通过浏览器访问网页时先不加载真实的大图，在代理对象的方法中，先使用一个线程向客户端浏览器加载一个小图片，然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新网页中显示。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果用户在浏览大图时加载工作还没有完成，可以再启动一个线程来显示相应的提示信息。通过代理技术结合多线程编程将真实图片的加载放到后台来操作，不影响前台图片的浏览。</span><br></pre></td></tr></table></figure>





<h3 id="模式扩展-11"><a href="#模式扩展-11" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Remote Proxy)</span><br><span class="line">一种常用代理模式，它使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端的请求</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。</span><br></pre></td></tr></table></figure>



<h4 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Virtual Proxy)</span><br><span class="line">如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</span><br></pre></td></tr></table></figure>



<h4 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Protect Proxy)</span><br><span class="line">控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</span><br></pre></td></tr></table></figure>



<h4 id="缓冲代理"><a href="#缓冲代理" class="headerlink" title="缓冲代理"></a>缓冲代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Cache Proxy)</span><br><span class="line">为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</span><br></pre></td></tr></table></figure>



<h4 id="智能引用代理"><a href="#智能引用代理" class="headerlink" title="智能引用代理"></a>智能引用代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Smart Reference Proxy)</span><br><span class="line">当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</span><br></pre></td></tr></table></figure>



<h4 id="防火墙代理"><a href="#防火墙代理" class="headerlink" title="防火墙代理"></a>防火墙代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Firewall Proxy)</span><br><span class="line">控制网络资源的访问，保护主题免于“坏客户”的侵害。常用在公司的防火墙系统。</span><br></pre></td></tr></table></figure>



<h4 id="同步代理"><a href="#同步代理" class="headerlink" title="同步代理"></a>同步代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Synchronization Proxy)</span><br><span class="line">在多线程的情况下为主题提供安全的访问。常用在JavaSpaces，为分散式环境内的潜在对象集合提供同步访问控制。</span><br></pre></td></tr></table></figure>



<h4 id="写入时复制代理"><a href="#写入时复制代理" class="headerlink" title="写入时复制代理"></a>写入时复制代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Copy-On-Write Proxy)</span><br><span class="line">用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。这是虚拟代理的变体。</span><br></pre></td></tr></table></figure>



<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(DynamicProxy)</span><br><span class="line">基于反射技术采用Java JDK提供的相应机制实现动态代理模式。</span><br><span class="line">当有多个真实主题对象时，只需要一个动态代理类即可， 避免了创建多个静态代理类的麻烦。</span><br><span class="line">可以在运行时根据实际需要为某个真实主题对象动态地创建一个代理对象，系统更加灵活。</span><br></pre></td></tr></table></figure>







<h3 id="模式本质-9"><a href="#模式本质-9" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制对象访问</span><br></pre></td></tr></table></figure>







<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Behavioral Pattern)</span><br><span class="line">是对在不同的对象之间划分责任和算法的抽象化。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。</span><br></pre></td></tr></table></figure>





<h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><h3 id="类行为型模式"><a href="#类行为型模式" class="headerlink" title="类行为型模式"></a>类行为型模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。</span><br></pre></td></tr></table></figure>



<h3 id="对象行为型模式"><a href="#对象行为型模式" class="headerlink" title="对象行为型模式"></a>对象行为型模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">满足“合成复用原则”，系统中使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。</span><br></pre></td></tr></table></figure>





















<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Chain of Responsibility Pattern</span><br><span class="line"></span><br><span class="line">处理请求链式传递的模式</span><br><span class="line"></span><br><span class="line">一种对象行为型模式</span><br><span class="line"></span><br><span class="line">又称为责任链模式。</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-22"><a href="#解决的问题-22" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将请求的处理者组织成一条链，请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现请求发送者和请求处理者解耦。</span><br></pre></td></tr></table></figure>



<h3 id="解决方式-7"><a href="#解决方式-7" class="headerlink" title="解决方式"></a>解决方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义抽象处理者角色：一般为抽象类，定义一个处理请求的接口，抽象请求处理方法以及一个抽象处理者类型对象（作为对下一个处理者的引用）</span><br><span class="line">定义具体处理者角色：继承或实现抽象处理类，实现抽象请求处理方法，在处理请求之前进行判断，满足条件则处理，不满足条件转发给后继处理者</span><br><span class="line"></span><br><span class="line">在客户端中创建职责链</span><br><span class="line"></span><br><span class="line">可以是一条链，一个环或者一个属性结构，最常见为直线型</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-14"><a href="#模式结构-14" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241105120359825.png" alt="image-20241105120359825"></p>
<h3 id="模式优缺点-12"><a href="#模式优缺点-12" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-7"><a href="#模式优点-7" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。</span><br><span class="line"></span><br><span class="line">请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。</span><br><span class="line"></span><br><span class="line">在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。</span><br><span class="line"></span><br><span class="line">在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-7"><a href="#模式缺点-7" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。</span><br><span class="line"></span><br><span class="line">对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</span><br><span class="line"></span><br><span class="line">如果建链不当，可能会造成循环调用，将导致系统陷入死循环。</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-12"><a href="#模式适用环境-12" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。</span><br><span class="line"></span><br><span class="line">在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</span><br><span class="line"></span><br><span class="line">可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-12"><a href="#现实应用-12" class="headerlink" title="现实应用"></a>现实应用</h4><h5 id="1-java中的异常处理机制"><a href="#1-java中的异常处理机制" class="headerlink" title="1. java中的异常处理机制"></a>1. java中的异常处理机制</h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241105122313988.png" alt="image-20241105122313988"></p>
<h5 id="2-SpringMVC中的过滤器Filter"><a href="#2-SpringMVC中的过滤器Filter" class="headerlink" title="2. SpringMVC中的过滤器Filter"></a>2. SpringMVC中的过滤器Filter</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Web应用开发中创建一个过滤器(Filter)链来对请求数据进行过滤，在工作流系统中实现公文的分级审批等等</span><br></pre></td></tr></table></figure>



<h5 id="3-事件浮升-Event-Bubbling-机制"><a href="#3-事件浮升-Event-Bubbling-机制" class="headerlink" title="3. 事件浮升(Event Bubbling)机制"></a>3. 事件浮升(Event Bubbling)机制</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是一种不纯的职责链模式</span><br><span class="line"></span><br><span class="line">早期的Java AWT事件模型(JDK 1.0及更早)(Java.1.1以后，JDK使用观察者模式代替职责链模式来处理事件)</span><br><span class="line">以及JavaScript事件浮升机制：</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241105122526719.png" alt="image-20241105122526719"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窗口组件（如按钮、文本框等）一般都位于容器组件中，当事件发生在某一个组件上时，先通过组件对象的handleEvent()方法将事件传递给相应的事件处理方法，该事件处理方法将处理此事件，然后决定是否将该事件向上一级容器组件传播</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上级容器组件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，如此反复，直到事件到达顶层容器组件为止；如果一直传到最顶层容器仍没有处理方法，则该事件不予处理。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一级组件在接收到事件时，都可以处理此事件，而不论此事件是否在上一级已得到处理，还存在事件未被处理的情况</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-12"><a href="#模式扩展-12" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="不纯的职责链模式"><a href="#不纯的职责链模式" class="headerlink" title="不纯的职责链模式"></a>不纯的职责链模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。</span><br></pre></td></tr></table></figure>







<h3 id="模型本质-1"><a href="#模型本质-1" class="headerlink" title="模型本质"></a>模型本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分离职责，动态组合</span><br><span class="line"></span><br><span class="line">分离职责是前提，动态组合是关键</span><br></pre></td></tr></table></figure>





















<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Command Pattern</span><br><span class="line"></span><br><span class="line">将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。</span><br><span class="line"></span><br><span class="line">关键在于引入抽象命令类，请求发送者针对抽象命令类编程</span><br><span class="line"></span><br><span class="line">一种对象行为型模式</span><br><span class="line"></span><br><span class="line">别名为动作(Action)模式或事务(Transaction)模式。</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-23"><a href="#解决的问题-23" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以一种松耦合的方式来设计软件，使得请求发送者与请求接收者能够消除彼此之间的耦合，发送者与接收者之间没有直接引用关系，让对象之间的调用关系更加灵活，可以灵活地指定请求接收者以及被请求的操作。</span><br></pre></td></tr></table></figure>



<h3 id="解决的方式-4"><a href="#解决的方式-4" class="headerlink" title="解决的方式"></a>解决的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义一个抽象命令类：一般是一个抽象类或接口，声明用于执行请求的execute()等方法，通过这些方法调用请求接收者的相关操作</span><br><span class="line">定义一个具体命令类：继承抽象命令类，实现execute()方法，对应具体的接收者方法，绑定其动作，在execute()方法中调用其相关操作</span><br><span class="line">定义调用者类：关联抽象命令类，运行时动态注入具体命令类，通过具体命令类来执行请求</span><br><span class="line">定义接收者类：具体实现对请求的业务处理</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="模式结构-15"><a href="#模式结构-15" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241105124503709.png" alt="image-20241105124503709"></p>
<h3 id="模式优缺点-13"><a href="#模式优缺点-13" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-8"><a href="#模式优点-8" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">更松散的耦合，请求者与接收者实现完全解耦，相同的请求者可以对应不同的接收者，相同的接收者也可以供不同的请求者使用，两者都具有良好的独立性。</span><br><span class="line"></span><br><span class="line">更动态的控制，把请求封装起来，可以动态对它进行参数化、队列化和日志化等操作，使系统更灵活。</span><br><span class="line"></span><br><span class="line">更容易的组合命令，能够很容易的设计一个命令队列或宏命令，使系统操作更简单，功能更强大。</span><br><span class="line"></span><br><span class="line">更好的扩展性，新命令可以很容易地加入到系统中，无须修改原有代码，甚至客户类代码，满足“开闭原则”的要求。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-8"><a href="#模式缺点-8" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-13"><a href="#模式适用环境-13" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果需要抽象出需要执行的动作，并参数化这些对象，可以选用命令模式，把这些需要执行的动作抽象成为命令，然后实现命令的参数化配置。</span><br><span class="line"></span><br><span class="line">如果需要在不同的时刻指定、排列和执行请求，可以选用命令模式，把这些请求封装成为命令对象，然后实现把请求队列化。</span><br><span class="line"></span><br><span class="line">如果需要支持取消操作，可以选用命令模式，通过管理命令对象，能很容易的实现命令的恢复和重做的功能</span><br><span class="line"></span><br><span class="line">如果需要支持当系统崩溃时，能把对系统的操作功能重新执行一遍，可以选用命令模式，把这些操作功能的请求封装成命令对象，然后实现日志命令，就可以在系统恢复后，通过日志获取命令列表，从而重新执行一遍功能。</span><br><span class="line"></span><br><span class="line">在需要事务的系统中，命令模式提供了对事务进行建模的方法，例如，建立一个由支持可撤销操作的命令对象组成的链表，正向遍历，即执行事务处理操作集合；一旦某个事务操作出现异常，便改为反向遍历，即执行事务回滚操作集合，这样就实现了一种具体的事务模式。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-13"><a href="#现实应用-13" class="headerlink" title="现实应用"></a>现实应用</h4><h5 id="1-AWT-Swing-GUI的委派事件模型"><a href="#1-AWT-Swing-GUI的委派事件模型" class="headerlink" title="1. AWT&#x2F;Swing(GUI的委派事件模型)"></a>1. AWT&#x2F;Swing(GUI的委派事件模型)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> (Delegation Event Model, DEM) </span><br><span class="line"> </span><br><span class="line">在AWT/Swing中：</span><br><span class="line"></span><br><span class="line">Frame、Button等界面组件是请求发送者</span><br><span class="line"></span><br><span class="line">AWT提供的事件监听器接口和事件适配器类是抽象命令接口</span><br><span class="line"></span><br><span class="line">用户可以自己写抽象命令接口的子类来实现事件处理，即实现具体命令类，而在具体命令类中可以调用业务处理方法来实现该事件的处理。对于界面组件而言，只需要了解命令接口即可，无须关心接口的实现，组件类并不关心实际操作，而操作由用户来实现。 </span><br></pre></td></tr></table></figure>



<h5 id="2-宏命令"><a href="#2-宏命令" class="headerlink" title="2. 宏命令"></a>2. 宏命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如UNIX平台下的Shell编程，可以将多条命令封装在一个命令对象中，只需要一条简单的命令即可执行一个命令序列</span><br></pre></td></tr></table></figure>











<h3 id="模型扩展"><a href="#模型扩展" class="headerlink" title="模型扩展"></a>模型扩展</h3><h4 id="命令队列"><a href="#命令队列" class="headerlink" title="命令队列"></a>命令队列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有时候一个请求发送者不止发送一个请求，将不止一个请求接收者产生响应，我们需要将多个请求排队，当发送请求时，这些请求接收者将逐个执行业务方法，完成对请求的处理。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令队列的实现方法有多种形式，其中最常用、灵活性最好的一种方式是增加一个CommandQueue类，由该类来负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241106101423026.png" alt="image-20241106101423026"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">增加了命令队列类CommandQueue以后，请求发送者类Invoker将针对CommandQueue编程</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241106101501145.png" alt="image-20241106101501145"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还可以使用多线程技术来并发调用命令对象的execute()方法，从而提高程序的执行效率。</span><br></pre></td></tr></table></figure>



<h4 id="请求日志"><a href="#请求日志" class="headerlink" title="请求日志"></a>请求日志</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还可以使用多线程技术来并发调用命令对象的execute()方法，从而提高程序的执行效率。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">日志文件可以记录用户对系统的一些操作（例如对数据的更改）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请求日志文件可以实现很多功能，常用功能如下：</span><br><span class="line">一旦系统发生故障，日志文件可以为系统提供一种恢复机制，在请求日志文件中可以记录用户对系统的每一步操作，从而让系统能够顺利恢复到某一个特定的状态；</span><br></pre></td></tr></table></figure>



<h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过在命令类中增加一个逆向操作来实现撤销(Undo)请求</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还可以通过保存对象的历史状态来实现撤销，后者可使用备忘录模式(Memento Pattern)来实现。</span><br></pre></td></tr></table></figure>



<h4 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">又称为组合命令，它是命令模式和组合模式联用的产物。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宏命令是一个具体命令类，它拥有一个集合属性，在该集合中包含了对其他命令对象的引用。通常宏命令不直接与请求接收者交互，而是通过它的成员来调用接收者的方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个宏命令的成员可以是简单命令，还可以继续是宏命令。执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理。</span><br></pre></td></tr></table></figure>







<h3 id="模式本质-10"><a href="#模式本质-10" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">封装请求</span><br><span class="line"></span><br><span class="line">命令模式的关键就是把请求封装成为命令对象</span><br></pre></td></tr></table></figure>





















<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator Pattern</span><br><span class="line"></span><br><span class="line">提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示</span><br><span class="line"></span><br><span class="line">一种对象行为型模式</span><br><span class="line"></span><br><span class="line">其别名为游标(Cursor)</span><br><span class="line"></span><br><span class="line">内部结合了工厂方法模式（创建迭代器）</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-24"><a href="#解决的问题-24" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，以简化聚合对象的设计，使之更符合“单一职责原则”的要求。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还可以灵活地为聚合对象增加不同的遍历方法，还可以访问一个聚合对象中的元素但又不需要暴露它的内部结构。</span><br></pre></td></tr></table></figure>



<h3 id="解决的方式-5"><a href="#解决的方式-5" class="headerlink" title="解决的方式"></a>解决的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义抽象迭代器：定义访问和遍历元素的接口，声明相应方法</span><br><span class="line">定义具体迭代器：实现抽象迭代器接口，引入游标来记录在聚合对象中所处的当前位置。</span><br><span class="line">定义抽象聚合类：用于存储和管理元素对象，声明创建迭代器对象，充当抽象迭代器工厂角色</span><br><span class="line">定义具体聚合类：实现抽象聚合类中声明的创建迭代器的方法</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-16"><a href="#模式结构-16" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241106114239695.png" alt="image-20241106114239695"></p>
<h3 id="模式优缺点-14"><a href="#模式优缺点-14" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-9"><a href="#模式优点-9" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</span><br><span class="line"></span><br><span class="line">迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</span><br><span class="line"></span><br><span class="line">在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-9"><a href="#模式缺点-9" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</span><br><span class="line"></span><br><span class="line">抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展：</span><br><span class="line">例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-14"><a href="#模式适用环境-14" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。</span><br><span class="line"></span><br><span class="line">需要为一个聚合对象提供多种遍历方式。</span><br><span class="line"></span><br><span class="line">为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-14"><a href="#现实应用-14" class="headerlink" title="现实应用"></a>现实应用</h4><h5 id="1-Java聚合框架Collections"><a href="#1-Java聚合框架Collections" class="headerlink" title="1. Java聚合框架Collections"></a>1. Java聚合框架Collections</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection是所有Java聚合类的根接口</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在JDK类库中:</span><br><span class="line"></span><br><span class="line">Collection的iterator()方法返回一个java.util.Iterator类型的对象</span><br><span class="line"></span><br><span class="line">而其子接口java.util.List的listIterator()方法返回一个java.util.ListIterator类型的对象</span><br><span class="line"></span><br><span class="line">ListIterator是Iterator的子类。它们构成了Java语言对迭代器模式的支持，Java语言的java.util.Iterator接口就是迭代器模式的应用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在JDK中，Iterator接口具有如下3个基本方法：</span><br><span class="line"></span><br><span class="line">Object next()：通过反复调用next()方法可以逐个访问聚合中的元素。 </span><br><span class="line"></span><br><span class="line">boolean hasNext()：hasNext()方法用于判断聚合对象中是否还存在下一个元素，为了不抛出异常，必须在调用next()之前先调用hasNext()。如果迭代对象仍然拥有可供访问的元素，那么hasNext()返回true。</span><br><span class="line"></span><br><span class="line">void remove()：用于删除上次调用next()时所返回的元素。 </span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241106122017388.png" alt="image-20241106122017388"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java迭代器可以理解为它工作在聚合对象的各个元素之间，每调用一次next()方法，迭代器便越过下个元素，并且返回它刚越过的那个元素的地址引用。</span><br><span class="line"></span><br><span class="line">不能连续调用两次remove()方法，否则第二次删除将找不到要删除的元素</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-13"><a href="#模式扩展-13" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="内部迭代器和外部迭代器"><a href="#内部迭代器和外部迭代器" class="headerlink" title="内部迭代器和外部迭代器"></a>内部迭代器和外部迭代器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">内部迭代器：</span><br><span class="line">由迭代器自己来控制迭代下一个元素的步骤，客户端无法干预。</span><br><span class="line"></span><br><span class="line">要在迭代的过程中完成工作，客户端就需要把操作传给迭代器，迭代器在迭代的时候会在每个元素上执行这个操作</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部迭代器指的是由客户端来控制迭代下一个元素</span><br></pre></td></tr></table></figure>



<h4 id="带迭代策略的迭代器"><a href="#带迭代策略的迭代器" class="headerlink" title="带迭代策略的迭代器"></a>带迭代策略的迭代器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最为典型的就是实现过滤功能的迭代器</span><br><span class="line"></span><br><span class="line">实现过滤功能的迭代器中，又有两种常见的需要过滤的情况：</span><br><span class="line">	一种是对数据进行整条过滤，比如只能查看自己部门的数据；</span><br><span class="line">	</span><br><span class="line">	另外一种情况是对数据进行部分过滤，比如某些人不能查看工资数据。</span><br><span class="line"></span><br><span class="line">实现的基本思路，获取聚合对象数据，存储到迭代器中，即可按照不同的策略来迭代数据。	</span><br></pre></td></tr></table></figure>



<h4 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以同时向前和向后遍历数据的迭代器</span><br><span class="line"></span><br><span class="line">Java util包中的ListIterator接口就是一个双向迭代器，自己实现只要Iterator接口中添加向前的判断和向前获取值的方法，然后在具体迭代器中实现即可。</span><br></pre></td></tr></table></figure>







<h3 id="模式本质-11"><a href="#模式本质-11" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制访问聚合对象中的元素</span><br><span class="line"></span><br><span class="line">并非单纯的透明</span><br></pre></td></tr></table></figure>



















<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Mediator Pattern</span><br><span class="line"></span><br><span class="line">用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</span><br><span class="line"></span><br><span class="line">一种对象行为型模式</span><br><span class="line"></span><br><span class="line">又称为调停者模式</span><br><span class="line"></span><br><span class="line">中介者模式是“迪米特法则”的一个典型应用。</span><br><span class="line"></span><br><span class="line">模式的核心在于中介者类的引入，承担两方面职责：</span><br><span class="line">	中转作用（结构性）：各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用</span><br><span class="line">	协调作用（行为性）：中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做。</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-25"><a href="#解决的问题-25" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在网状结构中，几乎每个对象都需要与其他对象发生相互作用，而这种相互作用表现为一个对象与另外一个对象的直接耦合，这将导致一个过度耦合的系统。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将对象之间的一些交互行为从各个对象中分离出来，并集中封装在一个中介者对象中，并由该中介者进行统一协调，这样对象之间多对多的复杂关系就转化为相对简单的一对多关系。可以将系统的网状结构变成以中介者为中心的星形结构</span><br></pre></td></tr></table></figure>



<h3 id="解决的方式-6"><a href="#解决的方式-6" class="headerlink" title="解决的方式"></a>解决的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义抽象中介者：定义一个用于和各同事对象进行通信的接口</span><br><span class="line">定义具体中介者，继承抽象终结者，维持对各个同事对象的引用，协调各个同事对象来实现协作行为</span><br><span class="line">定义抽象同事类：定义各个同事的公有方法，声明一些可实现的抽象方法，维持一个对抽象中介者的引用</span><br><span class="line">定义具体同事类：继承抽象同事类，实现在抽象同事类中声明的抽象方法</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-17"><a href="#模式结构-17" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107081406202.png" alt="image-20241107081406202"></p>
<h3 id="模式优缺点-15"><a href="#模式优缺点-15" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-10"><a href="#模式优点-10" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">松散耦合，中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互不依赖，同事对象就可以独立的变化和复用，而不再像以前那样“牵一发而动全身”了。</span><br><span class="line"></span><br><span class="line">集中控制交互，多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以，如果是已经做好的系统，那就扩展中介者对象，而各个同事类不需要修改。</span><br><span class="line"></span><br><span class="line">多对多变成一对多，没有使用中介者模式的时候，同事对象之间的关系通常是多对多的，引入中介者对象后，中介者对象和同事对象的关系变成了一对多，这让对象间的关系更容易理解和实现。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-10"><a href="#模式缺点-10" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">过度集中化，中介者模式中，如果同事对象的交互非常多，而且比较复杂，当这些交互全部集中到中介者的时候，会导致中介者对象变得十分的复杂，而且难于管理和维护。</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-15"><a href="#模式适用环境-15" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一组对象之间的通信方式比较复杂，导致相互依赖、结构混乱</span><br><span class="line"></span><br><span class="line">一个对象引用很多的对象，并直接跟这些对象交互，导致难以复用该对象</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-15"><a href="#现实应用-15" class="headerlink" title="现实应用"></a>现实应用</h4><h5 id="1-GUI应用程序"><a href="#1-GUI应用程序" class="headerlink" title="1.GUI应用程序"></a>1.GUI应用程序</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中介者模式在事件驱动类软件中应用比较多，在设计GUI应用程序时，组件之间可能存在较为复杂的交互关系，一个组件的改变将影响与之相关的其他组件，此时可以使用中介者模式来对组件进行协调</span><br></pre></td></tr></table></figure>



<h5 id="2-MVC"><a href="#2-MVC" class="headerlink" title="2.MVC"></a>2.MVC</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVC 是Java EE 的一个基本模式，此时控制器Controller 作为一种中介者，它负责控制视图对象View和模型对象Model之间的交互。如在Struts中，Action就可以作为JSP页面与业务对象之间的中介者。</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-14"><a href="#模式扩展-14" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="中介者模式与外观模式的区别"><a href="#中介者模式与外观模式的区别" class="headerlink" title="中介者模式与外观模式的区别"></a>中介者模式与外观模式的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">外观模式封装的是子系统外部和子系统内部模块间的交互</span><br><span class="line">外观模式是实现单向的交互</span><br><span class="line">外观模式的目的是简化客户端的调用</span><br><span class="line"></span><br><span class="line">中介者模式是提供多个平等的同事对象之间交互关系的封装，一般是用在内部实现上。</span><br><span class="line">中介者模式实现的是内部多个模块间多向的交互。</span><br><span class="line">中介者模式的目的主要是松散多个模块之间的耦合，把这些耦合关系全部放到中介者中去实现</span><br></pre></td></tr></table></figure>







<h3 id="模型本质-2"><a href="#模型本质-2" class="headerlink" title="模型本质"></a>模型本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">封装交互</span><br></pre></td></tr></table></figure>





















<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Memento Pattern</span><br><span class="line"></span><br><span class="line">在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</span><br><span class="line"></span><br><span class="line">一种对象行为型模式</span><br><span class="line"></span><br><span class="line">其别名又叫做Token模式或快照模式(Snapshot Pattern) </span><br><span class="line"></span><br><span class="line">核心是备忘录类以及用于管理备忘录的负责人类的设计</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-26"><a href="#解决的问题-26" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了使软件的使用更加人性化，对于误操作，我们需要提供一种类似“后悔药”的机制，让软件系统可以回到误操作前的某一特定历史状态</span><br></pre></td></tr></table></figure>



<h3 id="解决的方式-7"><a href="#解决的方式-7" class="headerlink" title="解决的方式"></a>解决的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义原发器：一个需要保存内部状态的普通类，可以创建一个备忘录并存储其当前内部状态，也可以适用备忘录恢复其内部状态</span><br><span class="line">定义备忘录：根据原发器的需求来存储原发器的内部状态，不能呗除原发器本身和负责人类之外的类使用，在不同的编程语言中实现机制有所不同</span><br><span class="line">定义负责人类：负责存储一个或多个备忘录，但不能操作或检查备忘录的内容，也不需要知道实现细节</span><br><span class="line"></span><br><span class="line">C++中可以使用friend关键字，让原发器类和备忘录类成为友元类，互相之间可以访问对象的一些私有的属性</span><br><span class="line"></span><br><span class="line">Java语言中可使用默认访问标识符来定义Memento类，让它们之间满足默认的包内可见性，也可以将备忘录类作为原发器类的内部类，使得只有原发器才可以访问备忘录中的数据，其他对象都无法使用备忘录中的数据。</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-18"><a href="#模式结构-18" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107085132459.png" alt="image-20241107085132459"></p>
<h3 id="模式优缺点-16"><a href="#模式优缺点-16" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-11"><a href="#模式优点-11" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。</span><br><span class="line"></span><br><span class="line">备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-11"><a href="#模式缺点-11" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-16"><a href="#模式适用环境-16" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。</span><br><span class="line"></span><br><span class="line">防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-16"><a href="#现实应用-16" class="headerlink" title="现实应用"></a>现实应用</h4><h5 id="1-文字或图像编辑软件"><a href="#1-文字或图像编辑软件" class="headerlink" title="1.文字或图像编辑软件"></a>1.文字或图像编辑软件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">几乎所有的文字或者图像编辑软件都提供了撤销的功能，即撤销操作</span><br><span class="line"></span><br><span class="line">但是当软件关闭再打开时不能再进行撤销操作，也就是说不能再回到关闭软件前的状态</span><br><span class="line"></span><br><span class="line">实际上这中间就使用到了备忘录模式，在编辑文件的同时可以保存一些内部状态，这些状态在软件关闭时从内存销毁</span><br><span class="line"></span><br><span class="line">当然这些状态的保存也不是无限的，很多软件只提供有限次的撤销操作。</span><br></pre></td></tr></table></figure>



<h5 id="2-数据库管理系统的事务管理应用"><a href="#2-数据库管理系统的事务管理应用" class="headerlink" title="2.数据库管理系统的事务管理应用"></a>2.数据库管理系统的事务管理应用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库管理系统DBMS所提供的事务管理应用了备忘录模式，当数据库某事务中一条数据操作语句执行失败时，整个事务将进行回滚操作，系统回到事务执行之前的状态。</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-15"><a href="#模式扩展-15" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="多次撤销的实现"><a href="#多次撤销的实现" class="headerlink" title="多次撤销的实现"></a>多次撤销的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在负责人类中定义一个集合来存储多个备忘录，每个备忘录负责保存一个历史状态，在撤销时可以对备忘录集合进行逆向遍历，回到一个指定的历史状态</span><br><span class="line"></span><br><span class="line">而且还可以对备忘录集合进行正向遍历，实现重做(Redo)操作，即取消撤销，让对象状态得到恢复。</span><br></pre></td></tr></table></figure>



<h4 id="备忘录模式和命令模式"><a href="#备忘录模式和命令模式" class="headerlink" title="备忘录模式和命令模式"></a>备忘录模式和命令模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个模式可以组合使用</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令模式实现中，在实现命令的撤销和重做的时候，可以使用备忘录模式，在命令操作的时候记录下操作前后的状态，然后在命令撤销和重做的时候，直接使用相应的备忘录对象来恢复状态就可以</span><br><span class="line"></span><br><span class="line">在这种撤销的执行顺序和重做执行顺序可控的情况下，备忘录对象还可以采用增量式记录的方式，可以减少缓存的数据量。</span><br></pre></td></tr></table></figure>



<h4 id="备忘录模式和原型模式"><a href="#备忘录模式和原型模式" class="headerlink" title="备忘录模式和原型模式"></a>备忘录模式和原型模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个模式可以组合使用</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在原发器对象创建备忘录对象的时候，如果原发器对象中全部或者大部分的状态都需要保存，一个简洁的方式就是直接克隆一个原发器对象。</span><br><span class="line"></span><br><span class="line">也就是说，这个时候备忘录对象里面存放的是一个原发器对象的实例</span><br></pre></td></tr></table></figure>







<h3 id="模式本质-12"><a href="#模式本质-12" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">保存和恢复内部状态</span><br><span class="line"></span><br><span class="line">保存是手段，恢复才是目的</span><br></pre></td></tr></table></figure>





















<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observer Pattern</span><br><span class="line"></span><br><span class="line">定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</span><br><span class="line"></span><br><span class="line">一种对象行为型模式。</span><br><span class="line"></span><br><span class="line">又叫做发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式</span><br><span class="line"></span><br><span class="line">模式中的关键对象是观察目标和观察者</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-27"><a href="#解决的问题-27" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个对象的状态发生改变的时候，如何让依赖于它的所有对象得到通知，并进行相应的处理呢？</span><br></pre></td></tr></table></figure>



<h3 id="解决的方式-8"><a href="#解决的方式-8" class="headerlink" title="解决的方式"></a>解决的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">定义目标类：一个接口或抽象类或具体类，指被观察的对象。定义一个观察者集合，可以接收任意数量互不相关的观察者进行观察，定义增加和删除观察者对象的方法，定义通知方法notify()</span><br><span class="line">定义具体目标类：继承目标类，通常包含有经常发生改变的数据，实现目标类中声明的notify()方法和抽象业务逻辑方法（如果有的话），状态变化时通知其各个观察者</span><br><span class="line">定义观察者类：一般为借口，声明更新数据的方法update()</span><br><span class="line">定义具体观察者类：继承观察者类，维护一个指向具体目标对象的引用，存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。实现抽象观察者类中定义的Update()方法</span><br><span class="line"></span><br><span class="line">通常在实现时：具体观察类调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除</span><br><span class="line"></span><br><span class="line">在有些更加复杂的情况下，具体观察者类的update()方法在执行时需要使用到具体目标类中的状态属性，因此在具体观察者类与具体目标类之间有时候还存在关联或依赖关系，在具体观察者类中定义一个具体目标类实例，通过该实例获取存储在具体目标类中的状态</span><br><span class="line"></span><br><span class="line">如果具体观察者类的update()方法不需要使用到具体目标类中的状态属性，则可以对观察者模式的标准结构进行简化，在具体观察者和具体目标之间无须维持对象引用</span><br><span class="line"></span><br><span class="line">如果无需扩展目标类，具体目标类可以省略</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-19"><a href="#模式结构-19" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107093057497.png" alt="image-20241107093057497"></p>
<h3 id="模式优缺点-17"><a href="#模式优缺点-17" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-12"><a href="#模式优点-12" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">实现了观察者和目标之间的抽象耦合</span><br><span class="line">原本目标对象在状态改变时，需要直接调用所有的观察者对象，但是抽象出观察者接口后，目标和观察者就只是在抽象层面上耦合了</span><br><span class="line">即目标只是知道观察者接口，并不知道具体的观察者的类，从而实现目标类和具体观察者类之间解耦。</span><br><span class="line"></span><br><span class="line">实现了动态联动</span><br><span class="line">所谓联动，就是做一个操作会引起其它相关的操作。</span><br><span class="line">由于观察者模式对观察者注册实行管理，那就可以在运行期间，通过动态的控制注册的观察者，来控制某个动作的联动范围，从而实现动态联动。</span><br><span class="line"></span><br><span class="line">支持广播通信</span><br><span class="line">由于目标发送通知给观察者是面向所有注册的观察者，所以每次目标通知的信息就要对所有注册的观察者进行广播。</span><br><span class="line">当然，也可以通过在目标上添加新的功能来限制广播的范围。</span><br><span class="line"></span><br><span class="line">观察者模式满足“开闭原则”的要求</span><br><span class="line">增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-12"><a href="#模式缺点-12" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于观察者模式每次都是广播通信，不管观察者需不需要，每个观察者都会被调用update方法，如果观察者不需要执行相应处理，要及时解注册。</span><br><span class="line"></span><br><span class="line">若两个对象互为观察者和目标对象，要注意避免相互广播造成死循环、有可能导致系统崩溃的问题。</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-17"><a href="#模式适用环境-17" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。</span><br><span class="line"></span><br><span class="line">一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。</span><br><span class="line"></span><br><span class="line">需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-17"><a href="#现实应用-17" class="headerlink" title="现实应用"></a>现实应用</h4><h5 id="1-JDK的事件模型"><a href="#1-JDK的事件模型" class="headerlink" title="1.JDK的事件模型"></a>1.JDK的事件模型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JDK 1.0及更早版本的事件模型基于职责链模式，但是这种模型不适用于复杂的系统</span><br><span class="line">因此在JDK 1.1及以后的各个版本中，事件处理模型采用基于观察者模式的委派事件模型(DelegationEvent Model，DEM)</span><br><span class="line">即一个Java组件所引发的事件并不由引发事件的对象自己来负责处理，而是委派给独立的事件处理对象负责。</span><br><span class="line"></span><br><span class="line">在DEM模型中</span><br><span class="line">目标角色（如界面组件）负责发布事件</span><br><span class="line">而观察者角色（事件处理者）可以向目标订阅它所感兴趣的事件。</span><br><span class="line">当一个具体目标产生一个事件时，它将通知所有订阅者。</span><br><span class="line"></span><br><span class="line">事件的发布者称为事件源(Event Source)</span><br><span class="line">而订阅者称为事件监听器(Event Listener)</span><br><span class="line">在这个过程中还可以通过事件对象(Event Object)来传递与事件相关的信息</span><br><span class="line">可以在事件监听者的实现类中实现事件处理，因此事件监听对象又可以称为事件处理对象。</span><br><span class="line"></span><br><span class="line">事件源对象、事件监听对象（事件处理对象）和事件对象构成了Java事件处理模型的三要素。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-JDK的Observable接口"><a href="#2-JDK的Observable接口" class="headerlink" title="2.JDK的Observable接口"></a>2.JDK的Observable接口</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在java.util包中，提供了Observable类以及Observer接口，它们构成了JDK对观察者模式的支持。</span><br><span class="line"></span><br><span class="line">可以直接使用Observer接口和Observable类来作为观察者模式的抽象层，再自定义具体观察者类和具体观察目标类</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107102325639.png" alt="image-20241107102325639"></p>
<h5 id="3-MVC模式"><a href="#3-MVC模式" class="headerlink" title="3.MVC模式"></a>3.MVC模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MVC模式是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。</span><br><span class="line"></span><br><span class="line">观察者模式可以用来实现MVC模式</span><br><span class="line">观察者模式中的观察目标就是MVC模式中的模型(Model)</span><br><span class="line">而观察者就是MVC中的视图(View)</span><br><span class="line">控制器(Controller)充当两者之间的中介者(Mediator)。</span><br><span class="line">当模型层的数据发生改变时，视图层将自动改变其显示内容。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107102626932.png" alt="image-20241107102626932"></p>
<h3 id="模式扩展-16"><a href="#模式扩展-16" class="headerlink" title="模式扩展"></a>模式扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure>



<h3 id="模式本质-13"><a href="#模式本质-13" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">触发联动</span><br></pre></td></tr></table></figure>





















<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">State Pattern</span><br><span class="line"></span><br><span class="line">许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</span><br><span class="line"></span><br><span class="line">一种对象行为型模式</span><br><span class="line"></span><br><span class="line">其别名为状态对象(Objects for States)</span><br><span class="line"></span><br><span class="line">模式的关键是引入了一个抽象类来专门表示对象的状态</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-28"><a href="#解决的问题-28" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。</span><br></pre></td></tr></table></figure>



<h3 id="解决的方式-9"><a href="#解决的方式-9" class="headerlink" title="解决的方式"></a>解决的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义环境类：一个拥有多种状态的对象，维护一个抽象状态类的实例用来定义当前状态</span><br><span class="line">定义抽象状态类：声明各种状态公有的抽象方法，以供表示不同状态的子类实现</span><br><span class="line">定义具体状态类：继承抽象状态类，对应环境的一个具体状态，实现抽象状态类中的公有抽象方法。</span><br><span class="line"></span><br><span class="line">状态类的产生是由于环境类存在多个状态，同时还满足两个条件：</span><br><span class="line">	这些状态经常需要切换</span><br><span class="line">	在不同的状态下对象的行为不同</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两种实现环境状态转换的方式</span><br><span class="line"></span><br><span class="line">统一由环境类来负责状态之间的转换，此时，它充当了状态管理器(State Manager)角色</span><br><span class="line">在它的业务方法中通过对某些属性值的判断实现状态转换，还可以提供一个专门的方法用于实现属性判断和状态转换</span><br><span class="line"></span><br><span class="line">由具体状态类来负责状态之间的转换，可以在其业务方法中判断环境类的某些属性值为它设置新的状态对象，实现状态转换，也可以提供一个专门的方法来负责属性判断和状态转换。此时，两者之间就存在依赖或关联关系</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-20"><a href="#模式结构-20" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107103204449.png" alt="image-20241107103204449"></p>
<h3 id="模式优缺点-18"><a href="#模式优缺点-18" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-13"><a href="#模式优点-13" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">简化应用逻辑控制，状态模式使用单独的类来封装一个状态的处理。</span><br><span class="line">如果把一个大的程序控制分成很多小块，每块定义一个状态来代表，那么就可以把这些逻辑控制的代码分散到很多单独的状态类当中去，这样就把着眼点从执行状态提高到整个对象的状态，使得代码结构化和意图更清晰，从而简化应用的逻辑控制。</span><br><span class="line"></span><br><span class="line">更好的分离状态和行为</span><br><span class="line">状态模式通过设置所有状态类的公共接口，把状态和状态对应的行为分离开来，把所有与一个特定的状态相关的行为都放入一个对象中，使得应用程序在控制的时候，只需要关心状态对象的切换，而不用关心这个状态对应的真正处理。</span><br><span class="line"></span><br><span class="line">更好的扩展性</span><br><span class="line">引入了状态处理的公共接口后，使得扩展新的状态变得非常容易，只需要新增加一个实现状态处理的公共接口的实现类，然后在进行状态维护的地方，设置状态变化到这个新的状态即可。</span><br><span class="line"></span><br><span class="line">显式化进行状态转换</span><br><span class="line">状态模式为不同的状态引入独立的对象，使得状态的转换变得更加明确。而且状态对象可以保证上下文不会发生内部状态不一致的情况，因为上下文中只有一个变量来记录状态对象，只要为这一个变量赋值就可以了。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-13"><a href="#模式缺点-13" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。</span><br><span class="line"></span><br><span class="line">状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。</span><br><span class="line"></span><br><span class="line">状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-18"><a href="#模式适用环境-18" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化。</span><br><span class="line"></span><br><span class="line">在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-18"><a href="#现实应用-18" class="headerlink" title="现实应用"></a>现实应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RPG游戏中角色升级伴随的状态及行为的变化</span><br><span class="line"></span><br><span class="line">OA系统中批文的状态管理（尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态）</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-17"><a href="#模式扩展-17" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="共享状态"><a href="#共享状态" class="headerlink" title="共享状态"></a>共享状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象</span><br></pre></td></tr></table></figure>



<h4 id="简单状态模式"><a href="#简单状态模式" class="headerlink" title="简单状态模式"></a>简单状态模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简单状态模式是指状态都相互独立，状态之间无须进行转换的状态模式，这是最简单的一种状态模式。</span><br><span class="line">对于这种状态模式，每个状态类都封装与状态相关的操作，而无须关心状态的切换，可以在客户端直接实例化状态类，然后将状态对象设置到环境类中。</span><br><span class="line">遵循“开闭原则”，在客户端可以针对抽象状态类进行编程，而将具体状态类写到配置文件中，同时增加新的状态类对原有系统也不造成任何影响。</span><br></pre></td></tr></table></figure>



<h4 id="状态模式和观察者模式的区别"><a href="#状态模式和观察者模式的区别" class="headerlink" title="状态模式和观察者模式的区别"></a>状态模式和观察者模式的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">多数的状态模式都是可以切换状态的状态模式</span><br><span class="line"></span><br><span class="line">观察者模式的自身行为是固定的，那就是通知所有的观察者</span><br><span class="line"></span><br><span class="line">状态模式是根据状态来选择不同的处理，当状态发生改变的时候，动态改变自身行为</span><br></pre></td></tr></table></figure>







<h3 id="模式本质-14"><a href="#模式本质-14" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据状态来分离和选择行为</span><br></pre></td></tr></table></figure>





















<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">策略模式(Strategy Pattern)</span><br><span class="line"></span><br><span class="line">定义一系列算法，将每一个算法封装起来，并让它们可以相互替换，让算法独立于使用它的客户而变化。</span><br><span class="line"></span><br><span class="line">一种对象行为型模式。</span><br><span class="line"></span><br><span class="line">也称为政策模式(Policy)</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-29"><a href="#解决的问题-29" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。 </span><br></pre></td></tr></table></figure>



<h3 id="解决的方式-10"><a href="#解决的方式-10" class="headerlink" title="解决的方式"></a>解决的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义环境类：使用算法的类，维持一个对抽象策略类的引用实例以用于选择策略</span><br><span class="line">定义抽象策略类：一个抽象类或具体类，声明算法的抽象方法</span><br><span class="line">定义具体策略类：继承抽象策略类，实现在抽象策略类中声明的算法。</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-21"><a href="#模式结构-21" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107125703360.png" alt="image-20241107125703360"></p>
<h3 id="模式优缺点-19"><a href="#模式优缺点-19" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-14"><a href="#模式优点-14" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">提供了一种算法复用机制。将算法单独提取出来封装在策略类中，不同的环境类可以方便地复用这些策略类。</span><br><span class="line"></span><br><span class="line">提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。</span><br><span class="line"></span><br><span class="line">可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法的逻辑与算法本身的实现逻辑混合在一起，将它们全部硬编码在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。</span><br><span class="line"></span><br><span class="line">提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来就违背“单一职责原则”，决定使用哪一种算法的逻辑和算法本身混合在一起，从而不可能独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。</span><br><span class="line"></span><br><span class="line">提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-14"><a href="#模式缺点-14" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</span><br><span class="line">这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。</span><br><span class="line">换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</span><br><span class="line"></span><br><span class="line">将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</span><br><span class="line"></span><br><span class="line">只适合扁平的算法结构</span><br><span class="line">策略模式的一系列算法地位是平等的，是可以相互替换的，事实上构成了一个扁平的算法结构，也就是在一个策略接口下，有多个平等的策略算法，就相当于兄弟算法。</span><br><span class="line">而且在运行时刻只有一个算法被使用，这就限制了算法使用的层级，使用的时候不能嵌套使用。</span><br><span class="line">对于出现需要嵌套使用多个算法的情况，比如折上折、折后返卷等业务的实现，需要组合或者是嵌套使用多个算法的情况，可以考虑使用装饰模式等方式来实现。</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-19"><a href="#模式适用环境-19" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个系统需要动态地在几种算法中选择一种。</span><br><span class="line"></span><br><span class="line">一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。</span><br><span class="line"></span><br><span class="line">不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-19"><a href="#现实应用-19" class="headerlink" title="现实应用"></a>现实应用</h4><h5 id="1-JavaSE的容器布局管理"><a href="#1-JavaSE的容器布局管理" class="headerlink" title="1.JavaSE的容器布局管理"></a>1.JavaSE的容器布局管理</h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107132304735.png" alt="image-20241107132304735"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在Java SE开发中，用户需要对容器对象Container中的成员对象如按钮、文本框等GUI控件进行布局(Layout)，在程序运行期间由客户端动态决定一个容器对象如何布局</span><br><span class="line">JDK中提供了几种不同的布局方式，封装在不同的类中，例如FlowLayout、GridLayout、BorderLayout、GridBagLayout和CardLayout等。</span><br><span class="line">上图中Container类充当环境角色Context</span><br><span class="line">LayoutManager作为所有布局类的公共父类扮演了抽象策略角色，它给出所有具体布局类所需的接口</span><br><span class="line">而具体策略类是LayoutManager的子类，也就是各种具体的布局类，它们封装了不同的布局方式。</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-18"><a href="#模式扩展-18" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="策略模式与状态模式的比较"><a href="#策略模式与状态模式的比较" class="headerlink" title="策略模式与状态模式的比较"></a>策略模式与状态模式的比较</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可以通过环境类状态的个数来决定是使用策略模式还是状态模式。</span><br><span class="line"></span><br><span class="line">如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式</span><br><span class="line">使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换</span><br><span class="line">而状态模式中具体状态往往需要维护一个环境类的引用，以便通过该引用实现状态的切换，存在一种双向的关联关系。</span><br><span class="line"></span><br><span class="line">如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式</span><br><span class="line">使用策略模式时，客户端需要知道所选的具体策略是哪一个</span><br><span class="line">策略模式中，具体策略类无须关心环境类</span><br></pre></td></tr></table></figure>







<h3 id="模式本质-15"><a href="#模式本质-15" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分离算法，选择实现</span><br></pre></td></tr></table></figure>





















<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Template Method Pattern</span><br><span class="line"></span><br><span class="line">定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</span><br><span class="line"></span><br><span class="line">它是一种类行为型模式，模板方法模式是一种基于继承的代码复用技术</span><br><span class="line"></span><br><span class="line">结构最简单的行为型设计模式，结构中只存在父类与子类之间的继承关系</span><br><span class="line"></span><br><span class="line">模板方法模式很好地体现了设计原则中的开闭原则和里式替换原则。</span><br></pre></td></tr></table></figure>





<h3 id="解决的问题-30"><a href="#解决的问题-30" class="headerlink" title="解决的问题"></a>解决的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某个方法的实现需要多个步骤，其中有些步骤是固定的，而有些步骤并不固定，存在可变性。为了提高代码的复用性和系统的灵活性，可以使用一种称之为模板方法模式的设计模式来对这类情况进行设计</span><br></pre></td></tr></table></figure>



<h3 id="解决的方式-11"><a href="#解决的方式-11" class="headerlink" title="解决的方式"></a>解决的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义抽象类：只能是抽象类，定义一些列基本操作，可以是具体也可以是抽象的，子类中可以重定义或实现。实现一个模板方法用于定义算法的框架</span><br><span class="line">定义具体类：继承抽象类，实现抽象类声明的抽象基本操作或覆盖在父类中已经实现的具体基本操作</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加以修改地完全继承下来。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">基本方法是实现算法各个步骤的方法，是模板方法的组成部分。分为三种：</span><br><span class="line">	抽象方法(Abstract Method)：在抽象类声明、由其具体子类实现</span><br><span class="line">	</span><br><span class="line">	具体方法(Concrete Method)：在一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</span><br><span class="line">	</span><br><span class="line">	钩子方法(Hook Method)：在一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">钩子方法有两类：</span><br><span class="line">	与一些具体步骤挂钩，以实现在不同条件下执行模板方法中的不同步骤，这类钩子方法的返回类型通常是bool类型的</span><br><span class="line">	这类方法名一般为IsXXX()，用于对某个条件进行判断，如果条件满足则执行某一步骤，否则将不执行</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107134649481.png" alt="image-20241107134649481"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">还有一类钩子方法就是实现体为空的具体方法，子类可以根据需要覆盖或者继承这些钩子方法。</span><br><span class="line">与抽象方法相比，这类钩子方法的好处在于子类如果没有覆盖父类中定义的钩子方法，编译可以正常通过，但是如果没有覆盖父类中声明的抽象方法，编译将报错。</span><br></pre></td></tr></table></figure>



<h3 id="模式结构-22"><a href="#模式结构-22" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241107133741773.png" alt="image-20241107133741773"></p>
<h3 id="模式优缺点-20"><a href="#模式优缺点-20" class="headerlink" title="模式优缺点"></a>模式优缺点</h3><h4 id="模式优点-15"><a href="#模式优点-15" class="headerlink" title="模式优点"></a>模式优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</span><br><span class="line"></span><br><span class="line">模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。</span><br><span class="line"></span><br><span class="line">可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。</span><br><span class="line"></span><br><span class="line">在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合开闭原则。</span><br></pre></td></tr></table></figure>



<h4 id="模式缺点-15"><a href="#模式缺点-15" class="headerlink" title="模式缺点"></a>模式缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。</span><br><span class="line"></span><br><span class="line">算法骨架不容易升级，如果要对模板中的算法骨架进行变更，可能就会要求所有相关的子类进行相应的变化。所以抽取算法骨架的时候要尽量确保是不会变化的部分才放到模板中。</span><br></pre></td></tr></table></figure>







<h3 id="模式适用环境-20"><a href="#模式适用环境-20" class="headerlink" title="模式适用环境"></a>模式适用环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。</span><br><span class="line"></span><br><span class="line">各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</span><br><span class="line"></span><br><span class="line">需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</span><br></pre></td></tr></table></figure>





<h4 id="现实应用-20"><a href="#现实应用-20" class="headerlink" title="现实应用"></a>现实应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模板方法广泛应用于框架设计(如Spring，Struts等)中，以确保父类控制处理流程的逻辑顺序。</span><br><span class="line">作为一种基本的代码复用技术，模板方法在MFC中得到大量的应用。如在MFC的源程序VIEWCORE.CPP中，类CView(AbstractClass)对Windows消息WM_PAINT的相应函数OnPaint就是一个TemplateMethod。</span><br></pre></td></tr></table></figure>







<h3 id="模式扩展-19"><a href="#模式扩展-19" class="headerlink" title="模式扩展"></a>模式扩展</h3><h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在模板方法模式中，子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，父类控制对子类的调用，这种机制被称为好莱坞原则(Hollywood Principle)，好莱坞原则定义为：不要给我们打电话，我们会给你打电话(Don&#x27;t call us, we&#x27;ll call you)。</span><br><span class="line"></span><br><span class="line">在模板方法模式中，好莱坞原则体现在：子类不需要调用父类，而通过父类来调用子类，将某些步骤的实现写在子类中，由父类来控制整个过程。 </span><br></pre></td></tr></table></figure>



<h4 id="模板方法模式和策略模式"><a href="#模板方法模式和策略模式" class="headerlink" title="模板方法模式和策略模式"></a>模板方法模式和策略模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从表面上看，两个模式都能实现算法的封装</span><br><span class="line"></span><br><span class="line">但是模板方法封装的是算法的骨架，这个算法骨架是不变的，变化的是算法中某些步骤的具体实现；</span><br><span class="line"></span><br><span class="line">而策略模式是把某个步骤的具体实现算法封装起来，所有封装的算法对象是等价的，可以相互替换。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以在模板方法中使用策略模式，就是把那些变化的算法步骤通过使用策略模式来实现。</span><br><span class="line">也可以在策略模式中使用模板方法</span><br></pre></td></tr></table></figure>







<h3 id="模式本质-16"><a href="#模式本质-16" class="headerlink" title="模式本质"></a>模式本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">固定算法骨架</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">fleeadango</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">http://example.com/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">fleeadango-tech-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/">课程复习</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/fleeadango/blog_pics@master/img/avatar4blog.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81/" title="吉林大学设计模式代码总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">吉林大学设计模式代码总结</div></div><div class="info-2"><div class="info-item-1"> 配合设计模式总结笔记使用  设计模式代码创建型模式简单工厂模式（Simple Factory）模式结构 简单示例代码1非常容易理解所以此处不提供代码    简单模式的简化1静态工厂方法写到抽象产品类中   1同样非常容易理解所以此处不提供代码                工厂方法模式(Factory Method)模式结构 简单示例代码1Factory  12345public abstract class PayMethodFactory&#123;    public abstract AbstractPay getPayMethod();&#125;    1ConcreteFactory  1234567public class CashPayFactory extends PayMethodFactory&#123;    public AbstractPay getPayMethod()    &#123;        return new CashPay();    &#125;&#125;...</div></div></div></a><a class="pagination-related" href="/2024/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/" title="吉林大学计算机网络复习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">吉林大学计算机网络复习笔记</div></div><div class="info-2"><div class="info-item-1">背诵第一章两种描述“因特网”的方式12345678910描述构成因特网的具体构成，基本硬件和软件组件主机/端系统通信链路分组交换机因特网服务提供商 ISP协议Internet standards（因特网工程任务组 IETF/请求评论 RFC）描述为基础设施向分布式应用程序提供的服务。套接字接口    因特网服务提供商 ISP的作用123提供不同种类的网络接入，住宅宽带接入DSL、高速局域网接入、移动无线接入    不同层ISP12345较高层ISP通过高速光纤链路和高速路由器组成；较低层ISP通过国家的、国际的较高层ISP互联到因特网无论高层还是低层ISP都独立管理    网络协议的特点123通信双方交换报文通信实体是设备因特网中两个或多个通信实体的所有活动都受协议的制约    接入网络的类型12345678910111213141516171819202122232425262728293031家庭接入网	宽带住宅接入有两种流行方式：		数字用户线 DSL		use existing telephone line(双绞线) to central...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0%E7%9B%B2%E7%82%B9/" title="吉林大学机器学习B复习盲点总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">吉林大学机器学习B复习盲点总结</div></div><div class="info-2"><div class="info-item-1"> 当然下面的内容并非都会考到，博主为了追求满绩才做了全面的整理  第一章   绪论1AIGC(AI Generated Content)模型  12345ChatGPT=GPT+人类反馈强化学习GPT=Generative Pre-trained TransformerGenerative：生成模型(ChatGPT生成的是文本)Pre-trained：预训练Transformer：一种基于Self-Attention的网络模型  1机器学习≈寻找一个函数  1机器学习的基本流程   1234567891011机器学习算法的类型监督学习	回归	分类无监督学习	聚类	降维半监督学习自监督学习强化学习    1半监督两个基本假设     123强化学习与判别学习的区别	强化学习通过判别学习	有监督学习通过指导学习   第二章  ...</div></div></div></a><a class="pagination-related" href="/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81/" title="吉林大学设计模式代码总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">吉林大学设计模式代码总结</div></div><div class="info-2"><div class="info-item-1"> 配合设计模式总结笔记使用  设计模式代码创建型模式简单工厂模式（Simple Factory）模式结构 简单示例代码1非常容易理解所以此处不提供代码    简单模式的简化1静态工厂方法写到抽象产品类中   1同样非常容易理解所以此处不提供代码                工厂方法模式(Factory Method)模式结构 简单示例代码1Factory  12345public abstract class PayMethodFactory&#123;    public abstract AbstractPay getPayMethod();&#125;    1ConcreteFactory  1234567public class CashPayFactory extends PayMethodFactory&#123;    public AbstractPay getPayMethod()    &#123;        return new CashPay();    &#125;&#125;...</div></div></div></a><a class="pagination-related" href="/2024/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/" title="吉林大学计算机网络复习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-20</div><div class="info-item-2">吉林大学计算机网络复习笔记</div></div><div class="info-2"><div class="info-item-1">背诵第一章两种描述“因特网”的方式12345678910描述构成因特网的具体构成，基本硬件和软件组件主机/端系统通信链路分组交换机因特网服务提供商 ISP协议Internet standards（因特网工程任务组 IETF/请求评论 RFC）描述为基础设施向分布式应用程序提供的服务。套接字接口    因特网服务提供商 ISP的作用123提供不同种类的网络接入，住宅宽带接入DSL、高速局域网接入、移动无线接入    不同层ISP12345较高层ISP通过高速光纤链路和高速路由器组成；较低层ISP通过国家的、国际的较高层ISP互联到因特网无论高层还是低层ISP都独立管理    网络协议的特点123通信双方交换报文通信实体是设备因特网中两个或多个通信实体的所有活动都受协议的制约    接入网络的类型12345678910111213141516171819202122232425262728293031家庭接入网	宽带住宅接入有两种流行方式：		数字用户线 DSL		use existing telephone line(双绞线) to central...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/fleeadango/blog_pics@master/img/avatar4blog.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">fleeadango</div><div class="author-info-description">to be continue</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%83%8C%E6%99%AF%E5%8F%8A%E6%84%8F%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">课程背景及意义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">软件设计模式和面向对象的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">面向对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A4%8D%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">面向对象设计与复用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.1.</span> <span class="toc-text">什么是面向设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">2.2.</span> <span class="toc-text">面向对象设计的层次</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E7%BA%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">框架级设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.2.</span> <span class="toc-text">代码设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.3.</span> <span class="toc-text">类设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.</span> <span class="toc-text">类间关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.1.</span> <span class="toc-text">依赖关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UML%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">UML表示方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">依赖关系的几种表现形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.2.</span> <span class="toc-text">关联关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UML%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95-1"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">UML表示方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">关联关系的几种表现形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88-%E8%81%9A%E9%9B%86%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.3.</span> <span class="toc-text">聚合&#x2F;聚集关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UML%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95-2"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">UML表示方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88-%E5%90%88%E6%88%90%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.4.</span> <span class="toc-text">组合&#x2F;合成关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-3"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UML%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95-3"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">UML表示方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.5.</span> <span class="toc-text">泛化关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UML%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95-4"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">UML表示方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.6.</span> <span class="toc-text">实现关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UML%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95-5"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">UML表示方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB%E5%BC%BA%E5%BC%B1%E7%A8%8B%E5%BA%A6"><span class="toc-number">2.3.7.</span> <span class="toc-text">类间关系强弱程度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E5%8F%98%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%A4%8D%E7%94%A8%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">2.3.8.</span> <span class="toc-text">适应变化实现复用的策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.4.</span> <span class="toc-text">类的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">2.4.1.</span> <span class="toc-text">开闭原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%80%A7"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">开闭原则的相对性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">2.4.2.</span> <span class="toc-text">里氏替换原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9D%E5%8F%8DLSP%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">违反LSP如何修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99"><span class="toc-number">2.4.3.</span> <span class="toc-text">迪米特原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E6%9C%8B%E5%8F%8B%E2%80%9D%E7%9A%84%E5%88%A4%E5%AE%9A%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">“朋友”的判定条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E8%A1%B7"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">初衷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90%E7%9A%84%E5%90%8E%E6%9E%9C"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">应用迪米特法则可能造成的后果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">2.4.4.</span> <span class="toc-text">单一职责原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E8%83%BD%E6%9C%89%E5%A4%9A%E4%BA%8E%E4%B8%80%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">为什么一个类不能有多于一个以上的职责</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%86%E9%9A%94%E5%8E%9F%E5%88%99"><span class="toc-number">2.4.5.</span> <span class="toc-text">接口分隔原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%81%B5%E5%AE%88%E6%8E%A5%E5%8F%A3%E5%88%86%E5%89%B2%E5%8E%9F%E5%88%99"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">为什么要遵守接口分割原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E4%B8%8E%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">2.4.5.2.</span> <span class="toc-text">单一职责原则与接口隔离原则的共同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E4%B8%8E%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.5.3.</span> <span class="toc-text">单一职责原则与接口隔离原则的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">2.4.6.</span> <span class="toc-text">依赖倒置原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bad-Design%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">Bad Design的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">解决方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%90%AF%E5%8F%91"><span class="toc-number">2.4.6.3.</span> <span class="toc-text">带来的启发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88-%E8%81%9A%E5%90%88%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">2.4.7.</span> <span class="toc-text">组合&#x2F;聚合复用原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Coad%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">Coad条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88-%E8%81%9A%E5%90%88%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">通过组合&#x2F;聚合复用的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.4.7.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">2.4.7.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.4.7.3.</span> <span class="toc-text">通过继承来进行复用的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">2.4.7.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">2.4.7.3.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">设计模式概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">模式的诞生与定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E5%8F%91%E5%B1%95"><span class="toc-number">3.2.</span> <span class="toc-text">设计模式的诞生与发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.</span> <span class="toc-text">设计模式的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-number">3.4.</span> <span class="toc-text">设计模式的基本要素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%A4%E5%A4%A7%E4%B8%BB%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text">设计模式的两大主题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.6.</span> <span class="toc-text">设计模式的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.7.</span> <span class="toc-text">设计模式的优点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">创建者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">解决的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9"><span class="toc-number">4.1.1.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9"><span class="toc-number">4.1.1.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">4.1.1.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8"><span class="toc-number">4.1.1.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-JDK%E7%B1%BB%E5%BA%93%E4%B8%AD%E6%97%A5%E6%9C%9F%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.1.1.5.1.1.</span> <span class="toc-text">1.JDK类库中日期工具类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-java%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF"><span class="toc-number">4.1.1.5.1.2.</span> <span class="toc-text">2.java加密技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-number">4.1.1.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96"><span class="toc-number">4.1.1.6.1.</span> <span class="toc-text">简单工厂模式的简化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.1.1.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-1"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">解决的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-1"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">4.1.2.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-1"><span class="toc-number">4.1.2.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-1"><span class="toc-number">4.1.2.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-1"><span class="toc-number">4.1.2.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-1"><span class="toc-number">4.1.2.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-Java%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.1.2.5.1.1.</span> <span class="toc-text">1.Java消息服务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-JDBC%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.5.1.2.</span> <span class="toc-text">2.JDBC中的工厂方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-1"><span class="toc-number">4.1.2.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.6.1.</span> <span class="toc-text">使用多个工厂方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A7%E5%93%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.2.6.2.</span> <span class="toc-text">产品对象的重复使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E4%B8%A7%E5%A4%B1%E5%92%8C%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%80%E5%8C%96"><span class="toc-number">4.1.2.6.3.</span> <span class="toc-text">多态性的丧失和模式的退化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-1"><span class="toc-number">4.1.2.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-2"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-2"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-2"><span class="toc-number">4.1.3.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-2"><span class="toc-number">4.1.3.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-2"><span class="toc-number">4.1.3.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-2"><span class="toc-number">4.1.3.5.1.</span> <span class="toc-text">现实应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Java-SE-AWT"><span class="toc-number">4.1.3.5.2.</span> <span class="toc-text">1.Java SE AWT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%8D%A2%E7%95%8C%E9%9D%A2%E4%B8%BB%E9%A2%98"><span class="toc-number">4.1.3.5.3.</span> <span class="toc-text">2.软件系统更换界面主题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-2"><span class="toc-number">4.1.3.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E7%9A%84%E5%80%BE%E6%96%9C%E6%80%A7"><span class="toc-number">4.1.3.6.1.</span> <span class="toc-text">开闭原则的倾斜性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%80%E5%8C%96"><span class="toc-number">4.1.3.6.2.</span> <span class="toc-text">工厂模式的退化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-2"><span class="toc-number">4.1.3.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-3"><span class="toc-number">4.2.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-3"><span class="toc-number">4.2.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="toc-number">4.2.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-3"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-3"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-3"><span class="toc-number">4.2.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-3"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-JavaMail"><span class="toc-number">4.2.5.1.1.</span> <span class="toc-text">1.JavaMail</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B8%B8%E6%88%8F%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9C%B0%E5%9B%BE%E6%88%96%E4%BA%BA%E7%89%A9"><span class="toc-number">4.2.5.1.2.</span> <span class="toc-text">2.游戏中不同类型的地图或人物</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-3"><span class="toc-number">4.2.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">建造者模式的简化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.6.2.</span> <span class="toc-text">建造者模式与抽象工厂模式的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.2.6.3.</span> <span class="toc-text">建造者模式的本质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-4"><span class="toc-number">4.3.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-4"><span class="toc-number">4.3.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-4"><span class="toc-number">4.3.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-4"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-4"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-4"><span class="toc-number">4.3.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-4"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A4%8D%E5%88%B6%E5%92%8C%E7%B2%98%E8%B4%B4"><span class="toc-number">4.3.5.1.1.</span> <span class="toc-text">1.复制和粘贴</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Struts2%E4%B8%AD%E7%9A%84Action%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="toc-number">4.3.5.1.2.</span> <span class="toc-text">2.Struts2中的Action对象创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Spring%E4%B8%ADbean%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.3.5.1.3.</span> <span class="toc-text">3.Spring中bean实例的创建</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-4"><span class="toc-number">4.3.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8E%9F%E5%9E%8B%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.6.1.</span> <span class="toc-text">带原型管理器的原型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E4%BC%BC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">4.3.6.2.</span> <span class="toc-text">相似对象的复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E5%85%8B%E9%9A%86%E5%92%8C%E6%B7%B1%E5%85%8B%E9%9A%86"><span class="toc-number">4.3.6.3.</span> <span class="toc-text">浅克隆和深克隆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%AF%94%E8%BE%83"><span class="toc-number">4.3.6.4.</span> <span class="toc-text">原型模式与拷贝构造比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-3"><span class="toc-number">4.3.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-5"><span class="toc-number">4.4.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F-3"><span class="toc-number">4.4.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-5"><span class="toc-number">4.4.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-5"><span class="toc-number">4.4.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-5"><span class="toc-number">4.4.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-5"><span class="toc-number">4.4.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-5"><span class="toc-number">4.4.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-5"><span class="toc-number">4.4.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Java-lang-Runtime%E7%B1%BB"><span class="toc-number">4.4.5.1.1.</span> <span class="toc-text">1.Java.lang.Runtime类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7%E7%9A%84%E4%B8%BB%E9%94%AE%E7%BC%96%E5%8F%B7%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">4.4.5.1.2.</span> <span class="toc-text">2.数据库中自动编号的主键编号生成器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8BSpring%E5%88%9B%E5%BB%BAbean%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.4.5.1.3.</span> <span class="toc-text">3.默认情况下Spring创建bean实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-5"><span class="toc-number">4.4.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="toc-number">4.4.6.1.</span> <span class="toc-text">饿汉式单例类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="toc-number">4.4.6.2.</span> <span class="toc-text">懒汉式单例类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-4"><span class="toc-number">4.4.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">结构性模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.1.</span> <span class="toc-text">类结构模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">对象结构模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-6"><span class="toc-number">5.2.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">解决方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-6"><span class="toc-number">5.2.3.</span> <span class="toc-text">模式结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">类适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">对象适配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-6"><span class="toc-number">5.2.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">优点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E8%80%8C%E8%A8%80"><span class="toc-number">5.2.4.1.1.</span> <span class="toc-text">对于类适配器而言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E8%80%8C%E8%A8%80"><span class="toc-number">5.2.4.1.2.</span> <span class="toc-text">对于对象适配器而言</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">5.2.4.2.</span> <span class="toc-text">缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E8%80%8C%E8%A8%80-1"><span class="toc-number">5.2.4.2.1.</span> <span class="toc-text">对于类适配器而言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E8%80%8C%E8%A8%80-1"><span class="toc-number">5.2.4.2.2.</span> <span class="toc-text">对于对象适配器而言</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-6"><span class="toc-number">5.2.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-6"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">现实应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-6"><span class="toc-number">5.2.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.6.1.</span> <span class="toc-text">默认适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-7"><span class="toc-number">5.2.6.1.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.6.1.2.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-7"><span class="toc-number">5.2.6.1.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.2.6.1.4.</span> <span class="toc-text">应用实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.6.2.</span> <span class="toc-text">双向适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-8"><span class="toc-number">5.2.6.2.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-number">5.2.6.2.2.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-8"><span class="toc-number">5.2.6.2.3.</span> <span class="toc-text">模式结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.6.3.</span> <span class="toc-text">智能适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-9"><span class="toc-number">5.2.6.3.1.</span> <span class="toc-text">解决的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%A4%9A%E4%B8%AA%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.6.4.</span> <span class="toc-text">适配多个适配者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-10"><span class="toc-number">5.2.6.4.1.</span> <span class="toc-text">解决的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-5"><span class="toc-number">5.2.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">桥接模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-11"><span class="toc-number">5.3.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F-2"><span class="toc-number">5.3.2.</span> <span class="toc-text">解决方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-9"><span class="toc-number">5.3.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-7"><span class="toc-number">5.3.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">5.3.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">5.3.4.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-7"><span class="toc-number">5.3.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-7"><span class="toc-number">5.3.5.1.</span> <span class="toc-text">现实应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-7"><span class="toc-number">5.3.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E8%81%94%E7%94%A8"><span class="toc-number">5.3.6.1.</span> <span class="toc-text">适配器模式与桥接模式联用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-12"><span class="toc-number">5.3.6.1.1.</span> <span class="toc-text">解决的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%9C%AC%E8%B4%A8"><span class="toc-number">5.3.7.</span> <span class="toc-text">模型本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-13"><span class="toc-number">5.4.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F-3"><span class="toc-number">5.4.2.</span> <span class="toc-text">解决方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-10"><span class="toc-number">5.4.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-8"><span class="toc-number">5.4.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-4"><span class="toc-number">5.4.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-4"><span class="toc-number">5.4.4.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-8"><span class="toc-number">5.4.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-8"><span class="toc-number">5.4.5.1.</span> <span class="toc-text">现实应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-8"><span class="toc-number">5.4.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.4.6.1.</span> <span class="toc-text">透明组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-14"><span class="toc-number">5.4.6.1.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">5.4.6.1.2.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-5"><span class="toc-number">5.4.6.1.3.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.4.6.2.</span> <span class="toc-text">安全组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84-1"><span class="toc-number">5.4.6.2.1.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-6"><span class="toc-number">5.4.6.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.4.6.3.</span> <span class="toc-text">更复杂的组合模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-6"><span class="toc-number">5.4.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.5.</span> <span class="toc-text">装饰模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-15"><span class="toc-number">5.5.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F-4"><span class="toc-number">5.5.2.</span> <span class="toc-text">解决方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-11"><span class="toc-number">5.5.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-9"><span class="toc-number">5.5.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-5"><span class="toc-number">5.5.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-7"><span class="toc-number">5.5.4.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-9"><span class="toc-number">5.5.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-9"><span class="toc-number">5.5.5.1.</span> <span class="toc-text">现实应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-9"><span class="toc-number">5.5.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.5.6.1.</span> <span class="toc-text">透明装饰系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-16"><span class="toc-number">5.5.6.1.1.</span> <span class="toc-text">解决的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.5.6.2.</span> <span class="toc-text">半透明装饰模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-17"><span class="toc-number">5.5.6.2.1.</span> <span class="toc-text">解决的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96"><span class="toc-number">5.5.6.3.</span> <span class="toc-text">装饰模式的简化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-7"><span class="toc-number">5.5.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.6.</span> <span class="toc-text">外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-18"><span class="toc-number">5.6.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F-5"><span class="toc-number">5.6.2.</span> <span class="toc-text">解决方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-12"><span class="toc-number">5.6.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-10"><span class="toc-number">5.6.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-6"><span class="toc-number">5.6.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-8"><span class="toc-number">5.6.4.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-10"><span class="toc-number">5.6.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-10"><span class="toc-number">5.6.5.1.</span> <span class="toc-text">现实应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-10"><span class="toc-number">5.6.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%B3%BB%E7%BB%9F%E5%A4%9A%E5%A4%96%E8%A7%82%E7%B1%BB"><span class="toc-number">5.6.6.1.</span> <span class="toc-text">单系统多外观类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-19"><span class="toc-number">5.6.6.1.1.</span> <span class="toc-text">解决的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%A4%96%E8%A7%82%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">5.6.6.2.</span> <span class="toc-text">抽象外观类的引入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-20"><span class="toc-number">5.6.6.2.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.6.2.2.</span> <span class="toc-text">解决方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-8"><span class="toc-number">5.6.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.7.</span> <span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-21"><span class="toc-number">5.7.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F-6"><span class="toc-number">5.7.2.</span> <span class="toc-text">解决方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-13"><span class="toc-number">5.7.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-11"><span class="toc-number">5.7.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-6"><span class="toc-number">5.7.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-6"><span class="toc-number">5.7.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-11"><span class="toc-number">5.7.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-11"><span class="toc-number">5.7.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-java-RMI"><span class="toc-number">5.7.5.1.1.</span> <span class="toc-text">1. java RMI</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84AOP%E6%8A%80%E6%9C%AF"><span class="toc-number">5.7.5.1.2.</span> <span class="toc-text">2. Spring框架中的AOP技术</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.5.1.3.</span> <span class="toc-text">3.远程代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%99%9A%E6%8B%9F%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.5.1.4.</span> <span class="toc-text">4.虚拟代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-11"><span class="toc-number">5.7.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.6.1.</span> <span class="toc-text">远程代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.6.2.</span> <span class="toc-text">虚拟代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.6.3.</span> <span class="toc-text">保护代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.6.4.</span> <span class="toc-text">缓冲代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%BC%95%E7%94%A8%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.6.5.</span> <span class="toc-text">智能引用代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E7%81%AB%E5%A2%99%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.6.6.</span> <span class="toc-text">防火墙代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.6.7.</span> <span class="toc-text">同步代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%97%B6%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.6.8.</span> <span class="toc-text">写入时复制代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.6.9.</span> <span class="toc-text">动态代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-9"><span class="toc-number">5.7.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-1"><span class="toc-number">6.1.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">类行为型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.2.</span> <span class="toc-text">对象行为型模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">职责链模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-22"><span class="toc-number">6.2.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F-7"><span class="toc-number">6.2.2.</span> <span class="toc-text">解决方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-14"><span class="toc-number">6.2.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-12"><span class="toc-number">6.2.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-7"><span class="toc-number">6.2.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-7"><span class="toc-number">6.2.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-12"><span class="toc-number">6.2.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-12"><span class="toc-number">6.2.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.5.1.1.</span> <span class="toc-text">1. java中的异常处理机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-SpringMVC%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8Filter"><span class="toc-number">6.2.5.1.2.</span> <span class="toc-text">2. SpringMVC中的过滤器Filter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BA%8B%E4%BB%B6%E6%B5%AE%E5%8D%87-Event-Bubbling-%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.5.1.3.</span> <span class="toc-text">3. 事件浮升(Event Bubbling)机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-12"><span class="toc-number">6.2.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E7%BA%AF%E7%9A%84%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.6.1.</span> <span class="toc-text">不纯的职责链模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%9C%AC%E8%B4%A8-1"><span class="toc-number">6.2.7.</span> <span class="toc-text">模型本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-23"><span class="toc-number">6.3.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F-4"><span class="toc-number">6.3.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-15"><span class="toc-number">6.3.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-13"><span class="toc-number">6.3.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-8"><span class="toc-number">6.3.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-8"><span class="toc-number">6.3.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-13"><span class="toc-number">6.3.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-13"><span class="toc-number">6.3.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-AWT-Swing-GUI%E7%9A%84%E5%A7%94%E6%B4%BE%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.5.1.1.</span> <span class="toc-text">1. AWT&#x2F;Swing(GUI的委派事件模型)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">6.3.5.1.2.</span> <span class="toc-text">2. 宏命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%89%A9%E5%B1%95"><span class="toc-number">6.3.6.</span> <span class="toc-text">模型扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97"><span class="toc-number">6.3.6.1.</span> <span class="toc-text">命令队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%97%A5%E5%BF%97"><span class="toc-number">6.3.6.2.</span> <span class="toc-text">请求日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C"><span class="toc-number">6.3.6.3.</span> <span class="toc-text">撤销操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">6.3.6.4.</span> <span class="toc-text">宏命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-10"><span class="toc-number">6.3.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">迭代器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-24"><span class="toc-number">6.4.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F-5"><span class="toc-number">6.4.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-16"><span class="toc-number">6.4.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-14"><span class="toc-number">6.4.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-9"><span class="toc-number">6.4.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-9"><span class="toc-number">6.4.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-14"><span class="toc-number">6.4.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-14"><span class="toc-number">6.4.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Java%E8%81%9A%E5%90%88%E6%A1%86%E6%9E%B6Collections"><span class="toc-number">6.4.5.1.1.</span> <span class="toc-text">1. Java聚合框架Collections</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-13"><span class="toc-number">6.4.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%A4%96%E9%83%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">6.4.6.1.</span> <span class="toc-text">内部迭代器和外部迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E8%BF%AD%E4%BB%A3%E7%AD%96%E7%95%A5%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">6.4.6.2.</span> <span class="toc-text">带迭代策略的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">6.4.6.3.</span> <span class="toc-text">双向迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-11"><span class="toc-number">6.4.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.5.</span> <span class="toc-text">中介者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-25"><span class="toc-number">6.5.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F-6"><span class="toc-number">6.5.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-17"><span class="toc-number">6.5.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-15"><span class="toc-number">6.5.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-10"><span class="toc-number">6.5.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-10"><span class="toc-number">6.5.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-15"><span class="toc-number">6.5.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-15"><span class="toc-number">6.5.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-GUI%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.5.5.1.1.</span> <span class="toc-text">1.GUI应用程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-MVC"><span class="toc-number">6.5.5.1.2.</span> <span class="toc-text">2.MVC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-14"><span class="toc-number">6.5.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.5.6.1.</span> <span class="toc-text">中介者模式与外观模式的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%9C%AC%E8%B4%A8-2"><span class="toc-number">6.5.7.</span> <span class="toc-text">模型本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.6.</span> <span class="toc-text">备忘录模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-26"><span class="toc-number">6.6.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F-7"><span class="toc-number">6.6.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-18"><span class="toc-number">6.6.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-16"><span class="toc-number">6.6.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-11"><span class="toc-number">6.6.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-11"><span class="toc-number">6.6.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-16"><span class="toc-number">6.6.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-16"><span class="toc-number">6.6.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%96%87%E5%AD%97%E6%88%96%E5%9B%BE%E5%83%8F%E7%BC%96%E8%BE%91%E8%BD%AF%E4%BB%B6"><span class="toc-number">6.6.5.1.1.</span> <span class="toc-text">1.文字或图像编辑软件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8"><span class="toc-number">6.6.5.1.2.</span> <span class="toc-text">2.数据库管理系统的事务管理应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-15"><span class="toc-number">6.6.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%AC%A1%E6%92%A4%E9%94%80%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.6.6.1.</span> <span class="toc-text">多次撤销的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.6.6.2.</span> <span class="toc-text">备忘录模式和命令模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.6.6.3.</span> <span class="toc-text">备忘录模式和原型模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-12"><span class="toc-number">6.6.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.7.</span> <span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-27"><span class="toc-number">6.7.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F-8"><span class="toc-number">6.7.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-19"><span class="toc-number">6.7.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-17"><span class="toc-number">6.7.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-12"><span class="toc-number">6.7.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-12"><span class="toc-number">6.7.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-17"><span class="toc-number">6.7.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-17"><span class="toc-number">6.7.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-JDK%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.7.5.1.1.</span> <span class="toc-text">1.JDK的事件模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-JDK%E7%9A%84Observable%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.7.5.1.2.</span> <span class="toc-text">2.JDK的Observable接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-MVC%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.7.5.1.3.</span> <span class="toc-text">3.MVC模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-16"><span class="toc-number">6.7.6.</span> <span class="toc-text">模式扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-13"><span class="toc-number">6.7.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.8.</span> <span class="toc-text">状态模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-28"><span class="toc-number">6.8.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F-9"><span class="toc-number">6.8.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-20"><span class="toc-number">6.8.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-18"><span class="toc-number">6.8.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-13"><span class="toc-number">6.8.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-13"><span class="toc-number">6.8.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-18"><span class="toc-number">6.8.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-18"><span class="toc-number">6.8.5.1.</span> <span class="toc-text">现实应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-17"><span class="toc-number">6.8.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81"><span class="toc-number">6.8.6.1.</span> <span class="toc-text">共享状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.8.6.2.</span> <span class="toc-text">简单状态模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.8.6.3.</span> <span class="toc-text">状态模式和观察者模式的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-14"><span class="toc-number">6.8.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.9.</span> <span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-29"><span class="toc-number">6.9.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F-10"><span class="toc-number">6.9.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-21"><span class="toc-number">6.9.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-19"><span class="toc-number">6.9.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-14"><span class="toc-number">6.9.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-14"><span class="toc-number">6.9.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-19"><span class="toc-number">6.9.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-19"><span class="toc-number">6.9.5.1.</span> <span class="toc-text">现实应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-JavaSE%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86"><span class="toc-number">6.9.5.1.1.</span> <span class="toc-text">1.JavaSE的容器布局管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-18"><span class="toc-number">6.9.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">6.9.6.1.</span> <span class="toc-text">策略模式与状态模式的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-15"><span class="toc-number">6.9.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.10.</span> <span class="toc-text">模板方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-30"><span class="toc-number">6.10.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F-11"><span class="toc-number">6.10.2.</span> <span class="toc-text">解决的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-22"><span class="toc-number">6.10.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9-20"><span class="toc-number">6.10.4.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9-15"><span class="toc-number">6.10.4.1.</span> <span class="toc-text">模式优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-15"><span class="toc-number">6.10.4.2.</span> <span class="toc-text">模式缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-20"><span class="toc-number">6.10.5.</span> <span class="toc-text">模式适用环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8-20"><span class="toc-number">6.10.5.1.</span> <span class="toc-text">现实应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-19"><span class="toc-number">6.10.6.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%BD%E8%8E%B1%E5%9D%9E%E5%8E%9F%E5%88%99"><span class="toc-number">6.10.6.1.</span> <span class="toc-text">好莱坞原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.10.6.2.</span> <span class="toc-text">模板方法模式和策略模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%9C%AC%E8%B4%A8-16"><span class="toc-number">6.10.7.</span> <span class="toc-text">模式本质</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/29/hello-world/" title="Hello World">Hello World</a><time datetime="2025-05-29T10:41:10.390Z" title="发表于 2025-05-29 18:41:10">2025-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0/" title="左程云算法思想学习笔记——B站视频（待更新）">左程云算法思想学习笔记——B站视频（待更新）</a><time datetime="2025-04-18T14:16:13.000Z" title="发表于 2025-04-18 22:16:13">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/java%E7%BC%96%E7%A8%8Bapi/" title="Java刷题一些常见的api">Java刷题一些常见的api</a><time datetime="2025-01-29T14:14:24.000Z" title="发表于 2025-01-29 22:14:24">2025-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/JUC/" title="黑马程序员JUC学习笔记">黑马程序员JUC学习笔记</a><time datetime="2025-01-29T14:14:24.000Z" title="发表于 2025-01-29 22:14:24">2025-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/netty/" title="黑马程序员Netty学习笔记">黑马程序员Netty学习笔记</a><time datetime="2025-01-29T14:12:24.000Z" title="发表于 2025-01-29 22:12:24">2025-01-29</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By fleeadango</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>