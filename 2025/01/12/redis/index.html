<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>黑马程序员Redis学习笔记 | fleeadango-tech-blog</title><meta name="author" content="fleeadango"><meta name="copyright" content="fleeadango"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础篇认识NoSQL对比SQL和NoSQL123456789扩展性处：主要是说	SQL型数据库的性能主要取决于其所处机器的性能（若要分库需要引入第三方组件）	NoSQL型数据库天然支持数据在多个节点上的存储（会对每条数据生成唯一HASHID来判断该数据应该存储在哪个结点）	BASE是指:	BA: Basically Availible(是指允许分布式系统中某些部分出现故障，系统的其余部分依然可以用">
<meta property="og:type" content="article">
<meta property="og:title" content="黑马程序员Redis学习笔记">
<meta property="og:url" content="http://example.com/2025/01/12/redis/index.html">
<meta property="og:site_name" content="fleeadango-tech-blog">
<meta property="og:description" content="基础篇认识NoSQL对比SQL和NoSQL123456789扩展性处：主要是说	SQL型数据库的性能主要取决于其所处机器的性能（若要分库需要引入第三方组件）	NoSQL型数据库天然支持数据在多个节点上的存储（会对每条数据生成唯一HASHID来判断该数据应该存储在哪个结点）	BASE是指:	BA: Basically Availible(是指允许分布式系统中某些部分出现故障，系统的其余部分依然可以用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-01-12T04:16:24.000Z">
<meta property="article:modified_time" content="2025-05-30T06:12:55.377Z">
<meta property="article:author" content="fleeadango">
<meta property="article:tag" content="开发技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "黑马程序员Redis学习笔记",
  "url": "http://example.com/2025/01/12/redis/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-01-12T04:16:24.000Z",
  "dateModified": "2025-05-30T06:12:55.377Z",
  "author": [
    {
      "@type": "Person",
      "name": "fleeadango",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/01/12/redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '黑马程序员Redis学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://cdn.jsdelivr.net/gh/fleeadango/blog_pics@master/img/preview.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">fleeadango-tech-blog</span></a><a class="nav-page-title" href="/"><span class="site-name">黑马程序员Redis学习笔记</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">黑马程序员Redis学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-12T04:16:24.000Z" title="发表于 2025-01-12 12:16:24">2025-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-30T06:12:55.377Z" title="更新于 2025-05-30 14:12:55">2025-05-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="认识NoSQL"><a href="#认识NoSQL" class="headerlink" title="认识NoSQL"></a>认识NoSQL</h2><h3 id="对比SQL和NoSQL"><a href="#对比SQL和NoSQL" class="headerlink" title="对比SQL和NoSQL"></a>对比SQL和NoSQL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">扩展性处：主要是说</span><br><span class="line">	SQL型数据库的性能主要取决于其所处机器的性能（若要分库需要引入第三方组件）</span><br><span class="line">	NoSQL型数据库天然支持数据在多个节点上的存储（会对每条数据生成唯一HASHID来判断该数据应该存储在哪个结点）</span><br><span class="line">	</span><br><span class="line">BASE是指:</span><br><span class="line">	BA: Basically Availible(是指允许分布式系统中某些部分出现故障，系统的其余部分依然可以用)</span><br><span class="line">	S: Soft State(在数据处理过程中，允许这个过程，存在数据状态暂时不一致的情况。但经过纠错处理，最终会一致)</span><br><span class="line">	E: Eventually Consistent(NoSQL的软状态允许数据处理过程的暂时不一致，但是最终处理结果将是一致的，说明NoSQL对数据处理过程可以有短暂的时间间隔，也允许分更细的步骤一个一个地处理，最后数据达到一致即可)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241129141945336.png" alt="image-20241129141945336"></p>
<h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Remote Dictionary Server</span><br><span class="line"></span><br><span class="line">远程词典服务器，一个基于内存的键值型NoSQL数据库</span><br><span class="line"></span><br><span class="line">特征:</span><br><span class="line">键值（key-value）型，value支持多种不同数据结构，功能丰富</span><br><span class="line"></span><br><span class="line">单线程，每个命令具备原子性（Redis6.0中仅在处理网络请求时使用多线程，核心命令的处理仍为单线程）</span><br><span class="line"></span><br><span class="line">低延迟，速度快（基于内存、I0多路复用、良好的编码）</span><br><span class="line"></span><br><span class="line">支持数据持久化</span><br><span class="line"></span><br><span class="line">支持主从集群、分片集群（分片即为拆分数据的存储）</span><br><span class="line"></span><br><span class="line">支持多语言客户端</span><br></pre></td></tr></table></figure>







<h3 id="Linux环境安装并配置Redis"><a href="#Linux环境安装并配置Redis" class="headerlink" title="Linux环境安装并配置Redis"></a>Linux环境安装并配置Redis</h3><h4 id="单机安装Redis"><a href="#单机安装Redis" class="headerlink" title="单机安装Redis"></a>单机安装Redis</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装Redis依赖（Redis基于C语言编写，所以需要首先安装gcc依赖）</span><br><span class="line"></span><br><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">上传安装包并解压</span><br><span class="line">tar -zxvf redis-6.2.6.tar.gz</span><br><span class="line"></span><br><span class="line">进入redis目录</span><br><span class="line">cd redis-6.2.6</span><br><span class="line"></span><br><span class="line">进行编译</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli: redis提供的命令行客户端</span><br><span class="line">redis-server: redis提供的服务端启动i奥本</span><br><span class="line">redis-sentinel: redis的哨兵启动脚本</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认启动</span><br><span class="line">命令行redis-server</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">指定配置启动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">备份Redis配置文件</span><br><span class="line">cp redis.conf redis.conf.bck</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改redis.conf中的一些配置</span><br><span class="line"></span><br><span class="line">#允许访问的地址，默认是127.0.0.1，会导致只能在本地访问，修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 守护进程，修改为yes后即可后台运行</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line">#密码，设置后访问Redis必须输入码</span><br><span class="line">requirepass 123321</span><br><span class="line"></span><br><span class="line">#监听的端囗</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">#工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><br><span class="line">dir .</span><br><span class="line"></span><br><span class="line">#数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><br><span class="line">databases 1</span><br><span class="line"></span><br><span class="line">#设置redis能够使用的最大内存</span><br><span class="line">maxmemory 512mb</span><br><span class="line"></span><br><span class="line">#日志文件，默认为空，不记录日志，可以指定日志文件名</span><br><span class="line">logfile &quot;redis.log&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启动redis</span><br><span class="line"></span><br><span class="line">#进入redis安装目录</span><br><span class="line">cd /usr/local/src/redis-6.2.6</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">redis-server redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">停止服务</span><br><span class="line">#利用redis-cli来执行shutdown 命令，即可停止Redis 服务</span><br><span class="line">#因为之前配置了密码，因此需要通过-u来指定密码</span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">开机自启</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先创建系统服务文件</span><br><span class="line">vi /etc/systemd/system/redis.service </span><br><span class="line">内容如下：</span><br><span class="line"></span><br><span class="line">[unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后重载系统服务</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在就可以通过下面的命令来操作redis</span><br><span class="line">启动</span><br><span class="line">systemctl start redis</span><br><span class="line">停止</span><br><span class="line">systemctl stop redis</span><br><span class="line">重启</span><br><span class="line">systemctl restart redis</span><br><span class="line">查看状态</span><br><span class="line">systemctl status redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行下面的命令，可以使redis开机自启</span><br><span class="line">systemctl enable redis</span><br></pre></td></tr></table></figure>





<h4 id="Redis客户端"><a href="#Redis客户端" class="headerlink" title="Redis客户端"></a>Redis客户端</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Redis安装完成后就自带了命令行客户端:redis-cli，使用方式如下:</span><br><span class="line"></span><br><span class="line">redis-cli [options][commonds]</span><br><span class="line"></span><br><span class="line">其中常见的options有:</span><br><span class="line">-h 127.0.0.1:指定要连接的redis节点的IP地址，默认是127.0.0.1</span><br><span class="line"></span><br><span class="line">-p 6379:指定要连接的redis节点的端口，默认是6379</span><br><span class="line"></span><br><span class="line">-a 123321&#125;:指定redis的访问密码</span><br><span class="line"></span><br><span class="line">其中的commonds就是Redis的操作命令，例如:</span><br><span class="line"></span><br><span class="line">ping:与redis服务端做心跳测试，服务端正常会返回pong</span><br><span class="line"></span><br><span class="line">不指定commond时，会进入redis-cli的交互控制台:</span><br></pre></td></tr></table></figure>







<h3 id="Redis数据结构介绍"><a href="#Redis数据结构介绍" class="headerlink" title="Redis数据结构介绍"></a>Redis数据结构介绍</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20241130161918862.png" alt="image-20241130161918862"></p>
<h3 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h3><h4 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h4><ul>
<li><p>KEYS:查看符合模板的所有key，不建议在生产环境设备上使用</p>
</li>
<li><p>DEL:删除一个指定的key</p>
</li>
<li><p>EXISTS:判断key是否存在</p>
</li>
<li><p>EXPIRE:给一个key设置有效期，有效期到期时该key会被自动删除</p>
</li>
<li><p>TTL:查看一个KEY的剩余有效期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果为-1，代表永久存储</span><br><span class="line">结果为-2，代表已过期</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="String类型的常见命令"><a href="#String类型的常见命令" class="headerlink" title="String类型的常见命令"></a>String类型的常见命令</h4><p><strong>Redis中KEY格式为：[项目名]:[业务名]:[类型]:[id]，也可以根据需要定制格式</strong></p>
<ul>
<li><p>SET:添加或者修改已经存在的一个String类型的键值对</p>
</li>
<li><p>GET:根据key获取String类型的value</p>
</li>
<li><p>MSET:批量添加多个String类型的键值对</p>
</li>
<li><p>MGET:根据多个key获取多个String类型的value</p>
</li>
<li><p>INCR:让一个整型的key自增1</p>
</li>
<li><p>INCRBY:让一个整型的key自增并指定步长，例如:incrby num 2让num值自增2</p>
</li>
<li><p>INCRBYFLOAT:让一个浮点类型的数字自增并指定步长</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">必须指定步长</span><br></pre></td></tr></table></figure>


</li>
<li><p>SETNX:添加一个String类型的键值对，前提是这个key不存在，否则不执行</p>
</li>
<li><p>SETEX:添加一个String类型的键值对，并且指定有效期</p>
</li>
</ul>
<h4 id="String类型的三种格式"><a href="#String类型的三种格式" class="headerlink" title="String类型的三种格式"></a>String类型的三种格式</h4><ul>
<li>string:普通字符串</li>
<li>int:整数类型，可以自增自减</li>
<li>float：浮点类型，可以自增自减</li>
</ul>
<p>底层均为字节数组形式存储，编码方式存在差异，且最大空间不能超过512M</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125120908306.png" alt="image-20250125120908306"></p>
<h4 id="Hash类型的常见命令"><a href="#Hash类型的常见命令" class="headerlink" title="Hash类型的常见命令"></a>Hash类型的常见命令</h4><p>value类型为一个无序字典，类似于java中的HashMap结构</p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段进行CRUD</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125124325326.png" alt="image-20250125124325326"></p>
<p><strong>常见命令如下</strong></p>
<ul>
<li>HSET key field value:添加或者修改hash类型key的field的值</li>
<li>HGET key field:获取一个hash类型key的field的值HMSET:批量添加多个hash类型key的field的值</li>
<li>HMGET:批量获取多个hash类型key的field的值</li>
<li>HGETALL:获取一个hash类型的key中的所有的field和value</li>
<li>HKEYS:获取一个hash类型的key中的所有的field</li>
<li>HVALS:获取一个hash类型的key中的所有的value</li>
<li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li>
<li>HSETNX:添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li>
</ul>
<p>、</p>
<h4 id="List类型的常见命令"><a href="#List类型的常见命令" class="headerlink" title="List类型的常见命令"></a>List类型的常见命令</h4><p>与java中的LinkededList类似，可以看作是一个双向链表结构，既可以支持正向检索亦可以支持反向检索。</p>
<p><strong>特征与LinkedList类似</strong></p>
<ul>
<li>有序</li>
<li>元素可重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用于存储一个有序数据，聊天记录之类的</p>
<p><strong>常用命令如下</strong></p>
<ul>
<li>LPUSH key element.:向列表左侧插入一个或多个元素</li>
<li>LPOP key:移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH key element..:向列表右侧插入一个或多个元素</li>
<li>RPOP key:移除并返回列表右侧的第一个元素</li>
<li>LRANGE key starend:返回一段角标范围内的所有元素BLPOP和BRPOP:与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>
</ul>
<h4 id="Set类型的常见命令"><a href="#Set类型的常见命令" class="headerlink" title="Set类型的常见命令"></a>Set类型的常见命令</h4><p>与java中的HashSet类似，可以看作是一个value为null的HashMap，是一个Hash表。</p>
<p><strong>特征：</strong></p>
<ul>
<li>无序</li>
<li>元素不重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<p><strong>常见命令：</strong></p>
<ul>
<li>SADD key member…:向set中添加一个或多个元素</li>
<li>SREM key member…:移除set中的指定元素</li>
<li>SCARD key:返回set中元素的个数</li>
<li>SISMEMBER key member:判断一个元素是否存在于set中</li>
<li>SMEMBERS:获取set中的所有元素</li>
<li>SINTER key1 key2..:求key1与key2的交集</li>
<li>SDIFF key1 key2.:求key1与key2的差集</li>
<li>SUNION key1 key2..:求key1和key2的并集</li>
</ul>
<h4 id="SortedSet类型的常见命令"><a href="#SortedSet类型的常见命令" class="headerlink" title="SortedSet类型的常见命令"></a>SortedSet类型的常见命令</h4><p>一个可排序的set集合，于Java中的TreeSet类似，但与其底层数据结构差别较大，每个元素都有一个score属性，可以基于score来对元素排序</p>
<p>底层由一个跳表(SkipList)加Hash表</p>
<p><strong>特性：</strong></p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>具有可排序特性，可以实现排行榜</p>
<p><strong>常见命令：</strong></p>
<ul>
<li>ZADD key score member:添加一个或多个元素到sorted set，如果已经存在则更新其score值</li>
<li>ZREM key member:删除sorted set中的一个指定元素</li>
<li>ZSCORE key member:获取sorted set中的指定元素的score值</li>
<li>ZRANK key member:获取sorted set 中的指定元素的排名</li>
<li>ZCARD key:获取sortedset中的元素个数</li>
<li>ZCOUNT key min max:统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member:让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max:按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max:按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF、ZINTER、ZUNION:求差集、交集、并集</li>
</ul>
<h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h2><p><strong>Spring Data Redis提供的API既可以以Jedis为底层，也可以使用lettuce为底层</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125145423817.png" alt="image-20250125145423817"></p>
<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>命名方式与redis相同</p>
<h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ul>
<li>引入依赖</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125152306686.png" alt="image-20250125152306686"></p>
<ul>
<li>建立连接</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125152316485.png" alt="image-20250125152316485"></p>
<ul>
<li>测试String</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125152435735.png" alt="image-20250125152435735"></p>
<ul>
<li>释放资源</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125152452024.png" alt="image-20250125152452024"></p>
<h4 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h4><p>本身线程不安全，频繁创建和销毁连接存在性能损耗，故推荐使用Jedis连接池代替Jedis的直连方式</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125161140995.png" alt="image-20250125161140995"></p>
<h3 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h3><p>Spring Data是对Spring中数据操作的模块，包含对各种数据库的集成，对Redis的集成模块即为SpringDataRedis，默认是lettuce</p>
<ul>
<li>提供了对不同Redis客户端的整合(Lettuce和Jedis)</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的IDKCollection实现</li>
</ul>
<h4 id="基于类型的API分组"><a href="#基于类型的API分组" class="headerlink" title="基于类型的API分组"></a>基于类型的API分组</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125171335346.png" alt="image-20250125171335346"></p>
<h4 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h4><ul>
<li>引入依赖</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125171509573.png" alt="image-20250125171509573"></p>
<ul>
<li>配置文件</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125173955147.png" alt="image-20250125173955147"></p>
<ul>
<li>注入RedisTemplate</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125174100486.png" alt="image-20250125174100486"></p>
<ul>
<li>编写测试</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125174124126.png" alt="image-20250125174124126"></p>
<h4 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125182020219.png" alt="image-20250125182020219"></p>
<p><strong>自定义序列化</strong>（基于RedisTemplate）</p>
<ul>
<li>RedisConfig中进行下面的配置</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125182049566.png" alt="image-20250125182049566"></p>
<ul>
<li>注入RedisTemplate&lt;String, Object&gt;类型的操作对象</li>
</ul>
<p><strong>自动反序列化</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125182337408.png" alt="image-20250125182337408"></p>
<p>JSON序列化时自动将类的class类型写入json结果中，存入Redis，便于在反序列化时确认对象的类型，但这样会带来额外的内存开销。</p>
<p><strong>手动序列化及反序列以节省内存空间</strong>（基于StringRedisTemplate）</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125182748418.png" alt="image-20250125182748418"></p>
<p>为节省空间，不使用JSON序列化器来处理value，而是同一使用String序列化器，要求只能存储String类型的key和value，当需要存储Java对象时，手动进行序列化和反序列化（程序员知道操作的类的类型）</p>
<ul>
<li>示例</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250125183016218.png" alt="image-20250125183016218"></p>
<h1 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h1><h2 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h2><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126130612123.png" alt="image-20250126130612123"></p>
<h3 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126144931344.png" alt="image-20250126144931344"></p>
<p>controller+service相关代码</p>
<p>interceptor的设置和其config类的编写</p>
<p>使用session保存用户信息并且通过ThreadLocal保证服务端的线程安全性</p>
<h4 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题"></a>Session共享问题</h4><p>多台tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。</p>
<h4 id="基于Redis实现共享session登录"><a href="#基于Redis实现共享session登录" class="headerlink" title="基于Redis实现共享session登录"></a>基于Redis实现共享session登录</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126155201654.png" alt="image-20250126155201654"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126161818227.png" alt="image-20250126161818227"></p>
<ul>
<li>发送短信验证码</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126162032531.png" alt="image-20250126162032531"></p>
<ul>
<li>config类中添加对StringRedisTemplate的注入，并且将其作为拦截器的内容进行初始化</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126171539066.png" alt="image-20250126171539066"></p>
<ul>
<li>登录拦截（Interceptor中内容）</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126171346713.png" alt="image-20250126171346713"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126171417788.png" alt="image-20250126171417788"></p>
<ul>
<li>短信验证码登录注册</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126171122785.png" alt="image-20250126171122785"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126170905802.png" alt="image-20250126170905802"></p>
<h4 id="登录拦截器的优化"><a href="#登录拦截器的优化" class="headerlink" title="登录拦截器的优化"></a>登录拦截器的优化</h4><p>当前登录拦截器拦截的路径并非用户可以访问的全部路径，如果当前用户一直访问未被拦截的服务，用户的登录状态将不会得到刷新。</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126172716516.png" alt="image-20250126172716516"></p>
<ul>
<li>对部分路径进行用户校验的拦截器</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126172834303.png" alt="image-20250126172834303"></p>
<ul>
<li>处理所有请求路径，刷新用户访问状态的拦截器</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126173049201.png" alt="image-20250126173049201"></p>
<ul>
<li>在config类中配置上述两个拦截器</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126173156330.png" alt="image-20250126173156330"></p>
<h4 id="Redis代替session要考虑的问题"><a href="#Redis代替session要考虑的问题" class="headerlink" title="Redis代替session要考虑的问题"></a>Redis代替session要考虑的问题</h4><ul>
<li>选择合适的数据结构</li>
<li>选择合适的key</li>
<li>选择合适的存储粒度</li>
</ul>
<h3 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h3><p>缓存是数据交换的缓冲区，是存储数据的临时地方，一般读写性能较高。</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126173829407.png" alt="image-20250126173829407"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126174250055.png" alt="image-20250126174250055"></p>
<h4 id="添加缓存代码实现"><a href="#添加缓存代码实现" class="headerlink" title="添加缓存代码实现"></a>添加缓存代码实现</h4><ul>
<li>缓存作用模型及根据id查询商铺缓存的流程</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126174459749.png" alt="image-20250126174459749"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126180437091.png" alt="image-20250126180437091"></p>
<h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126181022686.png" alt="image-20250126181022686"></p>
<h5 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h5><p>从左到右分别为旁路缓存模式，读写穿透模式，异步缓存写入模式</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250126193000005.png" alt="image-20250126193000005"></p>
<ul>
<li><p>Cache Aside是一种常见的缓存模式，也是最简单的一种缓存模式。在Cache Aside模式中，应用程序首先从缓存中读取数据，如果缓存中不存在，则从数据库中读取数据，并将数据写入缓存中。在更新数据时，应用程序首先更新数据库中的数据，然后删除缓存中的数据。当下一次请求到来时，应用程序会从数据库中读取最新的数据，并将其写入缓存中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cache Aside模式的优点是简单易用，缓存和数据库之间的数据一致性较好。但是，由于应用程序需要手动维护缓存和数据库之间的数据一致性，因此在高并发场景下，容易出现缓存和数据库之间的数据不一致的情况。</span><br><span class="line"></span><br><span class="line">适用于读多写少的场景，数据一致性要求不高的场景。</span><br></pre></td></tr></table></figure>

<ul>
<li>删除缓存还是更新换存：若选择更新缓存，每次更新数据库都更新缓存，无效写操作较多；若选择删除缓存，更新数据库时让缓存失效，查询时再更新缓存</li>
<li>如何保证缓存与数据库操作同时成功或失败：若在单体系统中，则将缓存与数据库操作放在一个事务中；若为分布式系统，利用TCC等分布式事务方案</li>
<li>先操作缓存还是先操作数据库：</li>
</ul>
</li>
<li><p>Read&#x2F;Write Through是一种将缓存和数据库完全解耦的缓存模式。在Read&#x2F;Write Through模式中，应用程序不直接访问缓存和数据库，而是通过一个中间层来访问缓存和数据库。当应用程序需要读取数据时，中间层首先从缓存中读取数据，如果缓存中不存在，则从数据库中读取数据，并将数据写入缓存中。当应用程序需要更新数据时，中间层会将更新操作发送到数据库中，并更新缓存中的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Read/Write Through模式的优点是完全解耦缓存和数据库，可以有效地提高系统的并发能力和可扩展性。但是，由于中间层需要处理缓存和数据库之间的数据一致性，因此实现起来较为复杂。</span><br><span class="line"></span><br><span class="line">适用于读多写多的场景，数据一致性要求较高的场景。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Write Behind Caching是一种将缓存和数据库异步写入的缓存模式。在Write Behind Caching模式中，应用程序首先将更新操作写入缓存中，然后异步地将更新操作写入数据库中。当下一次请求到来时，应用程序会从缓存中读取数据，并将其写入数据库中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Write Behind Caching模式的优点是可以有效地提高系统的写入性能，减少数据库的压力。但是，由于缓存和数据库之间存在一定的时间差，因此在数据一致性方面需要进行一定的权衡。</span><br><span class="line"></span><br><span class="line">适用于写多读少的场景，数据一致性要求不高的场景。</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="缓存更新策略的最佳实践"><a href="#缓存更新策略的最佳实践" class="headerlink" title="缓存更新策略的最佳实践"></a>缓存更新策略的最佳实践</h5><ul>
<li>低一致性需求：Redis自带的内存淘汰机制</li>
<li>高一致性需求：主动更新，以超时删除作为兜底方案<ul>
<li>读操作：缓存命中直接返回；未命中查询数据库并写入缓存，设定超时实践</li>
<li>写操作：先写数据库，删除缓存，确保两个操作的原子性</li>
</ul>
</li>
</ul>
<h4 id="实现商铺信息缓存与数据库的一致性"><a href="#实现商铺信息缓存与数据库的一致性" class="headerlink" title="实现商铺信息缓存与数据库的一致性"></a>实现商铺信息缓存与数据库的一致性</h4><ul>
<li>查询部分</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127103608561.png" alt="image-20250127103608561"></p>
<ul>
<li>更新部分</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127103755096.png" alt="image-20250127103755096"></p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，请求都会打到数据库</p>
<ul>
<li><p>缓存空对象</p>
<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：额外的内存消耗，可能造成短期的不一致</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127105050028.png" alt="image-20250127105050028"></p>
</li>
<li><p>布隆过滤</p>
<ul>
<li>优点：内存占用很少，没有多余key</li>
<li>缺点：实现复杂，存在误判可能</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127105105516.png" alt="image-20250127105105516"></p>
</li>
</ul>
<h4 id="商铺缓存穿透代码实现"><a href="#商铺缓存穿透代码实现" class="headerlink" title="商铺缓存穿透代码实现"></a>商铺缓存穿透代码实现</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127110158113.png" alt="image-20250127110158113"></p>
<ul>
<li>查询部分</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127105705060.png" alt="image-20250127105705060"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127110047124.png" alt="image-20250127110047124"></p>
<h4 id="缓存穿透的解决方案"><a href="#缓存穿透的解决方案" class="headerlink" title="缓存穿透的解决方案"></a>缓存穿透的解决方案</h4><ul>
<li>被动<ul>
<li>缓存null值</li>
<li>布隆过滤</li>
</ul>
</li>
<li>主动<ul>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
</li>
</ul>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</p>
<p><strong>解决方案</strong></p>
<ul>
<li>给不同的key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h4 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a>缓存击穿问题</h4><p>也称热点key问题，即一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击</p>
<p><strong>解决方案</strong></p>
<ul>
<li><p>互斥锁</p>
<ul>
<li>优点：无额外内存消耗，一致性能得到保证，实现简单</li>
<li>缺点：线程需要等待，性能受限，可能有死锁风险</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127113726578.png" alt="image-20250127113726578"></p>
</li>
<li><p>逻辑过期</p>
<ul>
<li>优点：线程无需等待，性能较好</li>
<li>缺点：不保证一致性，有额外内存消耗，实现复杂</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127113739208.png" alt="image-20250127113739208"></p>
</li>
</ul>
<h4 id="基于互斥锁解决缓存击穿问题"><a href="#基于互斥锁解决缓存击穿问题" class="headerlink" title="基于互斥锁解决缓存击穿问题"></a>基于互斥锁解决缓存击穿问题</h4><p>修改查询商铺的业务，采用逻辑过期</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127121710166.png" alt="image-20250127121710166"></p>
<ul>
<li>RedisData类</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127123149153.png" alt="image-20250127123149153"></p>
<ul>
<li>通过逻辑过期来进行查询</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127124242506.png" alt="image-20250127124242506"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127124131307.png" alt="image-20250127124131307"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127124449609.png" alt="image-20250127124449609"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127124414988.png" alt="image-20250127124414988"></p>
<h4 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a>缓存工具封装</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127125419434.png" alt="image-20250127125419434"></p>
<ul>
<li>任意Java对象序列化为json并存储为String类型的key，并且设置TTL过期时间</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127125440703.png" alt="image-20250127125440703"></p>
<ul>
<li>任意Java对象序列化为json并存储为String类型的key，并且设置逻辑过期时间，用于处理缓存击穿问题</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127125508885.png" alt="image-20250127125508885"></p>
<ul>
<li>根据指定key查询缓存，并反序列化为指定类型，利用缓存控制的方式解决缓存穿透问题</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127150759213.png" alt="image-20250127150759213"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127151017617.png" alt="image-20250127151017617"></p>
<ul>
<li>根据指定key查询缓存，并序列化为指定类型，使用逻辑过期解决缓存击穿问题</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127151131050.png" alt="image-20250127151131050"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127151214597.png" alt="image-20250127151214597"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127151346685.png" alt="image-20250127151346685"></p>
<h3 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h3><h4 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h4><p>订单表中使用数据库自增ID存在的问题</p>
<ul>
<li>id规律性太明显</li>
<li>受表单数据量的限制</li>
</ul>
<p>生成策略</p>
<h5 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a>全局ID生成器</h5><ul>
<li>需要满足的特性</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127154143896.png" alt="image-20250127154143896"></p>
<ul>
<li>格式如下</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127154117703.png" alt="image-20250127154117703"></p>
<ul>
<li>代码实现</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127154937575.png" alt="image-20250127154937575"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127154828283.png" alt="image-20250127154828283"></p>
<h4 id="实现优惠券秒杀下单"><a href="#实现优惠券秒杀下单" class="headerlink" title="实现优惠券秒杀下单"></a>实现优惠券秒杀下单</h4><ul>
<li>controller中接口</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127163722067.png" alt="image-20250127163722067"></p>
<ul>
<li>业务流程<ul>
<li>秒杀是否开始或者结束，如果尚未开始货已经结束则无法下单</li>
<li>库存是否充足，不足就无法下单</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127165159604.png" alt="image-20250127165159604"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方案上添加@Transactional</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127165642901.png" alt="image-20250127165642901"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127165626431.png" alt="image-20250127165626431"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127165546637.png" alt="image-20250127165546637"></p>
<h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h4><p>典型的多线程安全问题，常见解决方案就是加锁</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127175850712.png" alt="image-20250127175850712"></p>
<ul>
<li><p>悲观锁：添加同步锁，让线程串行执行</p>
<ul>
<li>优点：简单</li>
<li>缺点：性能较差</li>
</ul>
</li>
<li><p>乐观锁：不加锁，在更新时判断是否有其它线程在修改</p>
<ul>
<li><p>优点：性能好</p>
</li>
<li><p>缺点：存在成功率低的问题</p>
</li>
<li><p>关键在于判断之前查询到的数据是否有被修改过</p>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127180500571.png" alt="image-20250127180500571"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127180744256.png" alt="image-20250127180744256"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compare and swap</span><br><span class="line">无锁方案</span><br></pre></td></tr></table></figure>





<h4 id="一人一单修改代码实现"><a href="#一人一单修改代码实现" class="headerlink" title="一人一单修改代码实现"></a>一人一单修改代码实现</h4><p>新增操作，无法采用乐观锁，只能使用悲观锁</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127182528727.png" alt="image-20250127182528727"></p>
<ul>
<li>pom文件中引入依赖</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127183545026.png" alt="image-20250127183545026"></p>
<ul>
<li>启动类上添加暴露代理的注解</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250127183614509.png" alt="image-20250127183614509"></p>
<ul>
<li>改造下单方法</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250128011105514.png" alt="image-20250128011105514"></p>
<ul>
<li>createVoucherOrder方法：方法上加Transcational注解</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250128012220591.png" alt="image-20250128012220591"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250128012136248.png" alt="image-20250128012136248"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250128012155841.png" alt="image-20250128012155841"></p>
<h4 id="集群下的线程安全问题"><a href="#集群下的线程安全问题" class="headerlink" title="集群下的线程安全问题"></a>集群下的线程安全问题</h4><ul>
<li>单体项目本地模拟集群的相关操作：使得全部用户请求在两个节点上负载均衡</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250128132837676.png" alt="image-20250128132837676"></p>
<ul>
<li>原理分析：核心是不同JVM下不同锁监视器不共享加锁信息导致集群下的锁失效</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250128134750163.png" alt="image-20250128134750163"></p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>满足分布式系统或集群模式下多进程可见并且互斥的锁</p>
<ul>
<li>常用解决方案对比</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129104437670.png" alt="image-20250129104437670"></p>
<h4 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h4><ul>
<li><p>实现分布式锁的两个基本方法</p>
<ul>
<li>获取锁<ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回true, 失败返回false</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//添加锁：NX为互斥，EX为设置超时时间</span><br><span class="line">SET lock thread1 NX EX 10</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//释放锁，删除即可</span><br><span class="line">DEL key</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129105337231.png" alt="image-20250129105337231"></p>
<ul>
<li><p>初步实现</p>
<ul>
<li>对下面的结果添加实现</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129105405666.png" alt="image-20250129105405666"></p>
<ul>
<li>实现</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129105843702.png" alt="image-20250129105843702"></p>
<ul>
<li>对下单业务方法中sychronized方法的改进</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129110350846.png" alt="image-20250129110350846"></p>
<ul>
<li>解决锁误删问题：在锁上存入线程标识，并且在删除出锁前判断锁标识</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129111608235.png" alt="image-20250129111608235"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129111700928.png" alt="image-20250129111700928"></p>
</li>
<li><p>如果不能保证对锁标识的判断与删除锁两个操作的原子性，同样可能出现锁误删的情况</p>
<ul>
<li>redis中的批处理方法无法返回标识判断的结果，无法通过这个结果进行判断是否可以删除锁，所以不适用</li>
<li>乐观锁等方式也能实现，但是较为复杂</li>
<li>redis中提供lua脚本，在一个脚本中编写多条redis命令并且保证命令执行时的原子性</li>
</ul>
</li>
<li><p>lua脚本的使用方式</p>
<ul>
<li>redis提供的调用函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//执行redis命令</span><br><span class="line">redis.call(&#x27;命令名称&#x27;, &#x27;key&#x27;, &#x27;其它参数&#x27;, ...);</span><br></pre></td></tr></table></figure>



<ul>
<li>调用脚本的redis命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用lua脚本改造释放锁的业务流程</p>
<ul>
<li>lua脚本编写<ul>
<li>置于项目resources文件下</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129153415407.png" alt="image-20250129153415407"></p>
<ul>
<li>RedisTemplate调用lua脚本的API如下</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129153550265.png" alt="image-20250129153550265"></p>
<ul>
<li>lua脚本声明及初始化</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129153839320.png" alt="image-20250129153839320"></p>
<ul>
<li>unlock方法改造</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129153931812.png" alt="image-20250129153931812"></p>
</li>
<li><p>特性</p>
<ul>
<li>利用set nx满足互斥性</li>
<li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
</li>
</ul>
<h4 id="基于Redis的分布式锁优化"><a href="#基于Redis的分布式锁优化" class="headerlink" title="基于Redis的分布式锁优化"></a>基于Redis的分布式锁优化</h4><ul>
<li><p>基于setnx实现的分布式锁存在的问题</p>
<ul>
<li>不可重入：同一个线程无法多次获取同一把锁</li>
<li>不可重试：获取锁只尝试一次就返回false，没有重试机制</li>
<li>超时释放：锁超时释放可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患</li>
<li>主从一致性：在主从集群下主从同步存在延迟，且当主宕机时，从并未同步主中的锁数据，可能会导致锁失效</li>
</ul>
</li>
<li><p>Redisson介绍</p>
<ul>
<li>一个在Redis基础上实现的Java驻内存数据网格，不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。</li>
<li>实现的不同种类的分布式锁</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129171540825.png" alt="image-20250129171540825"></p>
</li>
<li><p>Redisson入门</p>
<ul>
<li>引入依赖</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129171631752.png" alt="image-20250129171631752"></p>
<ul>
<li>配置Redisson客户端<ul>
<li>可以通过下面这种Java代码配置的方式，也可以用配置文件进行配置，或者是添加redis的springboot-starter，但一般不推荐这样做。</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129171704997.png" alt="image-20250129171704997"></p>
<ul>
<li>使用Redisson的分布式锁</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129172454950.png" alt="image-20250129172454950"></p>
<ul>
<li>修改下单方法中的代码片段</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129173109657.png" alt="image-20250129173109657"></p>
</li>
</ul>
<h4 id="Redisson多种分布式锁原理"><a href="#Redisson多种分布式锁原理" class="headerlink" title="Redisson多种分布式锁原理"></a>Redisson多种分布式锁原理</h4><p><strong>三种分布式锁</strong></p>
<ul>
<li>不可重入Redis分布式锁<ul>
<li>原理：利用setnx的互斥性，利用ex避免死锁，释放锁时判断线程标识</li>
<li>缺陷：不可重入，无法重试，锁超时失效</li>
</ul>
</li>
<li>可重入的Redis分布式锁<ul>
<li>原理：利用hash结构，记录线程标识和重入次数，利用watchdog延续锁时间，利用信号量控制锁重试等待</li>
<li>缺陷：Redis宕机引起锁失效问题</li>
</ul>
</li>
<li>Redisson的multilock<ul>
<li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li>
<li>缺陷：运维成本高，实现复杂</li>
</ul>
</li>
</ul>
<p><strong>解决方式：</strong></p>
<ul>
<li>可重入：利用hash结构记录线程id和重入次数</li>
<li>可重试：利用信号量和发布订阅机制实现等待、唤醒、获取锁失败的重试机制</li>
<li>超时续约：利用watchdog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间</li>
</ul>
<p><strong>具体原理：</strong></p>
<ul>
<li>锁工作流程</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129174407127.png" alt="image-20250129174407127"></p>
<ul>
<li>获取锁的lua脚本</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129174644431.png" alt="image-20250129174644431"></p>
<ul>
<li>释放锁的lua脚本</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129174851510.png" alt="image-20250129174851510"></p>
<ul>
<li>锁重试和WatchDog机制</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250129204106923.png" alt="image-20250129204106923"></p>
<h4 id="Redis优化秒杀"><a href="#Redis优化秒杀" class="headerlink" title="Redis优化秒杀"></a>Redis优化秒杀</h4><p><strong>优化思路</strong></p>
<ul>
<li>先用Redis完成库存余量，一人一单判断，完成抢单业务</li>
<li>将下单业务放入阻塞队列，利用独立线程异步下单</li>
</ul>
<p><strong>代码实现</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130102841498.png" alt="image-20250130102841498"></p>
<ul>
<li>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130103746534.png" alt="image-20250130103746534"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130103812213.png" alt="image-20250130103812213"></p>
<ul>
<li>编写Lua脚本，判断秒杀库存，一人一单，决定用户是否抢购成功</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130104608379.png" alt="image-20250130104608379"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130104641335.png" alt="image-20250130104641335"></p>
<ul>
<li>抢购成功后，将优惠券id与用户id封装后存入阻塞队列，改进seckillVoucher方法</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130105117255.png" alt="image-20250130105117255"></p>
<ul>
<li>开启线程任务，不断从阻塞队列中获取信息，进行异步下单：阻塞队列中等待请求到来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：在子线程handleVoucherOrder中是无法取到代理的，只有在父线程中添加获取代理的代码，并且将代理对象设置为类的成员对象才能供子线程调用</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130114657049.png" alt="image-20250130114657049"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130115347340.png" alt="image-20250130115347340"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130115811809.png" alt="image-20250130115811809"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130121442224.png" alt="image-20250130121442224"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130121539469.png" alt="image-20250130121539469"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130141603746.png" alt="image-20250130141603746"></p>
<p><strong>存在的问题</strong></p>
<ul>
<li><p>内存限制问题：阻塞队列使用的是JVM中的内存空间</p>
</li>
<li><p>数据安全问题：JVM内存不具有持久化机制。服务重启或出现宕机时，阻塞队列中所有的订单任务都会丢失</p>
</li>
</ul>
<h4 id="Redis消息队列实现异步秒杀"><a href="#Redis消息队列实现异步秒杀" class="headerlink" title="Redis消息队列实现异步秒杀"></a>Redis消息队列实现异步秒杀</h4><p><strong>消息队列：即存放信息的队列</strong></p>
<p>（Message Queue）</p>
<p><strong>消息队列模型的角色</strong></p>
<ul>
<li>消息队列：存储和管理信息，也称消息代理（Message Broker）</li>
<li>生存者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p><strong>Redis中三种不同的实现消息队列方式</strong></p>
<ul>
<li><p>List结构：基于List结构模拟消息队列</p>
<ul>
<li>一个双向链表，可以模拟出队列效果</li>
<li>LPUSH, LPOP, RPUSH, RPOP均是非阻塞的方法，所以要使用BRPOP或者BLPOP来实现阻塞效果</li>
<li>优点<ul>
<li>利用Redis存储，不受JVM内存限制</li>
<li>基于Redis的持久化机制，可以保证数据安全性</li>
<li>可以满足信息有序性</li>
</ul>
</li>
<li>缺点<ul>
<li>无法避免消息丢失，获取信息是get and pop形式，如果没有即时的获取信息，就无法使用信息</li>
<li>只支持单消费者</li>
</ul>
</li>
</ul>
</li>
<li><p>PubSub：基本的点对点消息模型</p>
<ul>
<li>常用方法<ul>
<li>SUBSCRIBE channel [channel]：订阅一个或多个频道</li>
<li>PUBLISH channel msg：向一个频道发送信息</li>
<li>PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道</li>
</ul>
</li>
<li>优点<ul>
<li>采用发布订阅模型，支持多生产多消费</li>
</ul>
</li>
<li>缺点<ul>
<li>不支持数据持久化，数据不会存储在redis中</li>
<li>无法避免消息丢失</li>
<li>消息堆积上限由客户端缓存大小决定，超出时会出现数据丢失</li>
</ul>
</li>
</ul>
</li>
<li><p>Stream：比较完善的消息队列模型</p>
<ul>
<li><p>常用方法</p>
<ul>
<li>XADD</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130180350577.png" alt="image-20250130180350577"></p>
<ul>
<li>XREAD</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130180534696.png" alt="image-20250130180534696"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：如果设置阻塞时间为0，则阻塞将一直保持等待</span><br><span class="line"></span><br><span class="line">当指示起始ID为$时，代表读取最新的消息，如果我们处理一条信息的过程中，又有超过1条以上的消息到达队列，则下次获取时只能获取到最新的一条，会出现漏读消息的问题</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点</p>
<ul>
<li>消息可回溯，消息会保存在redis中</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130194036603.png" alt="image-20250130194036603"></p>
<p><strong>消费者组：把多个消费者划分到一个组中，监听同一个队列</strong></p>
<p><strong>特点</strong></p>
<ul>
<li>消息分流：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度</li>
<li>消息标识：消费者组会维护一个标识，记录最后一个被处理的消息，即使消费者宕机重启，也会从标示之后读取信息，确保每个信息都被消费</li>
<li>消息确认：消费者获取信息后，将消息置于PENDING状态，并且存入pending-list中。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list移除，每个消费者都有自己独立的pending-list</li>
</ul>
<p><strong>常用方法</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130185048404.png" alt="image-20250130185048404"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130185102526.png" alt="image-20250130185102526"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130190407651.png" alt="image-20250130190407651"></p>
<p><strong>代码实现</strong></p>
<ul>
<li>消费者监听消息</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130193349789.png" alt="image-20250130193349789"></p>
<p><strong>XREADGROUP命令特点</strong></p>
<ul>
<li>消息可回溯</li>
<li>可以多消费者争抢信息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<h4 id="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h4><p>代码实现</p>
<ul>
<li>创建一个Stream类型的消息队列，为stream.orders</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130195013817.png" alt="image-20250130195013817"></p>
<ul>
<li>修改秒杀下单Lua脚本，若判定有抢购资格，直接向stream.orders中添加信息，内容包含voucherId、userId、orderId</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130195104666.png" alt="image-20250130195104666"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130195214962.png" alt="image-20250130195214962"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130195345300.png" alt="image-20250130195345300"></p>
<ul>
<li>项目开启时，开启一个线程任务，尝试获取stream.orders中的信息，完成下单</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130204259728.png" alt="image-20250130204259728"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130204529152.png" alt="image-20250130204529152"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130205111501.png" alt="image-20250130205111501"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130205304540.png" alt="image-20250130205304540"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130205324459.png" alt="image-20250130205324459"></p>
<h3 id="附近的商户"><a href="#附近的商户" class="headerlink" title="附近的商户"></a>附近的商户</h3><h4 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h4><p><strong>Geolocation，代表地理坐标</strong></p>
<p>Redis3.2版本中加入对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据</p>
<p><strong>一些常见命令</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207114633671.png" alt="image-20250207114633671"></p>
<h4 id="附近商户搜索"><a href="#附近商户搜索" class="headerlink" title="附近商户搜索"></a>附近商户搜索</h4><p>按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207115203091.png" alt="image-20250207115203091"></p>
<ul>
<li>上传店铺位置信息</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207115718667.png" alt="image-20250207115718667"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207115742087.png" alt="image-20250207115742087"></p>
<ul>
<li>修改POM文件，因为SpringDataRedis的2.3.9版本不支持Redis6.2提供的GEOSERACH命令，因此我们需要提示其版本</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207121117299.png" alt="image-20250207121117299"></p>
<ul>
<li>分页查询同类型的店铺信息</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207130406442.png" alt="image-20250207130406442"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207130302466.png" alt="image-20250207130302466"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207130328016.png" alt="image-20250207130328016"></p>
<h3 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h3><h4 id="HypeLogLog用法"><a href="#HypeLogLog用法" class="headerlink" title="HypeLogLog用法"></a>HypeLogLog用法</h4><p><strong>UV</strong></p>
<ul>
<li>全称Unique Vistor</li>
<li>也称独立访客量，指通过互联网访问、浏览这个网页的自然人</li>
<li>1天内同一个用户多次访问该网站，只记录1次</li>
</ul>
<p><strong>PV</strong></p>
<ul>
<li>全称Page View</li>
<li>也叫页面访问量或点击量，用来衡量网站的流量</li>
<li>用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV</li>
</ul>
<p>UV统计在服务端做比较麻烦，需要判断用户是否已经统计过了，需要将统计过的用户信息保存，但若每个访问的用户都保存入Redis中，数据量将非常大</p>
<p><strong>HypeLogLog</strong> </p>
<ul>
<li><p>HLL，是LogLog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值</p>
</li>
<li><p>HLL是基于String结构实现的，单个HLL内存永远小于16KB，内存占用极低</p>
</li>
<li><p>测量结果是概率性的，有小于0.81%的误差，但对于UV统计完全可以忽略</p>
</li>
<li><p>常用命令</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207144917440.png" alt="image-20250207144917440"></p>
</li>
</ul>
<h4 id="实现UV统计"><a href="#实现UV统计" class="headerlink" title="实现UV统计"></a>实现UV统计</h4><p>一个简单的demo代码，实际运用也就是调用上面的3个API</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207145630737.png" alt="image-20250207145630737"></p>
<h3 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h3><p>Redis中利用String类型数据结构实现BitMap，最大上限是512M，转换为bit则是2^32个bit位</p>
<p><strong>BitMap的操作命令</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207131403510.png" alt="image-20250207131403510"></p>
<p><strong>代码实现</strong></p>
<ul>
<li>签到接口</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207135114984.png" alt="image-20250207135114984"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207140333050.png" alt="image-20250207140333050"></p>
<ul>
<li><p>签到统计</p>
<ul>
<li>统计连续签到天数</li>
<li>得到本月到今天位置的所有签到数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITDIELD key GET u[dayOfMonth] 0</span><br></pre></td></tr></table></figure>

<ul>
<li>从后向前遍历每个bit位</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">与1做与运算，得到最后一个bit位</span><br><span class="line">随后右移1位，下一个bit位成为了最后一个bit位</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207142926476.png" alt="image-20250207142926476"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207142858917.png" alt="image-20250207142858917"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207142807484.png" alt="image-20250207142807484"></p>
<h3 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207031329923.png" alt="image-20250207031329923"></p>
<h4 id="关注和取关"><a href="#关注和取关" class="headerlink" title="关注和取关"></a>关注和取关</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207031317245.png" alt="image-20250207031317245"></p>
<p><strong>代码实现</strong></p>
<ul>
<li>controller</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207031731542.png" alt="image-20250207031731542"></p>
<ul>
<li>关注或取关</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207031824657.png" alt="image-20250207031824657"></p>
<ul>
<li>判断是否关注</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207031915685.png" alt="image-20250207031915685"></p>
<h4 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207040008170.png" alt="image-20250207040008170"></p>
<p>核心是利用set之间取交集</p>
<p><strong>代码实现</strong></p>
<ul>
<li>在关注和取关处增加Redis相关代码</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207035817384.png" alt="image-20250207035817384"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207035837177.png" alt="image-20250207035837177"></p>
<ul>
<li>controller</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207040049913.png" alt="image-20250207040049913"></p>
<ul>
<li>业务方法实现</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207041815591.png" alt="image-20250207041815591"></p>
<h4 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h4><p>也称为Feed流，为用户持续地提供”沉浸式“的体验，通过无限下拉刷新获取新的信息</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207102335286.png" alt="image-20250207102335286"></p>
<p><strong>Feed流产品的两种常见模式</strong></p>
<ul>
<li>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注，例如朋友圈<ul>
<li>优点：信息全面，不会有缺失，而且实现也相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>
</ul>
</li>
<li>智能排序：利用智能算法屏蔽掉违规的、用户不敢兴趣的内容。推送用户感兴趣信息来吸引用户<ul>
<li>优点：投喂用户感兴趣信息，用户黏度高，易沉迷</li>
<li>缺点：若算法不精准，可能反作用</li>
</ul>
</li>
</ul>
<p><strong>Timeline的实现方案</strong></p>
<ul>
<li>拉模式：也叫读扩散<ul>
<li>缺点：每次读取都要重新拉取所有信息，延迟较高</li>
</ul>
</li>
</ul>
<p><code>发信息时附带时间戳，关注者拉取所有关注对象的信息，按时间戳排序</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207103148252.png" alt="image-20250207103148252"></p>
<ul>
<li>推模式：也叫写扩散<ul>
<li>缺点：尽管这种方案延迟较低，但是若关注对象粉丝量非常大，写扩散需要的成本也很大</li>
</ul>
</li>
</ul>
<p><code>关注对象发送信息时，为每个粉丝拷贝一份</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207103450811.png" alt="image-20250207103450811"></p>
<ul>
<li>推拉结合：也叫读写混合，兼具前两种模式的优点</li>
</ul>
<p><code>后台将关注对象分为粉丝量多和少两种情况，对于后者直接采用推模式，对于前者，将粉丝群体分为活跃粉丝和普通粉丝两种，对于前者采用推模式，对于后者采用拉模式</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207104322725.png" alt="image-20250207104322725"></p>
<p><strong>实现方案的比较</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207104510434.png" alt="image-20250207104510434"></p>
<p><strong>Feed流中的分页模式</strong></p>
<p>Feed流中的数据会不断更新，数据的角标也在变化，因此不能采用传统的分页模式</p>
<p><strong>要采用滚动分页模式</strong>，查询不依赖角标</p>
<p>在list中查询数据只能根据角标或者首尾，所以不能使用list</p>
<p>而应该使用SortedList</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207105355961.png" alt="image-20250207105355961"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207111826127.png" alt="image-20250207111826127"></p>
<p>本例中个人页面采用Timeline模式，基于关注的好友做Feed流，基于推模式实现关注推送功能</p>
<ul>
<li>推送</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207105831691.png" alt="image-20250207105831691"></p>
<ul>
<li>推送页面的分页查询</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207112741253.png" alt="image-20250207112741253"><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207114305530.png" alt="image-20250207114305530"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207114234467.png" alt="image-20250207114234467"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207114348161.png" alt="image-20250207114348161"></p>
<h3 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250130205614390.png" alt="image-20250130205614390"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206231516123.png" alt="image-20250206231516123"></p>
<h4 id="发布探店笔记"><a href="#发布探店笔记" class="headerlink" title="发布探店笔记"></a>发布探店笔记</h4><p>两个接口</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206231617001.png" alt="image-20250206231617001"></p>
<ul>
<li>上传照片</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206232112336.png" alt="image-20250206232112336"></p>
<ul>
<li>发布探店笔记</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206232140695.png" alt="image-20250206232140695"></p>
<h4 id="查看探店笔记"><a href="#查看探店笔记" class="headerlink" title="查看探店笔记"></a>查看探店笔记</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206232322663.png" alt="image-20250206232322663"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206232538456.png" alt="image-20250206232538456"></p>
<h4 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206233230625.png" alt="image-20250206233230625"></p>
<p>完善点赞功能使得一个用户只能点赞一次，再次点击取消点赞</p>
<ul>
<li>Blog类中添加isLike字段</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206233503084.png" alt="image-20250206233503084"></p>
<ul>
<li>修改点赞功能，使用Redis的set集合判断是否点赞过，进一步完善功能</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207002049923.png" alt="image-20250207002049923"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207002108944.png" alt="image-20250207002108944"></p>
<p><code>将用户从Redis的set集合移除时要拷贝if(isSuccess)的判断数据更新成功才更新redis</code></p>
<ul>
<li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，复制给isLike字段</li>
<li>修改分页查询Blog业务，判断当前用户是否点赞过，赋值给isLike字段</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207004748939.png" alt="image-20250207004748939"></p>
<h4 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a>点赞排行榜</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207005347803.png" alt="image-20250207005347803"></p>
<p><strong>Redis数据结构选择</strong></p>
<ul>
<li>选择sortedset，可以将时间戳作为score值进行排序</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207010914919.png" alt="image-20250207010914919"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207011837557.png" alt="image-20250207011837557"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207011909613.png" alt="image-20250207011909613"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207011938932.png" alt="image-20250207011938932"></p>
<p><code>如果member不存在，score会返回nil</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207012711619.png" alt="image-20250207012711619"></p>
<p><code>这里要注意不能用in来获取前五个id,否则显示顺序将以id大小为排序标准</code></p>
<h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="单点Redis的问题"><a href="#单点Redis的问题" class="headerlink" title="单点Redis的问题"></a>单点Redis的问题</h3><ul>
<li>数据丢失<ul>
<li>Redis是内存存储，服务重启可能会丢失数据</li>
<li>解决：实现Redis数据持久化</li>
</ul>
</li>
<li>并发能力<ul>
<li>单点Redis并发能力不能满足巨大吞吐量的高并发场景</li>
<li>解决：搭建主从集群，实现读写分离</li>
</ul>
</li>
<li>故障恢复<ul>
<li>单点Redis宕机，服务即不可用，需要一种自动的故障恢复手段</li>
<li>解决：利用Redis哨兵，实现健康检测和自动恢复</li>
</ul>
</li>
<li>存储能力<ul>
<li>Redis基于内存，单点能存储的数据量不能满足海量数据需求</li>
<li>解决：搭建分片集群，利用插槽机制实现动态扩容</li>
</ul>
</li>
</ul>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><p>Redis Database Backup file（Redis数据备份文件或Redis数据快照）</p>
<p>将内存中所有数据记录到磁盘中，当Redis示例故障重启后，从磁盘读取快照，恢复数据</p>
<p>快照文件称为RDB文件，默认保存在当前运行目录</p>
<p>Redis宕机时会自动进行一次RDB</p>
<p><strong>常见命令</strong></p>
<ul>
<li>save<ul>
<li>由Redis主进程执行RDB，会阻塞所有命令</li>
</ul>
</li>
<li>bgsave<ul>
<li>执行fork操作开启子进程执行RDB，避免主进程受到影响，只会在fork阶段出现阻塞</li>
</ul>
</li>
</ul>
<p><strong>Redis配置文件</strong></p>
<ul>
<li>Redis内部RDB的机制</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201081547877.png" alt="image-20250201081547877"></p>
<ul>
<li>RDB的其它配置</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201081617715.png" alt="image-20250201081617715"></p>
<p><strong>bgsave原理</strong></p>
<p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后bgsave命令返回”Backgroud saving started“信息不再阻塞主进程，读取内存数据并写入RDB文件，原子替换原RDB文件，进程发送信号给主进程表示完成，主进程更新统计信息</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201082815596.png" alt="image-20250201082815596"></p>
<p><strong>RDB的缺点</strong></p>
<ul>
<li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li>
<li>fork子进程、压缩、写出RDB文件都比较耗时</li>
<li>RDB文件适用特定二进制格式保存，Redis版本演进过程中有多个RDB版本，存在兼容性风险</li>
</ul>
<p><strong>RDB的优点</strong></p>
<ul>
<li>是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照，非常适用于备份，全量复制。</li>
</ul>
<h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><p>Append Only File（追加文件）</p>
<p>Redis处理的每一个写命令都会记录在AOF文件，可看作是命令日志文件，AOF会先将所有的写入命令追加到aof_buf中，然后AOF缓冲区根据对应的策略向磁盘进行同步</p>
<p><strong>为什么需要aof_buf这个缓冲区</strong></p>
<p>Redis使用单线程响应命令，若每次写AOF都直接同步硬盘。性能从内存读写变成IO读写，必然下降，先写入缓冲区可以有效减少IO次数</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201083347313.png" alt="image-20250201083347313"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：$3代表下面写入的命令的字符数</span><br></pre></td></tr></table></figure>



<p>AOF默认关闭，需要修改redis.conf配置文件来开启AOF</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201083445229.png" alt="image-20250201083445229"></p>
<p>AOF的命令记录的频率也可以通过redis.conf进行配置</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201083716738.png" alt="image-20250201083716738"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写的频率越小效率越高，但是可靠性和安全性也会降低，no模式下还不如使用RDB方式</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201083852075.png" alt="image-20250201083852075"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206193757025.png" alt="image-20250206193757025"></p>
<p><strong>系统调用write和fsync</strong></p>
<ul>
<li>write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用来提供硬盘IO性能，write操作在写入系统缓冲区后立即返回。同步硬盘操作依赖于系统调度机制。</li>
<li>fsync是针对单个文件操作，做强制硬盘同步，fsync将阻塞直到数据写入硬盘</li>
</ul>
<p>因为是记录命令，AOF文件会比RDB文件大的多，且AOF会记录对同一个key的多次写操作，但只有最后一次写才有意义</p>
<p><strong>bgrewriteaof命令</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206195016022.png" alt="image-20250206195016022"></p>
<p>可以让AOF文件执行重写功能，用最少的命令达到相同效果，是在后台异步执行的命令</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201084525798.png" alt="image-20250201084525798"></p>
<p>Redis在触发阈值时自动重写AOF文件，阈值可以在redis.conf中配置</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201085440599.png" alt="image-20250201085440599"></p>
<h4 id="RDB和AOF比较"><a href="#RDB和AOF比较" class="headerlink" title="RDB和AOF比较"></a>RDB和AOF比较</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201090312015.png" alt="image-20250201090312015"></p>
<h3 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201092231292.png" alt="image-20250201092231292"></p>
<h4 id="搭建主从架构"><a href="#搭建主从架构" class="headerlink" title="搭建主从架构"></a>搭建主从架构</h4><p>在同一台虚拟机中开启3个Redis实例，模拟主从集群</p>
<ul>
<li>创建三个文件夹</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201092756204.png" alt="image-20250201092756204"></p>
<ul>
<li>恢复原始配置，修改conf文件，将持久化模式改为默认的RDB模式，AOF保持关闭状态</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201092910723.png" alt="image-20250201092910723"></p>
<ul>
<li>拷贝配置文件到每个实例目录</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201093004003.png" alt="image-20250201093004003"></p>
<ul>
<li>修改每个实例的端口、工作目录</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201093641965.png" alt="image-20250201093641965"></p>
<ul>
<li>修改每个实例的声明IP，虚拟机本身有多个IP，为避免将来出现混乱，需要在redis.conf中指定每一个实例的IP绑定信息</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201093840161.png" alt="image-20250201093840161"></p>
<ul>
<li>启动，为便于查看日志，打开三个SSH窗口，分别启动三个redis实例。</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201093954864.png" alt="image-20250201093954864"></p>
<ul>
<li><p>开启主从关系，replicaof&#x2F;slaveof，在B节点执行命令以使B成为其它节点的从节点</p>
<ul>
<li>临时：使用redis-cli客户端连接到redis服务，执行slaveof命令，重启后失效。</li>
<li>修改配置文件（永久生效），在redis.conf中添加一行配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="主从数据同步原理"><a href="#主从数据同步原理" class="headerlink" title="主从数据同步原理"></a>主从数据同步原理</h4><p><strong>全量同步</strong></p>
<p>主从第一次同步是全量同步，但是slave节点实际请求的是增量同步，但是在master节点判断replid不一致后会拒绝增量同步请求而进行全量同步</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201103901981.png" alt="image-20250201103901981"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：之所以称为全量同步是因为进行了一次RDB操作。</span><br></pre></td></tr></table></figure>



<p><strong>master如何判断slave是不是第一次同步数据</strong></p>
<ul>
<li>Replication Id：简称replid，标记数据集，id一致则说明是同一数据集，每一个master都有唯一的replid，slave则会继承master节点的replid。</li>
<li>offset：偏移量，随记录在repl_baklog中的数据增多而逐渐增大，slave完成同步时也会记录当前同步的offset，若slave的offset小于master的offset，说明slave数据落后于master，需要更新</li>
</ul>
<p>slave数据同步之前必须向master声明自己的replication id和offset</p>
<p><strong>增量同步</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201104557088.png" alt="image-20250201104557088"></p>
<p>repl_baklog大小存在上限，写满后会覆盖最早的数据，若slave断开时间过久，导致数据被覆盖，无法实现增量同步，只能再次全量同步</p>
<p>增量同步的范围是从slave的offset到master的offset之间的数据，显然当master的offset超出整个repl_baklog后，就会存在部分数据被覆盖，此时就不能通过增量同步进行同步，只能进行全量同步</p>
<p><strong>优化Redis主从集群的几个方面</strong></p>
<ul>
<li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO，即在写RDB文件只不通过先进行磁盘同步的方式，而是将RDB文件通过网络直接发送到</li>
<li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li>
<li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li>
<li>限制一个master上的slave节点数量，若有比较多的slave节点，可以采用主-从-从链式结构，以减少master压力</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201110702036.png" alt="image-20250201110702036"></p>
<p><strong>全量同步和增量同步区别</strong></p>
<ul>
<li>区别<ul>
<li>全量同步是直接将完整内存数据生成RDB，发送RDB到slave，后续命令记录在repl_baklog，逐个发送给slave</li>
<li>增量同步是slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li>
</ul>
</li>
<li>条件<ul>
<li>全量同步<ul>
<li>slave节点第一次连接master节点</li>
<li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖</li>
</ul>
</li>
<li>增量同步<ul>
<li>slave节点断开又恢复，且在repl_baklog中能找到offset时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h3><h4 id="哨兵的作用和原理"><a href="#哨兵的作用和原理" class="headerlink" title="哨兵的作用和原理"></a>哨兵的作用和原理</h4><p>Redis使用哨兵（sentinel）机制来实现主从集群的自动故障恢复</p>
<p><strong>结构和作用</strong></p>
<ul>
<li>监控：sentinel会不断检查master和slave是否按预期工作</li>
<li>自动故障恢复：如果master故障，sentinel会将slave提升为master，故障实例恢复后以新的master为主</li>
<li>通知：sentinel充当Redis客户端的服务发现来源，集群发生故障转移时，将最新信息推送给Redis的客户端</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201115000777.png" alt="image-20250201115000777"></p>
<p><strong>服务状态监控</strong></p>
<p>sentinel基于心跳机制监测服务状态，每隔1s向集群的每个实例发送ping命令</p>
<ul>
<li>主观下线：如果某sentinel节点发现某实例未在规定时间响应</li>
<li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则客观下线，quorum值最好超过sentinel实例数的一半</li>
</ul>
<p><strong>选举新的master</strong></p>
<p>master发生故障，sentinel在slave中选择新的master</p>
<ul>
<li>先判断slave节点与master节点断开时间长短，超过指定值的节点被排除</li>
<li>判断slave节点的slave-priority值，越小优先级越高，如果为0则永不参与选举</li>
<li>如果slave-priority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>
<li>最后是判断slave节点的运行id，越小优先级越高</li>
</ul>
<p><strong>选定新master后故障的转移</strong></p>
<ul>
<li>sentinel向备选slave节点发送slaveof no one命令，使其成为master节点</li>
<li>sentinel给其他slave节点发送slaveof (masterip)命令，让这些slave成为新master的从节点，开始从新master上同步数据</li>
<li>最后sentinel将故障节点标记为slave，故障节点恢复后会自动成为新master的slave节点</li>
</ul>
<h4 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h4><p>搭建三个哨兵的集群，在同一台虚拟机开启三个实例</p>
<ul>
<li>创建三个文件夹</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201145526785.png" alt="image-20250201145526785"></p>
<ul>
<li>在s1目录下创建一个sentinel.conf文件，添加下面的内容</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201145944592.png" alt="image-20250201145944592"></p>
<ul>
<li>将s1&#x2F;sentinel.conf文件拷贝到s2和s3目录中</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201151000885.png" alt="image-20250201151000885"></p>
<ul>
<li>修改s2和s3两个文件夹中的配置文件，将端口分别修改为27002、27003</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201150949647.png" alt="image-20250201150949647"></p>
<ul>
<li>为便于查看日志，打开三个ssh窗口，分别启动三个redis实例</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201151037522.png" alt="image-20250201151037522"></p>
<h4 id="RedisTemplate的哨兵模式"><a href="#RedisTemplate的哨兵模式" class="headerlink" title="RedisTemplate的哨兵模式"></a>RedisTemplate的哨兵模式</h4><p>Spring中的RedisTemplate底层利用Lettuce实现了节点的感知和自动切换</p>
<p><strong>哨兵模式的配置</strong></p>
<ul>
<li>在pom文件中引入redis的starter依赖</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201151657177.png" alt="image-20250201151657177"></p>
<ul>
<li>在配置文件application.yml中指定sentinel相关信息</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201151709197.png" alt="image-20250201151709197"></p>
<ul>
<li>配置主从读写分离<ul>
<li>MASTER：从主节点读取</li>
<li>MASTER_PREFERRED：优先从主节点读取，主节点不可用才读取从节点</li>
<li>REPLICA：从从节点读取</li>
<li>REPLICA_PREFERRED：优先读取从节点，所有从节点不可用再读取主节点</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201152304632.png" alt="image-20250201152304632"></p>
<h3 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h3><p>主从和哨兵可以解决高可用、高并发读的问题，但是仍有下面的问题</p>
<ul>
<li>海量数据存储</li>
<li>高并发写</li>
</ul>
<p>使用分片集群可以解决上面的问题</p>
<p><strong>分片集群特征</strong></p>
<ul>
<li>集群中多个master，每个master保存不同数据</li>
<li>每个master可以有多个slave节点</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可以访问集群任意节点，最终会被转发到正确节点</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201153851470.png" alt="image-20250201153851470"></p>
<h4 id="搭建分片集群"><a href="#搭建分片集群" class="headerlink" title="搭建分片集群"></a>搭建分片集群</h4><p>搭建三个主节点和三个从节点的分片集群</p>
<ul>
<li>新建目录</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201154028862.png" alt="image-20250201154028862"></p>
<ul>
<li>设置redis.conf文件</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201154422337.png" alt="image-20250201154422337"></p>
<ul>
<li>将conf文件拷贝到每个目录下</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201155150667.png" alt="image-20250201155150667"></p>
<ul>
<li>修改每个目录下的redis.conf，修改6379与所在目录一致</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201155245898.png" alt="image-20250201155245898"></p>
<ul>
<li>已经配置了后台启动模式，故可以直接启动服务</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201155401286.png" alt="image-20250201155401286"></p>
<ul>
<li>若要关闭所有进程</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201155453688.png" alt="image-20250201155453688"></p>
<ul>
<li>创建集群（Redis5.0后），集群管理以及继承到redis.cli中</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201155602042.png" alt="image-20250201155602042"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201155624573.png" alt="image-20250201155624573"></p>
<ul>
<li>通过命令查看集群状态</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201155745692.png" alt="image-20250201155745692"></p>
<h4 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h4><p>Redis将每个master节点映射到0~16383共16384个插槽（hash slot）上，这样即便节点丢失，可以从相关插槽上找回数据</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201155929329.png" alt="image-20250201155929329"></p>
<p><strong>计算插槽值的方法</strong></p>
<p>数据key不是与节点绑定，而是与插槽绑定，redis根据key的有效部分计算插槽值</p>
<ul>
<li>key中包含{}，且{}中至少包含1个字符，{}中的部分是有效部分</li>
<li>key中不包含{}，整个key都是有效部分</li>
</ul>
<p>计算方式是通过CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值</p>
<p><strong>Redis如何判断某个key应该在哪个实例</strong></p>
<ul>
<li>将16384个插槽分配到不同实例</li>
<li>根据key的有效部分计算哈希值，对16384取余</li>
<li>余数作为插槽，寻找插槽所在实例即可</li>
</ul>
<p><strong>如何将同类数据固定的保存在同一个Redis实例</strong></p>
<ul>
<li>同一类数据使用相同的有效部分</li>
</ul>
<h4 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h4><p>通过reshard命令将部分插槽从一个节点转移到另一个节点</p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p><strong>集群中一个master宕机</strong></p>
<ul>
<li>该实例与其它实例失去连接</li>
<li>显示疑似宕机</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201183559808.png" alt="image-20250201183559808"></p>
<ul>
<li>确定下线，自动提升一个slave作为新的master</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201183613597.png" alt="image-20250201183613597"></p>
<p><strong>数据迁移</strong></p>
<p>使用cluster failover命令可以手动让集群中的某个master宕机，切换到执行命令的slave节点，实现无感知的数据迁移</p>
<p>手动的Failover支持三种模式</p>
<ul>
<li>缺省</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201184038201.png" alt="image-20250201184038201"></p>
<ul>
<li>force：省略了对offset的一致性校验</li>
<li>takeover：直接执行第5步，忽略数据一致性，忽略master状态和其它master意见</li>
</ul>
<h4 id="RedisTemplate访问分片集群"><a href="#RedisTemplate访问分片集群" class="headerlink" title="RedisTemplate访问分片集群"></a>RedisTemplate访问分片集群</h4><p><strong>配置</strong></p>
<ul>
<li><p>引入redis的starter依赖</p>
</li>
<li><p>配置分片集群地址</p>
</li>
<li><p>配置读写分离</p>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201184407435.png" alt="image-20250201184407435"></p>
<h2 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h2><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，若未命中则查询数据库</p>
<ul>
<li>请求经Tomcat处理，Tomcat性能成为整个系统的瓶颈</li>
<li>Redis缓存失效时，会对数据库产生冲击</li>
</ul>
<p><strong>多级缓存方案</strong></p>
<p>充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250201225551487.png" alt="image-20250201225551487"></p>
<h3 id="JVM进程缓存"><a href="#JVM进程缓存" class="headerlink" title="JVM进程缓存"></a>JVM进程缓存</h3><p>主要解决的是tomcat部分的缓存建立</p>
<p>本质是<strong>Tomcat + Java</strong></p>
<h4 id="mysql安装"><a href="#mysql安装" class="headerlink" title="mysql安装"></a><strong>mysql安装</strong></h4><ul>
<li>为方便后期配置MySQL，先准备两个目录，用于挂在容器的数据和配置文件目录</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205193556675.png" alt="image-20250205193556675"></p>
<ul>
<li>进入mysql目录，执行Docker命令</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205193619345.png" alt="image-20250205193619345"></p>
<ul>
<li>在&#x2F;tmp&#x2F;mysql&#x2F;conf中添加my.cnf文件，作为mysql配置文件</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205193837255.png" alt="image-20250205193837255"></p>
<p><code>文件内容</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205193855388.png" alt="image-20250205193855388"></p>
<ul>
<li>配置修改后，必须重启容器</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205193946967.png" alt="image-20250205193946967"></p>
<h4 id="NGINX反向代理配置"><a href="#NGINX反向代理配置" class="headerlink" title="NGINX反向代理配置"></a><strong>NGINX反向代理配置</strong></h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205202243679.png" alt="image-20250205202243679"></p>
<h4 id="本地进程缓存"><a href="#本地进程缓存" class="headerlink" title="本地进程缓存"></a><strong>本地进程缓存</strong></h4><ul>
<li>分布式缓存：Redis<ul>
<li>优点：存储容量更大，可靠性更好，可以在集群间共享</li>
<li>缺点：访问缓存有网络开销（独立于tomcat外）</li>
<li>场景：缓存数据量较大、可靠性要求较高，需要在集群间共享</li>
</ul>
</li>
<li>进程本地缓存：HashMap、GuavaCache、Caffeine<ul>
<li>优点：读取本地内存，没有网络开销，速度更快</li>
<li>缺点：存储容量有限、可靠性较低、无法共享（基于JVM，多台tomcat之间的JVM进程独立）</li>
<li>场景：性能要求较高，缓存数据量较小</li>
</ul>
</li>
</ul>
<h4 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a><strong>Caffeine</strong></h4><p>一个基于JAVA8开发的，提供近乎最佳命中率的高性能的本地缓存库，目前Spring内部的缓存选择</p>
<ul>
<li>基本API</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建缓存对象</span></span><br><span class="line">Cache&lt;Object, Object&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//存数据</span></span><br><span class="line">cache.put(key, obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取数据，不存在就返回Null</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cache.getIfPresent(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取数据，不存在则查询数据库</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key, key-&gt;&#123;</span><br><span class="line">    <span class="comment">//利用key查询value,也可以返回假值</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>缓存驱逐策略</p>
<ul>
<li>基于容量：设置缓存的数量上限</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205212841721.png" alt="image-20250205212841721"></p>
<ul>
<li>基于时间：设置缓存的有效时间</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205212855649.png" alt="image-20250205212855649"></p>
<ul>
<li>基于引用：设置缓存为软引用或弱引用，利用GC来回收缓存数据，性能较差，不建议使用</li>
</ul>
<p><code>默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即清理和驱逐，而是在一次读或写操作后，或在空闲时间完成对失效数据的驱逐</code></p>
</li>
</ul>
<p><strong>实现缓存实例代码</strong></p>
<ul>
<li>config类</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205213331845.png" alt="image-20250205213331845"></p>
<ul>
<li>修改controller实现</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205213924907.png" alt="image-20250205213924907"></p>
<h3 id="Lua语法入门"><a href="#Lua语法入门" class="headerlink" title="Lua语法入门"></a>Lua语法入门</h3><p><strong>Nginx + Lua</strong></p>
<p>轻量小巧的脚本语言，标准C语言编写且开放源代码，设计目的是为了嵌入应用程序中，从而为了应用程序提供灵活的扩展和定制功能</p>
<p><strong>helloworld入门</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205214409180.png" alt="image-20250205214409180"></p>
<h4 id="变量和循环"><a href="#变量和循环" class="headerlink" title="变量和循环"></a><strong>变量和循环</strong></h4><ul>
<li>数据类型  <code>可以用type函数来输出变量的类型</code></li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205214540791.png" alt="image-20250205214540791"></p>
<ul>
<li>声明变量</li>
</ul>
<p><code>字符串拼接可以用 .. </code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205215037523.png" alt="image-20250205215037523"></p>
<ul>
<li>数组和table的访问示例</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205215641171.png" alt="image-20250205215641171"></p>
<ul>
<li>遍历数组</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205215941670.png" alt="image-20250205215941670"></p>
<ul>
<li>遍历table</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205215950292.png" alt="image-20250205215950292"></p>
<h4 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a><strong>条件控制</strong></h4><ul>
<li>if else语法</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205220323070.png" alt="image-20250205220323070"></p>
<ul>
<li>布尔表达式</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205220343183.png" alt="image-20250205220343183"></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h4><ul>
<li>定义函数的语法</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205220109276.png" alt="image-20250205220109276"></p>
<h3 id="多级缓存-1"><a href="#多级缓存-1" class="headerlink" title="多级缓存"></a>多级缓存</h3><h4 id="OpenResty安装"><a href="#OpenResty安装" class="headerlink" title="OpenResty安装"></a><strong>OpenResty安装</strong></h4><p>一个基于Nginx和Lua的高性能web平台，用于方便地搭建能够处理超高并发，扩展性高的动态Web应用、Web服务和动态网关</p>
<p><strong>特点</strong></p>
<ul>
<li>具备Nginx完整功能</li>
<li>基于Lua语言进行扩展，集成大量精良的Lua库，第三方模块</li>
<li>允许使用Lua自定义业务逻辑、自定义库</li>
</ul>
<p><strong>安装流程</strong></p>
<ul>
<li>Linux虚拟机联网</li>
<li>安装OpenResty的依赖开发库，执行命令</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205222450106.png" alt="image-20250205222450106"></p>
<ul>
<li>安装OpenResty仓库，在CentOS系统中添加openresty仓库，可以便于未来安装或更新软件包（yum check-update），运行下面的命令</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205222614234.png" alt="image-20250205222614234"></p>
<p><code>若提示命令不存在，执行下面的命令再重复上面的命令</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205222702746.png" alt="image-20250205222702746"></p>
<ul>
<li>安装OpenResty</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205222731274.png" alt="image-20250205222731274"></p>
<ul>
<li>安装opm工具，opm是OpenResty的一个管理工具，可以帮助我们安装一个第三方的Lua模块</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205222830772.png" alt="image-20250205222830772"></p>
<ul>
<li>配置Nginx的环境变量</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205222928340.png" alt="image-20250205222928340"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205222938910.png" alt="image-20250205222938910"></p>
<p><code>NGINX_HOME后面是OpenResty安装目录下的nginx的目录</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205222953263.png" alt="image-20250205222953263"></p>
<ul>
<li>启动和运行</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205223139440.png" alt="image-20250205223139440"></p>
<ul>
<li>删减conf文件中的注释，便于后期修改</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205223240265.png" alt="image-20250205223240265"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205223254373.png" alt="image-20250205223254373"></p>
<h4 id="OpenResty快速入门"><a href="#OpenResty快速入门" class="headerlink" title="OpenResty快速入门"></a><strong>OpenResty快速入门</strong></h4><p><strong>流程</strong></p>
<ul>
<li>修改nginx.conf文件，在http下添加对OpenResty的Lua模块的加载以及在server下添加对&#x2F;api&#x2F;item路径的监听</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205224529789.png" alt="image-20250205224529789"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205224537517.png" alt="image-20250205224537517"></p>
<ul>
<li>编写item.lua文件</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205224709892.png" alt="image-20250205224709892"></p>
<h4 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a><strong>请求参数处理</strong></h4><p><strong>不同类型请求参数的获取API</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205225100369.png" alt="image-20250205225100369"></p>
<h4 id="查询Tomcat"><a href="#查询Tomcat" class="headerlink" title="查询Tomcat"></a><strong>查询Tomcat</strong></h4><p>先实现从OpenResty对Tomcat直接的查询请求</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205225505371.png" alt="image-20250205225505371"></p>
<p><strong>Nginx发送HTTP请求</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206091327609.png" alt="image-20250206091327609"></p>
<ul>
<li>返回的响应内容<ul>
<li>resp.status：响应状态码</li>
<li>resp.header：响应头，一个table</li>
<li>resp.body：响应体，即响应数据</li>
</ul>
</li>
</ul>
<p><code>注意：这里的path是路径，不包含ip和端口，该请求会被nginx内部的server监听并处理，但是我们希望这个请求发送到Tomcat服务器。所以还需要编写一个server来对这个路径做反向代理</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206091717292.png" alt="image-20250206091717292"></p>
<ul>
<li>将HTTP请求封装成Lua脚本，放在OpenResty函数库中，方便后续使用</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206092316111.png" alt="image-20250206092316111"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206092015399.png" alt="image-20250206092015399"></p>
<ul>
<li><p>引入OpenResty提供的cjson模块来处理JSON的序列化和反序列化</p>
<ul>
<li>引入cjson模块</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206092716173.png" alt="image-20250206092716173"></p>
<ul>
<li>序列化示例</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206092728888.png" alt="image-20250206092728888"></p>
<ul>
<li>反序列化示例</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206092741361.png" alt="image-20250206092741361"></p>
</li>
<li><p>实现nginx向tomcat发送请求查询商品及库存信息并且通过json转化为lua的table，然后返回的lua脚本</p>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206093111636.png" alt="image-20250206093111636"></p>
<p><strong>Tomcat集群的负载均衡</strong></p>
<ul>
<li>反向代理配置，配置路径请求到tomcat集群</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206093442570.png" alt="image-20250206093442570"></p>
<ul>
<li>配置tomcat集群</li>
</ul>
<p><code>对请求路径进行hash计算，得到hash值后对tomcat集群服务器数进行取模，得到实际要请求的服务器。否则如果采取轮询的方式，在访问同一路径时，访问了其它服务器，而服务器之间进程缓存不共享，就导致了第一次请求的服务器上的缓存失效</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206094428634.png" alt="image-20250206094428634"></p>
<h4 id="Redis缓存预热"><a href="#Redis缓存预热" class="headerlink" title="Redis缓存预热"></a><strong>Redis缓存预热</strong></h4><p><strong>冷启动</strong></p>
<p>服务刚刚启动时，Redis中没有缓存，若所有商品数据都在第一次查询时添加缓存，可能给数据库带来较大压力</p>
<p><strong>缓存预热</strong></p>
<p>实际开发中，可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中</p>
<ul>
<li>docker安装redis</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206101145871.png" alt="image-20250206101145871"></p>
<p><code>appendonly是指要做数据的持久化</code></p>
<ul>
<li>在item-service服务中引入redis依赖</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206101212718.png" alt="image-20250206101212718"></p>
<ul>
<li>配置redis地址</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206101236493.png" alt="image-20250206101236493"></p>
<ul>
<li>编写初始化类</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206101254324.png" alt="image-20250206101254324"></p>
<ul>
<li>代码实现</li>
</ul>
<p><code>当前项目是直接将所有数据都载入了redis</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206101647454.png" alt="image-20250206101647454"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206101722847.png" alt="image-20250206101722847"></p>
<h4 id="查询Redis缓存"><a href="#查询Redis缓存" class="headerlink" title="查询Redis缓存"></a><strong>查询Redis缓存</strong></h4><p>OpenResty提供了操作Redis的模块，只要引入该模块就能使用</p>
<ul>
<li>引入Redis模块并初始化Redis对象</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206101917744.png" alt="image-20250206101917744"></p>
<p><code>超时时间分别代表建立连接的超时时间、发送请求的超时时间，响应结果的超时时间</code></p>
<ul>
<li>封装函数，释放Redis连接，放入连接池</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206104244545.png" alt="image-20250206104244545"></p>
<ul>
<li>封装函数，从Redis读数据并返回</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206104228615.png" alt="image-20250206104228615"></p>
<ul>
<li>封装一下查询Redis函数，改写查询商品及库存信息的lua脚本</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206111504622.png" alt="image-20250206111504622"></p>
<h4 id="Nginx本地缓存"><a href="#Nginx本地缓存" class="headerlink" title="Nginx本地缓存"></a><strong>Nginx本地缓存</strong></h4><p>OpenResty为Nginx提供了<strong>shared dict</strong>功能，使得可以在nginx多个worker之间共享数据，实现缓存功能</p>
<ul>
<li>开启共享字典，在nginx.conf的http下添加配置</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206111912670.png" alt="image-20250206111912670"></p>
<ul>
<li>操作共享字典</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206111928296.png" alt="image-20250206111928296"></p>
<ul>
<li>修改原实现脚本，优先查询OpenResty的本地缓存</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206113749816.png" alt="image-20250206113749816"></p>
<h3 id="缓存同步策略"><a href="#缓存同步策略" class="headerlink" title="缓存同步策略"></a>缓存同步策略</h3><h4 id="数据同步策略"><a href="#数据同步策略" class="headerlink" title="数据同步策略"></a>数据同步策略</h4><p><strong>常见方式</strong></p>
<ul>
<li>设置有效期：缓存设置有效期，到期后自动删除，再次查询时更新<ul>
<li>优点：简单、方便</li>
<li>缺点：时效性差，缓存过期之前可能不一致</li>
<li>场景：更新频率较低，时效性要求低的业务</li>
</ul>
</li>
<li>同步双写：在修改数据库的同时，直接修改缓存<ul>
<li>优点：时效性强，缓存与数据库强一致</li>
<li>缺点：存在代码侵入，耦合度高</li>
<li>场景：对一致性、时效性要求较高的缓存数据</li>
</ul>
</li>
<li>异步通知：修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据<ul>
<li>优点：低耦合，可同时通知多个缓存服务</li>
<li>缺点：时效性一般，可能存在中间不一致状态</li>
<li>场景：时效性要求一般，多个服务需要同步</li>
</ul>
</li>
</ul>
<p><strong>异步通知的实现</strong></p>
<ul>
<li>基于MQ</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206114537685.png" alt="image-20250206114537685"></p>
<ul>
<li>基于Canal  <code>代码零侵入</code></li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206114554219.png" alt="image-20250206114554219"></p>
<h4 id="安装Canal"><a href="#安装Canal" class="headerlink" title="安装Canal"></a>安装Canal</h4><p>阿里巴巴旗下的开源项目，基于java开发，基于数据库增量日志解析，提供增量数据订阅&amp;消费，且提供了各种语言的客户端</p>
<p>Canal基于Mysql的主从同步实现，将自己伪装成Mysql的一个slave节点，监听master的binary log变化，再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206115543750.png" alt="image-20250206115543750"></p>
<p><strong>Mysql的主从同步原理</strong></p>
<ul>
<li>Mysql master将数据变更写入二进制日志（binary log），其中记录的数据叫做binary log events</li>
<li>Mysql slave将master的binary log events拷贝到它的中继日志（relay log）中</li>
<li>Mysql slave 重放relay log中事件，将数据变更反映到其自己的数据上</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206115332921.png" alt="image-20250206115332921"></p>
<p><strong>配置流程</strong></p>
<p>先要开启mysql主从功能</p>
<ul>
<li>打开mysql容器挂载的日志文件，开启binlog</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206121725805.png" alt="image-20250206121725805"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206121735692.png" alt="image-20250206121735692"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206121745506.png" alt="image-20250206121745506"></p>
<p><code>log-bin=/var/lib/mysql-bin : 设置binary log文件的存放地址和文件名，叫做mysql-bin</code></p>
<p><code>binlog-do-db=heima : 指定哪个database记录binary log events，这里记录heima</code></p>
<ul>
<li>添加一个仅用于数据同步的账户，仅提供对heima这个库的操作权限</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206122646638.png" alt="image-20250206122646638"></p>
<ul>
<li>重启mysql容器</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206122700329.png" alt="image-20250206122700329"></p>
<ul>
<li>测试设置是否成功</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206122747251.png" alt="image-20250206122747251"></p>
<ul>
<li>创建网络，将mysql，canal，mq放到同一个docker网络中，并且让mysql加入这个网络</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206122926320.png" alt="image-20250206122926320"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206122937770.png" alt="image-20250206122937770"></p>
<ul>
<li>加载docker镜像</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206123029101.png" alt="image-20250206123029101"></p>
<ul>
<li>创建canal容器</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206123136594.png" alt="image-20250206123136594"></p>
<p><code>命令的说明</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206123211062.png" alt="image-20250206123211062"></p>
<p><code>表名称监听支持的语法</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206123240425.png" alt="image-20250206123240425"></p>
<h4 id="监听Canal"><a href="#监听Canal" class="headerlink" title="监听Canal"></a>监听Canal</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206123451438.png" alt="image-20250206123451438"></p>
<p>当canal监听到binlog变化时，会通知canal的客户端</p>
<p><strong>使用第三方开源canal-starter进行配置</strong></p>
<ul>
<li>引入依赖</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206123534076.png" alt="image-20250206123534076"></p>
<ul>
<li>编写配置</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206123540848.png" alt="image-20250206123540848"></p>
<p><strong>监听配置流程</strong></p>
<ul>
<li>编写监听器</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206123925324.png" alt="image-20250206123925324"></p>
<ul>
<li>canal推送到canal-client的是被修改的行数据，我们引入的canal-client会将行数据封装到item实体类中，此过程中需要用JPA的几个注解来获取到数据库与实体的映射关系</li>
</ul>
<p><code>JPA（Java Persistence API），一套Java平台上的对象持久化标注，通过JDK5.0注释或XML描述对象与关系表之间的映射关系，将运行时的实体对象持久化到数据库中</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206124424154.png" alt="image-20250206124424154"></p>
<ul>
<li>代码实现</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206125258163.png" alt="image-20250206125258163"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206125434932.png" alt="image-20250206125434932"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206125412255.png" alt="image-20250206125412255"></p>
<h2 id="Redis最佳实践"><a href="#Redis最佳实践" class="headerlink" title="Redis最佳实践"></a>Redis最佳实践</h2><h3 id="Redis键值设计"><a href="#Redis键值设计" class="headerlink" title="Redis键值设计"></a>Redis键值设计</h3><h4 id="优雅的key结构"><a href="#优雅的key结构" class="headerlink" title="优雅的key结构"></a>优雅的key结构</h4><ul>
<li>基本格式：[业务名称]:[数据名]:[id]<ul>
<li>优点<ul>
<li>可读性强</li>
<li>避免key冲突</li>
<li>方便管理</li>
</ul>
</li>
</ul>
</li>
<li>长度不超过44字节<ul>
<li>优点<ul>
<li>更节省内存，key是string类型，底层编码包含int\embstr\raw三种，embstr在小于44字节使用，采用连续内存空间，内存占用更小</li>
</ul>
</li>
</ul>
</li>
<li>不包含特殊字符</li>
</ul>
<h4 id="拒绝bigkey"><a href="#拒绝bigkey" class="headerlink" title="拒绝bigkey"></a>拒绝bigkey</h4><p><strong>Bigkey通常以key的大小和key中成员的数量来综合判定</strong></p>
<ul>
<li>key本身的数据量过大：一个5mb的String类型的key</li>
<li>key中的成员数过多：一个含有10000个成员的ZSET类型的key</li>
<li>key中成员的数据量过大：一个仅含1000个成员但成员总value大小为100mb的Hash类型的key</li>
</ul>
<p><strong>推荐值</strong></p>
<ul>
<li>单个key的value小于10kb</li>
<li>对于集合类型的key，建议元素数量小于1000</li>
</ul>
<p><strong>bigkey的危害</strong></p>
<ul>
<li><p>网络阻塞：对bigkey执行读请求时，少量的QPS就可能导致带宽使用率被占满导致redis示例乃至所在物理机变慢</p>
</li>
<li><p>数据倾斜：bigkey所在的redis实例内存使用率元朝其它实例，无法使数据分片的内存资源达到均衡</p>
</li>
<li><p>redis阻塞：对元素较多的hash、list、zest做运算会耗时较久，使得主线程被阻塞</p>
</li>
<li><p>CPU压力：对bigkey的数据序列化和反序列化会导致CPU的使用率飙升，影响redis实例和本机其它应用</p>
</li>
</ul>
<p><strong>如何发现bigkey</strong></p>
<ul>
<li>redis-cli –bigkeys：可以遍历分析所有key，并返回key的整体统计信息与每一种数据类型的top1的bigkey</li>
</ul>
<p><code>只能作为参考，首先top1的key不一定是bigkey，而且不能得知其它key还有哪些bigkey</code></p>
<ul>
<li>scan扫描：自己编程，利用scan扫描redis中的所有key，使用strlen，hlen等命令判断key的长度（不建议使用占用内存过大的MEMORY USAGE）</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206134356574.png" alt="image-20250206134356574"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206134502018.png" alt="image-20250206134502018"><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206134533916.png" alt="image-20250206134533916"></p>
<ul>
<li>第三方工具：利用第三方工具，如redis-rdb-tools来分析rdb快照文件，全面分析内存使用情况，但是是离线分析，时效性不是特别好</li>
<li>网络监控：自定义工具：监控进出redis的网络数据，超出预警值时主动告警</li>
</ul>
<p><strong>如何删除bigkey</strong></p>
<ul>
<li>redis3.0及以下版本：若为集合类型，先遍历bigkey的元素，再逐个删除子元素，最后删除bigkey</li>
<li>redis4.0之后版本：redis在4.0后提供了异步删除的命令：unlink</li>
</ul>
<h4 id="恰当的数据类型"><a href="#恰当的数据类型" class="headerlink" title="恰当的数据类型"></a>恰当的数据类型</h4><p><strong>单个对象的存储方式选择</strong></p>
<ul>
<li>json字符串<ul>
<li>优点：实现简单粗暴</li>
<li>缺点：数据耦合，不够灵活</li>
</ul>
</li>
<li>字段打散<ul>
<li>优点：可以灵活访问对象任意字段</li>
<li>缺点：占用空间大，没办法做统一控制</li>
</ul>
</li>
<li>hash（推荐）<ul>
<li>优点：底层使用ziplist，空间占用小，可以灵活访问对象的任意字段</li>
<li>缺点：代码相对复杂</li>
</ul>
</li>
</ul>
<p>一个具有100w对field和value的hash类型的key存在的问题</p>
<ul>
<li><p>问题</p>
<ul>
<li>hash的entry数量超过500时，会使用哈希表而不是ziplist，内存占用较多</li>
</ul>
</li>
<li><p>优化</p>
<ul>
<li>可以通过hash-max-ziplist-entries配置entry上限，但是entry过多可能会导致bigkey问题</li>
<li>将field转为key，value转为value，拆分成String类型<ul>
<li>存在的问题<ul>
<li>String结构底层无太多内存优化，内存占用较多</li>
<li>想要批量获取这些数据很麻烦</li>
</ul>
</li>
</ul>
</li>
<li>拆分成的小的hash，将id&#x2F;100作为key，id % 100作为field，这样每100个元素为一个hash</li>
</ul>
</li>
</ul>
<h3 id="批处理优化"><a href="#批处理优化" class="headerlink" title="批处理优化"></a>批处理优化</h3><h4 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h4><ul>
<li>N条命令依次执行</li>
</ul>
<p><code>N次往返的网络传输耗时 + N次Redis执行命令耗时</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206164733954.png" alt="image-20250206164733954"></p>
<ul>
<li>N条命令批量执行</li>
</ul>
<p><code>1次往返的网络传输耗时 + N次Redis执行命令耗时</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206164912248.png" alt="image-20250206164912248"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：不要再一次批处理中传输太多命令，否则单次命令占用带宽过多，会导致网络阻塞</span><br></pre></td></tr></table></figure>



<p><strong>原生的批处理命令</strong></p>
<ul>
<li>mset：只能处理字符串</li>
<li>hmset：只能处理哈希</li>
<li>sadd：key不能变化，只能处理set集合</li>
</ul>
<p>pipeline可以处理各种数据类型，但是要注意多个命令之间不具备原子性</p>
<h4 id="集群下的批处理"><a href="#集群下的批处理" class="headerlink" title="集群下的批处理"></a>集群下的批处理</h4><p>对于MSET或Pipeline这样的批处理需要在一次请求中携带多条命令，但如果Redis是一个集群，那么批处理命令的多个key必须落在同一个插槽中，否则就会导致执行失败</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206174344350.png" alt="image-20250206174344350"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">推荐使用并行slot，Spring提供</span><br></pre></td></tr></table></figure>



<h3 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h3><h4 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h4><p>Redis的持久化虽然可以保证数据安全，但是会有很多额外开销</p>
<p><strong>持久化建议</strong></p>
<ul>
<li><p>用来做缓存的Redis实例尽量不要开启持久化功能</p>
</li>
<li><p>建议关闭RDB持久化功能，使用AOF持久化，RDB执行周期长，数据安全性不能得到保证</p>
</li>
<li><p>利用脚本定期在slave节点做RDB，实现数据备份</p>
</li>
<li><p>设置合理的rewrite阈值，避免频繁的bgrewrite</p>
</li>
<li><p>配置no-appendfsync-on-rewrite &#x3D; yes，禁止在rewrite期间做AOF，避免因AOF引起的阻塞，但是这可能导致rewrite期间的命令未被持久化</p>
</li>
</ul>
<p><strong>部署相关建议</strong></p>
<ul>
<li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li>
<li>单个Redis实例内存上限不要太大，可以加快fork的速度，减少主从同步、数据迁移的压力</li>
<li>不要与CPU密集型应用部署在一起，比如es</li>
<li>不要与高硬盘负载应用一起部署（数据库、消息队列）</li>
</ul>
<h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>在Redis执行时耗时超过某个阈值的命令</p>
<p><strong>慢查询的阈值</strong></p>
<ul>
<li>slowlog-log-slower-than：慢查询阈值，单位是微秒，默认为10000，建议1000</li>
</ul>
<p>慢查询会被放到慢查询日志中，慢查询日志本质是一个队列，长度存在上限</p>
<p><strong>慢查询日志长度</strong></p>
<ul>
<li>slowlog-max-len：默认为128，建议1000</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206195836546.png" alt="image-20250206195836546"></p>
<p><code>修改</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206195853355.png" alt="image-20250206195853355"></p>
<p><strong>查询慢查询日志列表</strong></p>
<ul>
<li>slowlog len：查询慢查询日志长度</li>
<li>slowlog get [n]：读取n条慢查询日志</li>
<li>slowlog reset：清空慢查询列表</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206200448980.png" alt="image-20250206200448980"></p>
<h4 id="命令及安全配置"><a href="#命令及安全配置" class="headerlink" title="命令及安全配置"></a>命令及安全配置</h4><p>Redis会绑定在0.0.0.0:6379，这样会将Redis服务暴露到公网上，而Redis如果没有做身份认证，会出现严重的安全漏洞</p>
<p><strong>避免漏洞的建议</strong></p>
<ul>
<li>Redis一定设置复杂密码</li>
<li>禁止线上使用以下命令：keys、flushall、flushdb、config set等命令，可以利用rename-command禁用</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206205159585.png" alt="image-20250206205159585"></p>
<ul>
<li>bind：限制网卡，禁止外网网卡访问</li>
<li>开启防火墙</li>
<li>不要使用Root账户启动Redis</li>
<li>尽量不是有默认的端口</li>
</ul>
<h4 id="内存配置"><a href="#内存配置" class="headerlink" title="内存配置"></a>内存配置</h4><p>当Redis内存不足时，可能导致key频繁被删除、响应时间变长、QPS不稳定等问题，当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206205727549.png" alt="image-20250206205727549"></p>
<p><strong>内存碎片问题</strong></p>
<ul>
<li>源于jemalloc分配内存产生的碎片</li>
<li>定期重启Redis服务器即可解决，重启服务器的过程中就会自动清理内存碎片</li>
</ul>
<p><strong>查看Redis当前内存分配状态的命令</strong></p>
<ul>
<li><p>可以直接在GUI客户端上查看</p>
</li>
<li><p>info memory</p>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206212745742.png" alt="image-20250206212745742"></p>
<ul>
<li>memory [命令]<ul>
<li>memory doctor是自带的内存诊断策略</li>
<li>memory purge是清除一些数据</li>
<li>memory status是查看内存状态</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206212756895.png" alt="image-20250206212756895"></p>
<p><code>memory status可以查询到的所有内存情况如下，上面的截图不完整</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206212558649.png" alt="image-20250206212558649"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206212635695.png" alt="image-20250206212635695"></p>
<p><strong>内存缓冲区</strong></p>
<ul>
<li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过repl-backlogh-size来设置，默认1mb</li>
<li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li>
<li>客户端缓冲区：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置，输出缓冲区可以设置</li>
</ul>
<p><code>输出缓冲区</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250206214934078.png" alt="image-20250206214934078"></p>
<h3 id="集群最佳实践"><a href="#集群最佳实践" class="headerlink" title="集群最佳实践"></a>集群最佳实践</h3><p>集群具备高可用特性，也能实现自动故障恢复，</p>
<p><strong>但是如果使用不当，也会存在一些问题</strong></p>
<ul>
<li><p>集群完整性问题</p>
<ul>
<li>cluster-require&#x3D;full-coverage：Redis默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务，为了保证高可用特性，建议将cluster-require-full-coverage配置为false</li>
</ul>
</li>
<li><p>集群带宽问题</p>
<ul>
<li>集群节点之间会不断的互相ping来确定集群中其它节点的状态，每次ping携带的信息至少包括<ul>
<li>插槽信息</li>
<li>集群状态信息</li>
</ul>
</li>
<li>集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群胡同需要的带宽会非常高，下面有几种解决途径<ul>
<li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，就建立多个集群</li>
<li>避免在单个物理机中运行太多Redis实例，否则ping携带的信息过多</li>
<li>配置合适的cluster-node-timeout值</li>
</ul>
</li>
</ul>
</li>
<li><p>数据倾斜问题</p>
<ul>
<li>bigkey或者集群批处理时使用了相同的hashtag，都有可能出现集群负载不均衡的问题</li>
</ul>
</li>
<li><p>客户端性能问题</p>
<ul>
<li>节点的选择，读写分离，插槽的判断等均会影响客户端性能</li>
</ul>
</li>
<li><p>命令的集群兼容性问题</p>
<ul>
<li>比如使得批处理命令能在集群下运行</li>
</ul>
</li>
<li><p>lua和事务问题</p>
<ul>
<li>集群模式下是无法运行lua和事务的，对命令的原子性保证有影响</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<p>单体Redis（主从Redis）已经能达到万级别的QPS，并且在引入哨兵后也具备很强的高可用特性，若主从能满足业务需求的情况下，尽量不搭建Redis集群</p>
<h1 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="动态字符串SDS"><a href="#动态字符串SDS" class="headerlink" title="动态字符串SDS"></a>动态字符串SDS</h3><p><strong>Redis没有直接使用C语言中的字符串的原因</strong></p>
<ul>
<li>获取字符串长度需要通过运算</li>
<li>非二进制安全</li>
<li>不可修改</li>
</ul>
<p>Redis构建了一种新的字符串结构，称为简单动态字符串：Simple Dynamic String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意当执行 set nane alice时</span><br><span class="line">redis将在底层创建两个SDS，一个包含name,一个包含alice</span><br></pre></td></tr></table></figure>



<p><strong>源码结构分析</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202023921018.png" alt="image-20250202023921018"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：存储结构的数据部分在len范围内即使遇到\0也会继续读取，而非停止，所以满足二进制安全</span><br></pre></td></tr></table></figure>



<p><strong>字符串内存预分配</strong></p>
<ul>
<li><p>若新字符串小于1M，则新空间为扩展后字符串长度的两倍</p>
</li>
<li><p>若新字符串大于1M，则新空间为扩展后字符串长度+1M+1</p>
</li>
<li><p>优点</p>
<ul>
<li>获取字符串长度的时间复杂度为O(1)</li>
<li>支持动态扩容</li>
<li>减少内存分配次数</li>
<li>二进制安全</li>
</ul>
</li>
</ul>
<h3 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h3><p>Redis中set集合的一种实现方式，基于整数数组实现，具备长度可变、有序等特征</p>
<ul>
<li>Redis确保IntSet中元素唯一、有序</li>
<li>具备类型升级机制，可以节省内存空间</li>
<li>底层采用二分查找方式进行查询</li>
<li>适合小数据量使用，在大数据量下需要申请一段连续的空间</li>
</ul>
<p><strong>结构</strong></p>
<p>为便于查找，Redis将IntSet中所有整数按照升序保存在contents数组中</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202025722825.png" alt="image-20250202025722825"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202113319584.png" alt="image-20250202113319584"></p>
<p><strong>encoding模式标识存储的整数大小不同</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202102506364.png" alt="image-20250202102506364"></p>
<p><strong>升级</strong></p>
<p>当新增的数字超出了当前IntSet的encoding范围时，会自动升级编码方式到合适的大小</p>
<ul>
<li>升级编码并按照新的编码方式及元素个数扩容数组</li>
<li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li>
<li>将待添加的元素放入数组末尾</li>
<li>最后修改IntSet的encoding属性，并且修改length属性</li>
</ul>
<p><strong>IntSet新增流程源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202115416424.png" alt="image-20250202115416424"></p>
<p><strong>IntSet升级流程源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202115515301.png" alt="image-20250202115515301"></p>
<h3 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h3><p>Redis是一个键值型的数据库，键与值的映射关系是通过Dict实现的</p>
<p><strong>组成</strong></p>
<ul>
<li>哈希表（DictHashTable）</li>
<li>哈希节点（DictEntry）</li>
<li>字典（Dict）</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202121214707.png" alt="image-20250202121214707"></p>
<p><strong>结构例图</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202121403635.png" alt="image-20250202121403635"></p>
<p><strong>Hash值计算</strong></p>
<ul>
<li>通过key计算出hash值h</li>
<li>利用h &amp; sizemark计算元素索引（与运算等价于h对size取余）</li>
</ul>
<p><strong>Dict的扩容</strong></p>
<p>Dict中的HashTable就是数组结合单向链表，当集合中元素较多时，哈希冲突增多，链表过长会导致查询效率会大大降低</p>
<p>Dict每次新增键值对时都会检查负载因子（LoadFactor &#x3D; used &#x2F; size）</p>
<ul>
<li>哈希表扩容的条件<ul>
<li>哈希表的LoadFactor &gt;&#x3D; 1，且服务器没有执行BGSAVE或者BGREWRITEAOF等后台进程</li>
<li>哈希表的LoadFactor &gt; 5</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202122610321.png" alt="image-20250202122610321"></p>
<p><strong>Dict的收缩</strong></p>
<p>Dict每次删除元素时，会对负载因子进行检查</p>
<ul>
<li>哈希表收缩的条件<ul>
<li>LoadFactor &lt; 0.1</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202123157273.png" alt="image-20250202123157273"></p>
<p><strong>Dict的rehash</strong></p>
<p>不管是扩容还是收缩，都一定会创建新的哈希表，使哈希表的size和sizemask变化，而key的查询要与sizemask有关，所以必须对哈希表中的每一个key重新计算索引，插入到新的哈希表</p>
<p><strong>渐进式rehash</strong></p>
<p>但是rehash并不是一次性完成的，否则如果Dict中包含数百万的entry，要在一次rehash中完成，极有可能导致主线程阻塞，由于Dict的rehash是分多次、渐进式的完成，故称为渐进式rehash</p>
<ul>
<li><p>过程</p>
<ul>
<li>计算新哈希表的realSize，该值取决于当前是要扩容还是收缩<ul>
<li>若扩容，新size为第一个大于等于dict.ht[0].used + 1的2的幂次</li>
<li>若收缩，新size为第一个大于等于dict.ht[0].used的2的幂次（不能小于4）</li>
</ul>
</li>
<li>根据新的realSize申请内存空间，创建dictht，赋值给dict.ht[1]</li>
<li>设置dict.rehashidx &#x3D; 0，标示开始rehash，若为-1则表示没有进行rehash</li>
<li>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，若是则将dict.ht[0].table[rehashidx]的entry链表rehash到dict.ht[1]，并且将rehashidx++，直至dict.ht[0]的所有数据都rehash到dict.ht[1]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：查询、修改、删除操作都要在ht[0]和ht[1]中搜索，而新增操作直接针对ht[1]进行操作，这样可以确保ht[0]中的数据只减不增</span><br></pre></td></tr></table></figure>

<ul>
<li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li>
<li>将rehashidx赋值为-1，代表rehash结束</li>
</ul>
</li>
</ul>
<h3 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h3><p>一种特殊的“双端链表”，由一系列特殊编码的连续内存块组成，可在任意一端进行压入&#x2F;弹出操作，并且该操作的时间复杂度为O(1)</p>
<p><strong>格式</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202160055269.png" alt="image-20250202160055269"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202153729197.png" alt="image-20250202153729197"></p>
<ul>
<li>entry格式 ：不想普通链表中有记录前后节点的指针，可以节省16B的内存，采用下面的结构</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202161922477.png" alt="image-20250202161922477"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后</span><br></pre></td></tr></table></figure>

<ul>
<li><p>encoding编码</p>
<ul>
<li>字符串：以”00”, “01”, “10”开头</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202162334555.png" alt="image-20250202162334555"></p>
<ul>
<li>整数：以”11”开头</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202165839878.png" alt="image-20250202165839878"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：最后一种编码方式数值的范围为0~12</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>连锁更新问题</strong></p>
<p>ZipList连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生</p>
<p>但显然这种问题发生条件苛刻，概率极低</p>
<p><strong>特性</strong></p>
<ul>
<li>压缩列表可以看作一种连续内存空间的双向链表</li>
<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li>
<li>若列表数据过多，导致链表过长，可能影响查询性能</li>
<li>增或删较大数据时有可能发生连续更新问题</li>
</ul>
<h3 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h3><p>一个双端链表，每个节点都是一个ZipList</p>
<p><strong>ZipList的缺陷及解决</strong></p>
<ul>
<li>ZipList虽然节省内存，但是申请内存必须是连续空间，若内存占用较多，申请内存效率很低</li>
</ul>
<p><code>为缓解此问题，必须限制ZipList的长度和entry大小</code></p>
<ul>
<li>存储大量数据，会超出ZipList最佳的上限</li>
</ul>
<p><code>创建多个ZipList来分片存储数据</code></p>
<ul>
<li>数据拆分后比较分散，不方便管理和查找，多个ZipList如何建立联系</li>
</ul>
<p><code>Redis3.2开始引入QuickList</code></p>
<p><strong>结构示例</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202182725738.png" alt="image-20250202182725738"></p>
<p><strong>结构源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202182634384.png" alt="image-20250202182634384"></p>
<p><strong>配置项</strong></p>
<p>为避免QuickList中每个ZipList中entry过多，Redis中提供一个配置项：list-max-ziplist-size进行限制</p>
<p>默认值为-2</p>
<ul>
<li>值为整数，代表ZipList允许的entry个数的最大值</li>
<li>值为负数，代表单个ZipList的最大内存大小<ul>
<li>-1：4kb</li>
<li>-2：8kb</li>
<li>-3：16kb</li>
<li>-4：32kb</li>
<li>-5：64kb</li>
</ul>
</li>
</ul>
<p>为控制ZipList大小，QuickList还可以对节点的ZipList进行压缩，通过配置项list-compress-depth进行控制。</p>
<p>链表多从首尾进行访问，所以首尾是不压缩的，该参数控制首尾不压缩的节点个数</p>
<p>默认值为0</p>
<ul>
<li>0：特殊值，代表不压缩</li>
<li>1：标识QuickList的首尾各有一个节点不压缩，中间节点压缩</li>
<li>n：以此类推</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>一个节点为ZipList的双端链表</li>
<li>节点采用ZipList，解决了传统链表的内存占用问题</li>
<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>
<li>中间节点可压缩，进一步节省内存</li>
</ul>
<h3 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h3><p>一种不同于传统链表的链表</p>
<ul>
<li>元素按照升序排列存储</li>
<li>节点可能包含多个指针，指针跨度不同</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202192056089.png" alt="image-20250202192056089"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最多允许32级指针，即最多可以存储到2的32次个元素</span><br></pre></td></tr></table></figure>





<p><strong>结构示例</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202192700149.png" alt="image-20250202192700149"></p>
<p><strong>结构源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202194238231.png" alt="image-20250202194238231"></p>
<p><strong>特点</strong></p>
<ul>
<li>跳表是一个双向链表，每个节点都包含score和ele值</li>
<li>节点俺早score值排序，score值一样则按照ele字典排序</li>
<li>每个节点都可以包含多层指针，层数为1~32之间的随机数</li>
<li>不同层指针到下一节点的跨度不同，层级越高，跨度越大</li>
<li>增删改查效率与红黑树基本一致，但是实现更简单那</li>
</ul>
<h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象</p>
<p><strong>结构源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202195233924.png" alt="image-20250202195233924"></p>
<p><strong>编码类型详情</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202195639225.png" alt="image-20250202195639225"></p>
<p><strong>不同数据类型对应的编码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202195432895.png" alt="image-20250202195432895"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：其它诸如bitmap这样的数据类型（基于OBJ_STRING）只是上述五种类型的不同用法，并非新的数据类型</span><br></pre></td></tr></table></figure>





<h3 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p><strong>基本特性</strong></p>
<ul>
<li>Redis最常见的数据存储类型</li>
<li>基本编码方式是RAW</li>
<li>基于简单动态字符串SDS实现</li>
<li>存储上限为512MB</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202221934740.png" alt="image-20250202221934740"></p>
<ul>
<li>若存储的SDS长度小于44字节，则采用EMBSTR编码，此时object head与SDS是一段连续空间，申请内存时只需要调用一次内存分配函数，效率更高</li>
</ul>
<p><code>此时由于jemalloc会以2的幂次方字节大小分片并分配内存，当前下面的整片区域正好是64字节，不会在内存分配时留下内存碎片</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202222052010.png" alt="image-20250202222052010"></p>
<ul>
<li>若存储的字符串是整数值，且大小在LONG_MAX范围内，则采用INT编码，直接将数据保存在RedisObject的ptr指针位置，刚好8字节，无需SDS了</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202222533236.png" alt="image-20250202222533236"></p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>类似一个双端链表，可以从首尾操作表中的元素</p>
<p><strong>数据结构的选择</strong></p>
<ul>
<li>LinkedList：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li>
<li>ZipList：压缩列表，可以从双端访问，内存占用低，存储下限低</li>
<li>QuickList：LinkedList  + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高<ul>
<li>3.2版本前，Redis采用ZipList和LinkedList来实现List，元素数量小于且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码</li>
<li>3.2版本之后，Redis统一采用QuickList实现List</li>
</ul>
</li>
</ul>
<p><strong>结构源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202233849046.png" alt="image-20250202233849046"></p>
<p><strong>结构示例</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250202233802235.png" alt="image-20250202233802235"></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Redis中的单列集合</p>
<p><strong>特点</strong></p>
<ul>
<li>不保证有序性</li>
<li>保证元素唯一（可判断元素是否存在）</li>
<li>求交集、并集、差集</li>
</ul>
<p><strong>数据结构的选择</strong></p>
<ul>
<li><p>HashTable，即Redis中的Dict，不过Dict是双列集合（可以存储键、值对）</p>
</li>
<li><p>为了查询效率和唯一性，Set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null</p>
</li>
<li><p>当存储的所有数据都是整数且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存</p>
</li>
</ul>
<p><strong>结构示例</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203005313209.png" alt="image-20250203005313209"></p>
<p><strong>结构源码</strong></p>
<ul>
<li>数据结构创建</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203003826966.png" alt="image-20250203003826966"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203003915526.png" alt="image-20250203003915526"></p>
<h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>即SortedSet，其中每一个元素都要指定一个score值和member值</p>
<ul>
<li>可以根据score值排序</li>
<li>member必须唯一</li>
<li>可以根据member查询分数</li>
</ul>
<p><strong>数据结构的选择</strong></p>
<ul>
<li><p>SkipList：可排序且可以同时存储score值和ele值（member）</p>
</li>
<li><p>HT（Dict）：可以键值存储，且可以根据key找value</p>
</li>
<li><p>实际实现是通过SkipList进行排序，HT来保证键值存储和键必须唯一</p>
</li>
</ul>
<p><strong>结构示例</strong></p>
<ul>
<li>一般情况</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203110534781.png" alt="image-20250203110534781"></p>
<ul>
<li>元素数量小于zset_max_ziplist_entries，默认值128，且每个元素都小于zset_max_ziplist_value字节，默认值64时使用ziplist来替代<ul>
<li>ZipList本事无排序功能，且没有键值对的概念，故需要有zset通过编码实现<ul>
<li>ZipList时连续内存，故score和element是紧挨在一起的两个entry，element在前，score在后</li>
<li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203113256036.png" alt="image-20250203113256036"></p>
<p><strong>结构源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203104653518.png" alt="image-20250203104653518"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203110928779.png" alt="image-20250203110928779"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203111252813.png" alt="image-20250203111252813"></p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>与Zset相似</p>
<ul>
<li>都是键值存储</li>
<li>都休要根据键获取值</li>
<li>键必须唯一</li>
</ul>
<p>但存在区别</p>
<ul>
<li>Zset的键是member，值是score：hash的键和值都是任意值</li>
<li>Zset要根据score排序；hash无需排序</li>
</ul>
<p>故Hash底层采用的编码与Zset基本一致，只需要把排序有关的SkipList去掉即可</p>
<p><strong>结构示例</strong></p>
<ul>
<li>Hash结构默认采用ZipList编码，以节省内存，ZipList中响铃的两个entry分别保存field和value</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203124545669.png" alt="image-20250203124545669"></p>
<ul>
<li>当数据量较大时，Hash结构会转为HT编码，即Dict，触发条件有两个<ul>
<li>ZipList中元素数量超过了hash_max_ziplist_entries（默认512）</li>
<li>ZipList中的任意entry大小超过了hash_max_ziplist_value（默认64字节）</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203124722542.png" alt="image-20250203124722542"></p>
<p><strong>结构源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203124835862.png" alt="image-20250203124835862"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203125118971.png" alt="image-20250203125118971"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203125214830.png" alt="image-20250203125214830"><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203125415727.png" alt="image-20250203125415727"></p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">《UNIX网络编程》中有5中IO模型</span><br><span class="line">阻塞IO（Blocking IO）</span><br><span class="line">非阻塞IO（Nonblocking IO）</span><br><span class="line">IO多路复用（IO Multiplexing）</span><br><span class="line">信号驱动IO（Signal Driven IO）</span><br><span class="line">异步IO（Asynchronous IO）</span><br></pre></td></tr></table></figure>







<h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><p>应用通过Linux内核与硬件交互</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203132833051.png" alt="image-20250203132833051"></p>
<p>为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的</p>
<ul>
<li>进程的寻址空间划分为<strong>内核空间、用户空间</strong><ul>
<li><strong>用户空间</strong>只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问</li>
<li><strong>内核空间</strong>可以执行特权命令（Ring0），调用一切系统资源</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203133707593.png" alt="image-20250203133707593"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203133723416.png" alt="image-20250203133723416"></p>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区</p>
<ul>
<li>写数据时，将用户缓冲数据拷贝到内核缓冲区，然后写入设备</li>
<li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203141622461.png" alt="image-20250203141622461"></p>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p><strong>Blocking IO</strong></p>
<p>阻塞IO就是在内核数据就绪和拷贝数据两个阶段用户进程均为阻塞状态</p>
<p><strong>流程图</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203143635873.png" alt="image-20250203143635873"></p>
<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p><strong>Nonblocking IO</strong></p>
<p>非阻塞IO的recvfrom操作会立即返回结果而非阻塞用户进程</p>
<p>非阻塞IO在等待数据就绪阶段为非阻塞状态</p>
<p>但是在数据拷贝过程阶段是阻塞的</p>
<p>并且虽然是非阻塞，忙等机制不仅没有提高性能，还会使CPU空转，使得CPU使用率暴增</p>
<p><strong>流程图</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203144132568.png" alt="image-20250203144132568"></p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p><strong>IO Multiplexing</strong></p>
<p>利用单个线程来同时监听多个FD，并在某个FD可读，可写时得到通知，从而避免无效的等待，充分利用CPU资源</p>
<p><strong>BIO和NIO存在的问题</strong></p>
<p>服务器处理客户端Socket请求时，在单线程情况下，只能一次处理每一个socket，若正在处理的socket恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有其它客户端socket都必须等待，性能会很差</p>
<p><strong>解决方案</strong></p>
<ul>
<li>多线程：会增加资源消耗</li>
<li>当前线程监听多个Socket，只要数据就绪就可以点餐</li>
</ul>
<p><strong>文件描述符</strong></p>
<p>（File Descriptor），即FD，一个从0开始递增的无符号整数，用来关联Linux中的一个文件。</p>
<p><strong>流程图</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203154231291.png" alt="image-20250203154231291"></p>
<p><strong>监听FD并通知的实现方式</strong></p>
<ul>
<li>select<ul>
<li>存在的问题<ul>
<li>需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</li>
<li>select无法得知具体是哪个fd就绪，需要遍历整个fd_set</li>
<li>fd_set监听的fd数量不能超过1024</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203160927812.png" alt="image-20250203160927812"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203164844071.png" alt="image-20250203164844071"></p>
<ul>
<li>poll<ul>
<li>相对于select做了简单改进，但是性能提升不明显</li>
<li>IO流程<ul>
<li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li>
<li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li>
<li>内核遍历fd，判断是否就绪</li>
<li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li>
<li>用户进程判断n是否大于0</li>
<li>大于0则遍历pollfd数组，找到就绪的fd</li>
</ul>
</li>
<li>与select对比<ul>
<li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li>
<li>监听fd越多，每次遍历消耗时间也越久，性能反而会下降</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203171742795.png" alt="image-20250203171742795"></p>
<ul>
<li>epoll <ul>
<li>对select和poll的改进,提供三个函数</li>
<li>优点<ul>
<li>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，并且增删改查效率都非常高，性能不会随监听的FD数量增多而下降</li>
<li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li>
<li>内核会将就绪的FD直接拷贝到用户空间的指定位置，用户进程无需遍历所有FD即可知道就绪的FD</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203175158235.png" alt="image-20250203175158235"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203175211970.png" alt="image-20250203175211970"></p>
<p><strong>差异：</strong></p>
<ul>
<li>select和poll只会通知用户进程有FD就绪，但不确定具体是哪个FD，需要用户进程逐个遍历FD来确认</li>
<li>epoll则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间</li>
</ul>
<h4 id="epoll的事件通知机制"><a href="#epoll的事件通知机制" class="headerlink" title="epoll的事件通知机制"></a>epoll的事件通知机制</h4><p>当FD有数据可读时，调用epoll_wait就可以得到通知，但事件通知的模式有两种</p>
<ul>
<li>LevelTriggered：简称LT，当FD有数据可读时，会重复通知多次，直至数据处理完成，即epoll的默认模式</li>
<li>EdgeTriggered：简称ET，当FD有数据可读时。只会被通知一次，不管数据是否处理完成</li>
<li>结论<ul>
<li>ET模式避免了LT模式可能出现的惊群现象（如果链表不为空，并且有多个线程阻塞在epoll_wait，就会唤醒等待的所有线程）</li>
<li>ET模式最好结合非阻塞IO读取FD数据，相对LT会复杂一些</li>
</ul>
</li>
</ul>
<h4 id="Web服务流程"><a href="#Web服务流程" class="headerlink" title="Web服务流程"></a>Web服务流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：事件类型有连接请求/数据读请求/异常处理</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203195708039.png" alt="image-20250203195708039"></p>
<h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p><strong>Signal Driven IO</strong></p>
<p>与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，发出SIGIO信号通知用户，期间用户应用可执行其它业务，无需阻塞等待</p>
<p><strong>缺点</strong></p>
<ul>
<li>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出</li>
</ul>
<p><strong>流程图</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203200530744.png" alt="image-20250203200530744"></p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p><strong>Asynchronous IO</strong></p>
<p>异步IO的整个过程都是非阻塞的，用户进程调用完异步API就可以做其它事情，内核等待数据就绪并拷贝到用户空间后才会递交信号，通知用户进程</p>
<p><strong>缺点</strong></p>
<ul>
<li>如果不做限流，系统IO处理压力可能过大</li>
<li>如果添加限流，在保证异步IO的情况下代码设计复杂</li>
</ul>
<p><strong>流程图</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250203235451866.png" alt="image-20250203235451866"></p>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>IO操作是同步还是异步，关键看数据在内核空间与用户空间的拷贝过程（数据读写的IO操作）</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204000947573.png" alt="image-20250204000947573"></p>
<p><strong>注意</strong></p>
<ul>
<li>只有异步IO才是真正的异步</li>
<li>IO复用使用最广泛，其次异步IO也有一定使用场景</li>
</ul>
<h3 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h3><p><strong>Redis是单线程还是多线程</strong></p>
<ul>
<li>如果仅先Redis的核心业务部分（命令处理），答案是单线程</li>
<li>如果是说整个Redis，那么答案是多线程<ul>
<li>Redis v4.0引入多线程异步处理一些耗时较长的任务，例如异步删除命令unlink</li>
<li>Redis v6.0在核心网络模型中引入多线程，进一步提高对多核CPU的利用率</li>
</ul>
</li>
</ul>
<p><strong>为什么Redis选择单线程</strong></p>
<ul>
<li>除了持久化操作，Redis是纯内存操作，执行速度非常快，性能瓶颈是网络延迟而不是执行速度，多线程并不会带来巨大的性能提升</li>
<li>多线程会导致过多的上下文切换，带来不必要的开销</li>
<li>引入多线程会面临线程安全问题，必然引入线程锁这种安全手段，实现复杂度增高，且性能大打折扣</li>
</ul>
<p><strong>代码结构</strong></p>
<p>Redis通过IO多路复用来提高网络性能，支持各种不同的多路复用实现，并且封装这些实现，提供统一的高性能事件API库AE，相当于对四个不同实现的再封装</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204040206307.png" alt="image-20250204040206307"></p>
<p><strong>源码分析</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204110355107.png" alt="image-20250204110355107"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204110531314.png" alt="image-20250204110531314"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204223624998.png" alt="image-20250204223624998"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204223524773.png" alt="image-20250204223524773"></p>
<p><strong>Redis单线程网络模型流程</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204214433487.png" alt="image-20250204214433487"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204221602388.png" alt="image-20250204221602388"></p>
<p><strong>Redis多线程网络模型流程</strong></p>
<p>目的是为了提高IO读写效率，因此在解析客户端命令，写响应结果时采用了多线程，核心命令执行、IO多路复用模块依然是主线程来执行</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204222835519.png" alt="image-20250204222835519"></p>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><h3 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h3><p>Redis Serialization Protocol</p>
<p>Redis是一个CS架构的软件，通信分两步（不含pipeline和PubSub）</p>
<ul>
<li>客户端（Client）向服务端（Server）发送一条命令</li>
<li>服务器解析并执行命令，返回响应结果给客户端</li>
</ul>
<p>客户端发送命令的格式，服务端响应结果的格式必须有一个规范，即通信协议</p>
<p>Redis中采用的是RESP协议</p>
<ul>
<li>Redis1.2版本引入了RESP协议</li>
<li>Redis2.0版本中称为与Redis服务端通信的标准，称为RESP2</li>
<li>Redis6.0版本中，从RESP2升级到RESP3协议，增加了更多数据类型，且支持6.0的新特性–客户端缓存</li>
</ul>
<p>目前默认使用的是RESP2协议</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>通过首字节字符来区分不同数据类型</p>
<ul>
<li><p>单行字符串：首字节为’+‘，后面跟上单行字符串，以CRLF（”\r\n“）结尾，字符串中间不能有’\n’</p>
<ul>
<li>例：”+OK\r\n“</li>
</ul>
</li>
<li><p>错误（ERRORS）：首字节为’-‘，与单行字符串格式一样，只是字符串是异常信息</p>
<ul>
<li>例：”-Error msg\r\n“</li>
</ul>
</li>
<li><p>数值：首字节为’:’，后面是数字格式的字符串，以CRLF结尾</p>
<ul>
<li>例：”:10\r\n“</li>
</ul>
</li>
<li><p>多行字符串：首字节是’$’，表示二进制安全的字符串，最大支持512MB，记录字符串长度以保证读取安全性</p>
<ul>
<li>若大小为0，则代表空字符串：”$0\r\n\r\n“</li>
<li>若大小为-1，则代表不存在：”$-1\r\n“</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204225809709.png" alt="image-20250204225809709"></p>
</li>
<li><p>数组：首字节是”*“，后面跟上数组元素个数，再跟上元素，元素的数据类型不限</p>
<ul>
<li>命令的发送以数组为载体</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204230052493.png" alt="image-20250204230052493"></p>
<ul>
<li>数组的嵌套</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204230106868.png" alt="image-20250204230106868"></p>
</li>
</ul>
<h3 id="模拟Redis客户端"><a href="#模拟Redis客户端" class="headerlink" title="模拟Redis客户端"></a>模拟Redis客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要回顾直接看视频吧，就是模拟发送命令的网络请求格式来请求Redis服务器进行简单操作</span><br></pre></td></tr></table></figure>









<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>Redis性能强的主要原因就是基于内存存储，但是单节点的Redis其内存大小不宜过大，可能会影响持久化或主从同步性能</p>
<p>可以通过修改配置文件来设置Redis的最大内存</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204232228373.png" alt="image-20250204232228373"></p>
<p>内存使用达到上限时就无法存储更多数据了</p>
<h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><p>expire命令对Redis的key设置TTL，当TTL到期时，访问key返回nil说明key已经不存在，对应内存也被释放，即内存得到回收</p>
<p><strong>Redis如何知道一个key是否过期</strong></p>
<p><strong>DB结构</strong></p>
<p>Redis本身是一个典型的key-value内存存储数据库，所有key，value都保存在之前学习过的Dict结构中，不过在Database结构体中，有两个Dict，一个用来记录key-value，另一个用来记录key-TTL</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204234054988.png" alt="image-20250204234054988"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204234755441.png" alt="image-20250204234755441"></p>
<p><strong>是不是TTL过期就立即删除</strong></p>
<ul>
<li>惰性删除</li>
</ul>
<p>在访问一个key时，检查该key的存活时间，若已经过期才执行删除</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250204235216752.png" alt="image-20250204235216752"></p>
<ul>
<li><p>周期删除</p>
<ul>
<li>Redis设置一个定时任务serverCron()，按照server.hz的频率来执行过期key清理，模式为SLOW（执行的时间长但是频率低）<ul>
<li>执行频率受server.hz影响，默认为10，每秒执行10次，每个执行周期1000ms</li>
<li>执行清理耗时不超过一次执行周期的25%</li>
<li>逐个遍历DB，逐个遍历DB中的bucket，抽取20个key判断是否过期</li>
<li>若没有达到时间上限（25ms）且过期key比例大于10%，再次进行一次抽样，否则结束</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205000809935.png" alt="image-20250205000809935"></p>
<ul>
<li>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST（执行的时间短但是频率高）<ul>
<li>过期key比例小于10%时不执行</li>
<li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li>
<li>执行清理耗时不超过1ms</li>
<li>逐个遍历DB，逐个遍历DB中的bucket，抽取20个key判断是否过期</li>
<li>若没有达到时间上限（1ms）且过期key比例大于10%，再进行一次抽样，否则结束</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p><strong>内存淘汰</strong></p>
<p>当Redis内存使用达到设置的阈值时，Redis主动挑选部分key删除以释放更多内存的流程</p>
<ul>
<li>Redis在处理客户端命令的方法processCommand()中尝试做内存淘汰</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205180748170.png" alt="image-20250205180748170"></p>
<ul>
<li><p>八种淘汰策略（maxmemory-policy）</p>
<ul>
<li>noeviction：默认策略，不淘汰任何key，但是内存满时不允许写入新数据</li>
<li>volatile-ttl：对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li>
<li>allkeys-random：对全体key，随机进行淘汰，即直接从db-&gt;dict中随机挑选</li>
<li>volatile-random：对设置了TTL的key，随机进行淘汰，即从db-&gt;expires中随机挑选</li>
<li>allkeys-lru：对全体key，基于LRU算法进行淘汰</li>
<li>volatile-lru：对设置了TTL的key，基于LRU算法进行淘汰</li>
<li>allkeys-lfu：对全体key，基于LFU算法进行淘汰</li>
<li>volatile-lfu：对设置了TTL的key，基于LFU进行淘汰</li>
</ul>
<p><code>lru: least recently used，最少最近使用，用当前时间减去最后一次访问时间，该值越大则淘汰优先级越高</code></p>
<p><code>lfu: least frequently used，最少频率使用，会统计每个key的访问频率，值越小淘汰优先级越高</code></p>
</li>
</ul>
<p><strong>淘汰策略具体实现</strong></p>
<ul>
<li>Redis数据被封装为RedisObject结构</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205185421799.png" alt="image-20250205185421799"></p>
<ul>
<li><p>LFU的具体实现</p>
<ul>
<li>访问次数被叫做逻辑访问次数，并非每次访问key都计数，流程详见<ul>
<li>生成0~1之间的随机数R</li>
<li>计算1&#x2F;（旧次数 * lfu_log_factor + 1），记录为P，lfu_log_factor默认为10</li>
<li>若R&lt;P则计数器+1，且最大不超过255</li>
<li>访问次数会随时间衰减，距离上一次访问时间每隔lfu_decay_time分钟（默认1），计数器-1，但是不会小于0</li>
</ul>
</li>
</ul>
</li>
<li><p>淘汰流程</p>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250205192256109.png" alt="image-20250205192256109"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">fleeadango</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/01/12/redis/">http://example.com/2025/01/12/redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">fleeadango-tech-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">开发技术</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/" title="吉林大学计算机网络复习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">吉林大学计算机网络复习笔记</div></div><div class="info-2"><div class="info-item-1">背诵第一章两种描述“因特网”的方式12345678910描述构成因特网的具体构成，基本硬件和软件组件主机/端系统通信链路分组交换机因特网服务提供商 ISP协议Internet standards（因特网工程任务组 IETF/请求评论 RFC）描述为基础设施向分布式应用程序提供的服务。套接字接口    因特网服务提供商 ISP的作用123提供不同种类的网络接入，住宅宽带接入DSL、高速局域网接入、移动无线接入    不同层ISP12345较高层ISP通过高速光纤链路和高速路由器组成；较低层ISP通过国家的、国际的较高层ISP互联到因特网无论高层还是低层ISP都独立管理    网络协议的特点123通信双方交换报文通信实体是设备因特网中两个或多个通信实体的所有活动都受协议的制约    接入网络的类型12345678910111213141516171819202122232425262728293031家庭接入网	宽带住宅接入有两种流行方式：		数字用户线 DSL		use existing telephone line(双绞线) to central...</div></div></div></a><a class="pagination-related" href="/2025/01/21/rabbitMQ/" title="黑马程序员RabbitMQ学习笔记（待更新）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">黑马程序员RabbitMQ学习笔记（待更新）</div></div><div class="info-2"><div class="info-item-1">基础篇同步与异步同步调用1234567优势：时效性强，等待到结果才返回问题：拓展性差性能下降级联失败问题（调用的服务迟迟不响应导致当前服务资源耗尽）    异步调用1234三个角色消息发送者：调用方信息代理：管理、暂存、转发消息消息接收者：服务提供方   12345678910优势：解除耦合，扩展性强无需等待，性能好故障隔离缓存信息，流量的削峰填谷问题：不能立即得到调用结果，时效性差不确定下游业务执行是否成功业务安全依赖于Broker的可靠性        MQ技术选型1存放消息的队列。异步调用中的Broker   123456789ErLang是面向并发的语言RabbitMQ和ActiveMQ连接的微服务可以是其他语言，而RocketMQ只能使用java语言Kafka以吞吐量为优势，但可靠性一般，可以解决大量日志信息部署到日志平台的需求RabbitMQ可靠性强，消息延迟非常短RabbitMQ与RocketMQ使用较多    数据隔离1下面是基础架构   SpringAMQP12345678AMQP Advanced Message Queuing...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/04/30/JDBC/" title="JDBC学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-30</div><div class="info-item-2">JDBC学习笔记</div></div><div class="info-2"><div class="info-item-1">基础篇引言1通过Java程序对数据库中数据做增删改查的需求催生了JDBC的出现    JDBC概念123Java DataBase Connectivityjava提供的一组独立于任何数据库管理系统的API，厂商根据规范提供数据库驱动jar包    核心组成接口规范123保持JAVA代码的一致性接口存储在java.sql和javax.sql包下    实现规范1厂商自行实现，并将内容封装为jar包        快速入门 核心API理解forName123456forName(&quot;com.mysql.cj.jbdc.Driver&quot;)方法也可以替换为forName(new...</div></div></div></a><a class="pagination-related" href="/2025/01/29/JUC/" title="黑马程序员JUC学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-29</div><div class="info-item-2">黑马程序员JUC学习笔记</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/01/29/netty/" title="黑马程序员Netty学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-29</div><div class="info-item-2">黑马程序员Netty学习笔记</div></div><div class="info-2"><div class="info-item-1">认真的 Netty 源码解析（一）本文又是一篇源码分析文章，其实除了 Doug Lea 的并发包源码，我是不太爱写源码分 - 掘金 1没准以后有用  C10K问题解析-CSDN博客 NIO基础non-blocking io...</div></div></div></a><a class="pagination-related" href="/2025/01/21/rabbitMQ/" title="黑马程序员RabbitMQ学习笔记（待更新）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-21</div><div class="info-item-2">黑马程序员RabbitMQ学习笔记（待更新）</div></div><div class="info-2"><div class="info-item-1">基础篇同步与异步同步调用1234567优势：时效性强，等待到结果才返回问题：拓展性差性能下降级联失败问题（调用的服务迟迟不响应导致当前服务资源耗尽）    异步调用1234三个角色消息发送者：调用方信息代理：管理、暂存、转发消息消息接收者：服务提供方   12345678910优势：解除耦合，扩展性强无需等待，性能好故障隔离缓存信息，流量的削峰填谷问题：不能立即得到调用结果，时效性差不确定下游业务执行是否成功业务安全依赖于Broker的可靠性        MQ技术选型1存放消息的队列。异步调用中的Broker   123456789ErLang是面向并发的语言RabbitMQ和ActiveMQ连接的微服务可以是其他语言，而RocketMQ只能使用java语言Kafka以吞吐量为优势，但可靠性一般，可以解决大量日志信息部署到日志平台的需求RabbitMQ可靠性强，消息延迟非常短RabbitMQ与RocketMQ使用较多    数据隔离1下面是基础架构   SpringAMQP12345678AMQP Advanced Message Queuing...</div></div></div></a><a class="pagination-related" href="/2023/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="黑马程序员Mysql学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="info-item-2">黑马程序员Mysql学习笔记</div></div><div class="info-2"><div class="info-item-1">数据库学习笔记基本学习要求![屏幕截图 2023-07-25 092220](C:\Users\THECHOSEN\Desktop\数据库笔记图片\屏幕截图 2023-07-25 092220.png)    基础篇MySQL概述概念1234567数据库是存储数据的仓库，数据有组织的进行存储关系型数据库是建立在关系模型基础上，用多张相互连接的二维表组成的数据库数据库管理系统，操纵和管理数据库的大型软件SQL，操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准    配置并连接1234方法一：打开“服务”，找到MySQL80，将其启动方法二：用系统自带的命令行工具执行指令（需要先配置PATH环境变量，在path内添加一个到mysql server 8.0/bin/的路径）mysql [-h 127.0.0.1] [-p 3306] -u root...</div></div></div></a><a class="pagination-related" href="/2024/11/20/ssm%E6%A1%86%E6%9E%B6/" title="黑马程序员ssm框架学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">黑马程序员ssm框架学习笔记</div></div><div class="info-2"><div class="info-item-1">Spring12345其实是在学习SpringFrameWorkSpring5.0需要jdk8及以上进行支持Spring中的配置学习是为了熟悉原理，而注解的学习是为了简便开发  Spring Framework系统架构 1AOP可以在不影响程序的前提下增强程序的功能  核心容器核心概念（IoC&#x2F;DI）1目的是充分解耦，使用对象时可以直接从IoC容器中获取到绑定好所有依赖关系的bean    IoC12345Inversion of Control...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">fleeadango</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86NoSQL"><span class="toc-number">1.1.</span> <span class="toc-text">认识NoSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94SQL%E5%92%8CNoSQL"><span class="toc-number">1.1.1.</span> <span class="toc-text">对比SQL和NoSQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Redis"><span class="toc-number">1.2.</span> <span class="toc-text">认识Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AERedis"><span class="toc-number">1.2.1.</span> <span class="toc-text">Linux环境安装并配置Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85Redis"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">单机安装Redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Redis客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">Redis数据结构介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.</span> <span class="toc-text">Redis命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">Redis通用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">String类型的常见命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">String类型的三种格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">Hash类型的常见命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">List类型的常见命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">Set类型的常见命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SortedSet%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">SortedSet类型的常见命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.</span> <span class="toc-text">Redis的Java客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis"><span class="toc-number">1.3.1.</span> <span class="toc-text">Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jedis%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Jedis连接池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Data-Redis"><span class="toc-number">1.3.2.</span> <span class="toc-text">Spring Data Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E7%9A%84API%E5%88%86%E7%BB%84"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">基于类型的API分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">序列化方式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">实战篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84"><span class="toc-number">2.1.</span> <span class="toc-text">黑马点评</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">短信登录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">Session共享问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%ABsession%E7%99%BB%E5%BD%95"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">基于Redis实现共享session登录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">登录拦截器的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BB%A3%E6%9B%BFsession%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">Redis代替session要考虑的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.2.</span> <span class="toc-text">商户查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%BC%93%E5%AD%98%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">添加缓存代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.1.2.2.1.</span> <span class="toc-text">主动更新策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.1.2.2.2.</span> <span class="toc-text">缓存更新策略的最佳实践</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%95%86%E9%93%BA%E4%BF%A1%E6%81%AF%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">实现商铺信息缓存与数据库的一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%95%86%E9%93%BA%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">商铺缓存穿透代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.1.2.6.</span> <span class="toc-text">缓存穿透的解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">2.1.2.7.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.2.8.</span> <span class="toc-text">缓存击穿问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.2.9.</span> <span class="toc-text">基于互斥锁解决缓存击穿问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85"><span class="toc-number">2.1.2.10.</span> <span class="toc-text">缓存工具封装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-number">2.1.3.</span> <span class="toc-text">优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">全局唯一ID</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">2.1.3.1.1.</span> <span class="toc-text">全局ID生成器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">实现优惠券秒杀下单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">超卖问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">一人一单修改代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.3.5.</span> <span class="toc-text">集群下的线程安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">2.1.3.6.</span> <span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">2.1.3.7.</span> <span class="toc-text">基于Redis的分布式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">2.1.3.8.</span> <span class="toc-text">基于Redis的分布式锁优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson%E5%A4%9A%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.3.9.</span> <span class="toc-text">Redisson多种分布式锁原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BC%98%E5%8C%96%E7%A7%92%E6%9D%80"><span class="toc-number">2.1.3.10.</span> <span class="toc-text">Redis优化秒杀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80"><span class="toc-number">2.1.3.11.</span> <span class="toc-text">Redis消息队列实现异步秒杀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84Stream%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">2.1.3.12.</span> <span class="toc-text">基于Redis的Stream结构作为消息队列，实现异步秒杀下单</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E7%9A%84%E5%95%86%E6%88%B7"><span class="toc-number">2.1.4.</span> <span class="toc-text">附近的商户</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">GEO数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7%E6%90%9C%E7%B4%A2"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">附近商户搜索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UV%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.1.5.</span> <span class="toc-text">UV统计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HypeLogLog%E7%94%A8%E6%B3%95"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">HypeLogLog用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0UV%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">实现UV统计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0"><span class="toc-number">2.1.6.</span> <span class="toc-text">用户签到</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8"><span class="toc-number">2.1.7.</span> <span class="toc-text">好友关注</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E5%92%8C%E5%8F%96%E5%85%B3"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">关注和取关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="toc-number">2.1.7.2.</span> <span class="toc-text">共同关注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81"><span class="toc-number">2.1.7.3.</span> <span class="toc-text">关注推送</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97"><span class="toc-number">2.1.8.</span> <span class="toc-text">达人探店</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-number">2.1.8.1.</span> <span class="toc-text">发布探店笔记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-number">2.1.8.2.</span> <span class="toc-text">查看探店笔记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E"><span class="toc-number">2.1.8.3.</span> <span class="toc-text">点赞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">2.1.8.4.</span> <span class="toc-text">点赞排行榜</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">高级篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">分布式缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%82%B9Redis%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">单点Redis的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">RDB持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">AOF持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E5%92%8CAOF%E6%AF%94%E8%BE%83"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">RDB和AOF比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E"><span class="toc-number">3.1.3.</span> <span class="toc-text">Redis主从</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">搭建主从架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">主从数据同步原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%93%A8%E5%85%B5"><span class="toc-number">3.1.4.</span> <span class="toc-text">Redis哨兵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">哨兵的作用和原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">搭建哨兵集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RedisTemplate%E7%9A%84%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">RedisTemplate的哨兵模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">3.1.5.</span> <span class="toc-text">Redis分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">搭建分片集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">散列插槽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9"><span class="toc-number">3.1.5.3.</span> <span class="toc-text">集群伸缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">3.1.5.4.</span> <span class="toc-text">故障转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RedisTemplate%E8%AE%BF%E9%97%AE%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">3.1.5.5.</span> <span class="toc-text">RedisTemplate访问分片集群</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.</span> <span class="toc-text">多级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.1.</span> <span class="toc-text">JVM进程缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql%E5%AE%89%E8%A3%85"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">mysql安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NGINX%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">NGINX反向代理配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">本地进程缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Caffeine"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">Caffeine</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">Lua语法入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">变量和循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">条件控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">多级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenResty%E5%AE%89%E8%A3%85"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">OpenResty安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenResty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">OpenResty快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">请求参数处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2Tomcat"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">查询Tomcat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">3.2.3.5.</span> <span class="toc-text">Redis缓存预热</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2Redis%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.3.6.</span> <span class="toc-text">查询Redis缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.3.7.</span> <span class="toc-text">Nginx本地缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.4.</span> <span class="toc-text">缓存同步策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">数据同步策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Canal"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">安装Canal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%ACCanal"><span class="toc-number">3.2.4.3.</span> <span class="toc-text">监听Canal</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.3.</span> <span class="toc-text">Redis最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%94%AE%E5%80%BC%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.1.</span> <span class="toc-text">Redis键值设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E7%9A%84key%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">优雅的key结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%92%E7%BB%9Dbigkey"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">拒绝bigkey</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%B0%E5%BD%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">恰当的数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.2.</span> <span class="toc-text">批处理优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipeline"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">Pipeline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">集群下的批处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.3.</span> <span class="toc-text">服务端优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">持久化配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">慢查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">命令及安全配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.3.4.</span> <span class="toc-text">内存配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.3.4.</span> <span class="toc-text">集群最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E7%AF%87"><span class="toc-number">4.</span> <span class="toc-text">原理篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS"><span class="toc-number">4.1.1.</span> <span class="toc-text">动态字符串SDS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntSet"><span class="toc-number">4.1.2.</span> <span class="toc-text">IntSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dict"><span class="toc-number">4.1.3.</span> <span class="toc-text">Dict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZipList"><span class="toc-number">4.1.4.</span> <span class="toc-text">ZipList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QuickList"><span class="toc-number">4.1.5.</span> <span class="toc-text">QuickList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SkipList"><span class="toc-number">4.1.6.</span> <span class="toc-text">SkipList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedisObject"><span class="toc-number">4.1.7.</span> <span class="toc-text">RedisObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.8.</span> <span class="toc-text">五种数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">4.1.8.1.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List"><span class="toc-number">4.1.8.2.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">4.1.8.3.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ZSet"><span class="toc-number">4.1.8.4.</span> <span class="toc-text">ZSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash"><span class="toc-number">4.1.8.5.</span> <span class="toc-text">Hash</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="toc-number">4.2.1.</span> <span class="toc-text">用户空间和内核空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9EIO"><span class="toc-number">4.2.2.</span> <span class="toc-text">阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">4.2.3.</span> <span class="toc-text">非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">epoll的事件通知机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">Web服务流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="toc-number">4.2.5.</span> <span class="toc-text">信号驱动IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5IO"><span class="toc-number">4.2.6.</span> <span class="toc-text">异步IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">同步和异步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.7.</span> <span class="toc-text">Redis网络模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.3.</span> <span class="toc-text">通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RESP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.3.1.</span> <span class="toc-text">RESP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9FRedis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.3.2.</span> <span class="toc-text">模拟Redis客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">4.4.</span> <span class="toc-text">内存回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">4.4.1.</span> <span class="toc-text">过期策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">4.4.2.</span> <span class="toc-text">淘汰策略</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/29/hello-world/" title="Hello World">Hello World</a><time datetime="2025-05-29T10:41:10.390Z" title="发表于 2025-05-29 18:41:10">2025-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0/" title="左程云算法思想学习笔记——B站视频（待更新）">左程云算法思想学习笔记——B站视频（待更新）</a><time datetime="2025-04-18T14:16:13.000Z" title="发表于 2025-04-18 22:16:13">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/JUC/" title="黑马程序员JUC学习笔记">黑马程序员JUC学习笔记</a><time datetime="2025-01-29T14:14:24.000Z" title="发表于 2025-01-29 22:14:24">2025-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/java%E7%BC%96%E7%A8%8Bapi/" title="Java刷题一些常见的api">Java刷题一些常见的api</a><time datetime="2025-01-29T14:14:24.000Z" title="发表于 2025-01-29 22:14:24">2025-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/netty/" title="黑马程序员Netty学习笔记">黑马程序员Netty学习笔记</a><time datetime="2025-01-29T14:12:24.000Z" title="发表于 2025-01-29 22:12:24">2025-01-29</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By fleeadango</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>