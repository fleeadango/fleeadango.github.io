<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>黑马程序员JUC学习笔记 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程与线程进程1234567程序由指令和数据组成。程序运行时需要使用磁盘网络等设备，进程是用来加载指令，管理内存，管理IO的程序被运行时，磁盘加载这个程序的代码到内存，此时就开启了一个进程进程可视为程序的一个实例，程序可同时运行多个实例进程，也有的程序只能启动一个实例进程          线程1234567一个进程之内可以分为一到多个线程一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序">
<meta property="og:type" content="article">
<meta property="og:title" content="黑马程序员JUC学习笔记">
<meta property="og:url" content="http://example.com/2025/01/29/JUC/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="进程与线程进程1234567程序由指令和数据组成。程序运行时需要使用磁盘网络等设备，进程是用来加载指令，管理内存，管理IO的程序被运行时，磁盘加载这个程序的代码到内存，此时就开启了一个进程进程可视为程序的一个实例，程序可同时运行多个实例进程，也有的程序只能启动一个实例进程          线程1234567一个进程之内可以分为一到多个线程一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-01-29T14:14:24.000Z">
<meta property="article:modified_time" content="2025-05-30T05:16:03.256Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="开发技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "黑马程序员JUC学习笔记",
  "url": "http://example.com/2025/01/29/JUC/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-01-29T14:14:24.000Z",
  "dateModified": "2025-05-30T05:16:03.256Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Doe",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/01/29/JUC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '黑马程序员JUC学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hexo</span></a><a class="nav-page-title" href="/"><span class="site-name">黑马程序员JUC学习笔记</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">黑马程序员JUC学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-29T14:14:24.000Z" title="发表于 2025-01-29 22:14:24">2025-01-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-30T05:16:03.256Z" title="更新于 2025-05-30 13:16:03">2025-05-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">程序由指令和数据组成。</span><br><span class="line"></span><br><span class="line">程序运行时需要使用磁盘网络等设备，进程是用来加载指令，管理内存，管理IO的</span><br><span class="line"></span><br><span class="line">程序被运行时，磁盘加载这个程序的代码到内存，此时就开启了一个进程</span><br><span class="line"></span><br><span class="line">进程可视为程序的一个实例，程序可同时运行多个实例进程，也有的程序只能启动一个实例进程</span><br></pre></td></tr></table></figure>









<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一个进程之内可以分为一到多个线程</span><br><span class="line"></span><br><span class="line">一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行</span><br><span class="line"></span><br><span class="line">Java中，线程作为最小调度单位，进程作为资源分配的最小单位。</span><br><span class="line"></span><br><span class="line">windows中进程不活动，只是线程的容器。</span><br></pre></td></tr></table></figure>









<h2 id="进程与线程对比"><a href="#进程与线程对比" class="headerlink" title="进程与线程对比"></a>进程与线程对比</h2><table>
<thead>
<tr>
<th>对比</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>组成</td>
<td>基本相互独立，拥有共享资源，如内存空间，供内部线程共享</td>
<td>线程存在在进程内，是进程的一个子集</td>
</tr>
<tr>
<td>通信</td>
<td>较为复杂，同一台计算机之间的进程通信称为IPC，不同计算机之间的进程通信，需要通过网络，并且遵守共同的协议</td>
<td>线程通信相对简单，因为它们共享进程内的内存</td>
</tr>
<tr>
<td>开销</td>
<td>上下文切换成本较高</td>
<td>更轻量，上下文切换成本较低</td>
</tr>
</tbody></table>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>单核CPU下，多个线程的执行是<strong>微观串行，宏观并行</strong>的</p>
<p>这种线程轮流使用CPU的做法称为并发：<strong>concurrent</strong>（并发）</p>
<p>多核CPU下，每个核都可以调度运行线程，此时线程是<strong>parallel</strong>（并行的）</p>
<h2 id="多线程效率提升的一些结论"><a href="#多线程效率提升的一些结论" class="headerlink" title="多线程效率提升的一些结论"></a>多线程效率提升的一些结论</h2><ol>
<li>单核CPU下，多线程不能实际提升程序运行效率，只是为了能够在不同的任务之间切换，不同线程<strong>轮流</strong>使用CPU，不会出现<strong>线程饿死</strong>。</li>
<li>多核CPU可以并行跑多个线程，但是只有经过<strong>精心设计的任务拆分</strong>才能在并行执行下提高程序的运行效率，并且不是所有计算任务都能拆分（<strong>阿姆达尔定律</strong>）。同时也不是所有任务都需要拆分，任务如果目的不同，拆分是无意义的</li>
<li>IO操作不占用CPU，但是拷贝文件使用的通常是<strong>阻塞IO</strong>，所以线程需要等待IO结束才能能使用CPU，没有充分利用线程，后面会有<strong>非阻塞IO</strong>和<strong>异步IO</strong>优化</li>
</ol>
<h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><h2 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h2><ul>
<li>直接使用Thread</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//方法实现</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">t.setName(<span class="string">&quot;name&quot;</span>);设置线程名称</span><br><span class="line">t.start();启动线程</span><br></pre></td></tr></table></figure>



<ul>
<li>使用Runable配合Thread</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Runnable接口上有注解@FunctionalInterface，可以用lambda表达式来简化</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda简化</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="comment">//方法实现</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>FutureTask配合Thread</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;name&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">res</span> <span class="operator">=</span> task.get();</span><br></pre></td></tr></table></figure>









<h2 id="Thread与Runnable的关系"><a href="#Thread与Runnable的关系" class="headerlink" title="Thread与Runnable的关系"></a>Thread与Runnable的关系</h2><p>方法一将线程和任务合并在一起</p>
<p>方法二将线程和任务分开了</p>
<p>使用Runnable更容易与<strong>线程池</strong>等高级API配合，且让任务类<strong>脱离了Thread继承体系</strong>，更灵活</p>
<h2 id="查看进程线程的方式"><a href="#查看进程线程的方式" class="headerlink" title="查看进程线程的方式"></a>查看进程线程的方式</h2><p><strong>windows</strong></p>
<ul>
<li>任务管理器可以查看进程和线程数，也能用来杀死进程</li>
<li>tasklist 查看进程</li>
<li>taskkill 杀死进程</li>
</ul>
<p><strong>linux</strong></p>
<ul>
<li>ps -fe 查看所有进程</li>
<li>ps -fT -p <PID> 查看某个进程(PID)的所有线程</li>
<li>kill 杀死进程</li>
<li>top 按大写H切换是否显示线程</li>
<li>top -H -p <PID> 查看某个进程(PID)的所有线程</li>
</ul>
<p><strong>Java</strong></p>
<ul>
<li>jps 查看所有Java进程</li>
<li>jstack <PID> 查看某个Java进程(PID)的所有线程状态</li>
<li>jconsole 可以查看某个Java进程中线程的运行情况(图形界面)</li>
</ul>
<h3 id="jconsole远程监控配置"><a href="#jconsole远程监控配置" class="headerlink" title="jconsole远程监控配置"></a>jconsole远程监控配置</h3><p><strong>在linux上使用</strong></p>
<ul>
<li>运行Java类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=&#x27;ip地址&#x27; -Dcom.sun.management.jmxremote -Dcom.sum.management.jmxremote.port=&#x27;连接端口&#x27; -Dcom.sun.management.jmxremote.ssl=(是否安全连接,true/false) -Dcom.sum.management.jmxremote.authenticate=是否认证java类</span><br></pre></td></tr></table></figure>

<ul>
<li>修改&#x2F;etc&#x2F;hosts文件将127.0.0.1映射到主机名</li>
</ul>
<p> 要认证访问，还要做以下步骤</p>
<ul>
<li>复制 jmxremote.password文件</li>
<li>修改 jmxremote.password和 jmxremote.access文件的权限为600，即文件所有者可读写</li>
<li>连接时填入controlRole（用户名），R&amp;D（密码）</li>
</ul>
<h2 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h2><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>JVM由堆、栈、方法区所组成</p>
<ul>
<li>每个线程启动后，虚拟机会为其分配一块栈内存</li>
<li>每个栈由多个栈帧（Frame）组成，对应每次方法调用时占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应于正在执行的方法。</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250102162739121.png" alt="image-20250102162739121"></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：对多线程程序进行Debug时，如果想要同时看到各线程的运行情况，需要将断点的类型改为Thread</span><br><span class="line"></span><br><span class="line">注意：线程状态处于就绪或运行都显示&quot;Running&quot;</span><br></pre></td></tr></table></figure>

<p>线程的栈内存相互独立</p>
<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>CPU不再执行当前线程，而去执行另一个线程的代码</p>
<ul>
<li>线程的CPU时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了sleep，yield，wait，join，park，synchronized，lock等方法</li>
</ul>
<p>当上下文切换时，操作系统保存<strong>当前线程状态</strong>，恢复<strong>另一个线程状态</strong>，使用线程私有的<strong>PCR</strong>实现</p>
<ul>
<li>状态包括程序计数器，虚拟机栈中每个栈帧的信息（局部变量、操作数栈、返回地址等）</li>
<li>上下文切换频繁发生会影响性能</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td></td>
<td>启动一个新线程，在新的线程运行run方法中代码</td>
<td>让线程进入就绪状态，只有获取到CPU时间片时才能开始运行，单个线程的start方法只能调用一次，否则会出现IllegalThreadStateException异常</td>
</tr>
<tr>
<td>run()</td>
<td></td>
<td>新线程启动后调用的方法</td>
<td>若在构造Thread对象时传递了Runnable参数，则线程启动后会调用Runnable中的run方法，某则默认不执行任何操作，但可以创建Thread的子类对象，来覆盖默认行为</td>
</tr>
<tr>
<td>join()</td>
<td></td>
<td>等待线程运行结束，可以是等待该线程结果</td>
<td></td>
</tr>
<tr>
<td>join(long n)</td>
<td></td>
<td>等待线程运行结束，最多等待n毫秒</td>
<td></td>
</tr>
<tr>
<td>getId()</td>
<td></td>
<td>获取线程长整型的id</td>
<td>id唯一</td>
</tr>
<tr>
<td>getName()</td>
<td></td>
<td>获取线程名</td>
<td></td>
</tr>
<tr>
<td>setName(String)</td>
<td></td>
<td>修改线程名</td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td></td>
<td>获取线程优先级</td>
<td></td>
</tr>
<tr>
<td>setPriority(int)</td>
<td></td>
<td>修改线程优先级</td>
<td>Java中规定线程优先级是1-10的整数，较大的优先级能提高该线程被CPU调度的几率</td>
</tr>
<tr>
<td>getState()</td>
<td></td>
<td>获取线程状态</td>
<td>Java中线程状态是用6个enum表示，分别为：NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED</td>
</tr>
<tr>
<td>isAlive()</td>
<td></td>
<td>线程是否存活（是否运行完毕）</td>
<td></td>
</tr>
<tr>
<td>interrupt()</td>
<td>static</td>
<td>打断线程</td>
<td>如果被打断线程正在sleep，wait，join会使被打断的线程抛出InterruptedException，并清除打断标记，如果打断的正在运行的线程，就会设置打断标记，park的线程被打断，也会设置打断标记</td>
</tr>
<tr>
<td>isInterrupted()</td>
<td></td>
<td>判断是否被打断</td>
<td>不会清除打断标记</td>
</tr>
<tr>
<td>interrupted()</td>
<td>static</td>
<td>判断当前线程是否被打断</td>
<td>会清除打断标记</td>
</tr>
<tr>
<td>currentThread()</td>
<td>static</td>
<td>获取当前正在执行的线程</td>
<td></td>
</tr>
<tr>
<td>sleep(long n)</td>
<td>static</td>
<td>让当前执行的线程休眠n毫秒，休眠时让出CPU的时间片给其它线程</td>
<td></td>
</tr>
<tr>
<td>yield()</td>
<td>static</td>
<td>提示线程调度器让出当前线程对CPU的使用</td>
<td>主要是为了测试和调试</td>
</tr>
</tbody></table>
<h3 id="start和run的比较"><a href="#start和run的比较" class="headerlink" title="start和run的比较"></a>start和run的比较</h3><p>根据线程对象名来调用run方法是在主线程中执行的，即非多线程，相当于是同步执行该方法，而非异步</p>
<p>而根据线程对象名来调用start方法是在该线程中执行的，是多线程异步执行的</p>
<h3 id="sleep和yield的比较"><a href="#sleep和yield的比较" class="headerlink" title="sleep和yield的比较"></a>sleep和yield的比较</h3><p><strong>sleep</strong></p>
<ol>
<li>调用sleep方法，线程从RUNNING状态进入TIMED_WAITING状态（一种阻塞状态）</li>
<li>其它线程可以使用interrupt方法打断正在睡眠的线程，但是会抛出InterruptedException</li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>建议使用TimeUnit的sleep代替Thread的sleep来获得更好的可读性</li>
</ol>
<p><code>java.util.concurrent.TimeUnit</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250207212521267.png" alt="image-20250207212521267"></p>
<p><strong>yield</strong></p>
<ol>
<li>调用yield方法，线程从RUNNING状态进入RUNNABLE状态，从而去调度执行其它同优先级的线程，如果此时没有同优先级的线程，就不能保证让当前线程暂停的效果。</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ol>
<p><strong>两者区别</strong></p>
<ul>
<li>CPU可能将时间片分给RUNNABLE状态的线程，但是不会分配给阻塞的TIMED_WAITING状态下的线程</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1-10</span><br><span class="line"></span><br><span class="line">默认优先级是5</span><br></pre></td></tr></table></figure>

<ul>
<li>线程优先级提示调度器优先调度该线程，但仅仅是一个提示，调度器可以忽略</li>
<li>CPU较忙时优先级高的线程会获得更多时间片，但是CPU闲时优先级几乎没啥用</li>
</ul>
<h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>如果是限时join，当等待的时间小于实际运行时间时，join方法不会继续等待。</p>
<p>如果等待的时间大于实际运行时间，join方法实际等待的时间将与实际运行时间相符。</p>
<h3 id="interrupt方法详解"><a href="#interrupt方法详解" class="headerlink" title="interrupt方法详解"></a>interrupt方法详解</h3><p><strong>打断标记可以用来判断线程被打断后会继续运行或者就此终止</strong></p>
<p><strong>打断状态可以用来停止线程</strong></p>
<p><strong>打断sleep,wait,join的线程</strong></p>
<p>即阻塞状态的线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意；join的底层原理其实就是wait</span><br><span class="line"></span><br><span class="line">打断sleep/wait/join的线程，会清空打断状态</span><br></pre></td></tr></table></figure>



<p><strong>打断正常运行的线程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打断正常运行的线程，不会清空打断状态</span><br></pre></td></tr></table></figure>



<p><strong>打断park线程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是LockSupport中的一个方法，目的也是停止当前线程</span><br><span class="line"></span><br><span class="line">注意：如果打断标记已经为true，park会失效，即再次执行park无法停止当前线程</span><br></pre></td></tr></table></figure>







<h3 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h3><p>不推荐使用，容易破坏同步代码块，造成死锁</p>
<p>suspend和resume由现在的wait和notify代替</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>stop()</td>
<td></td>
<td>停止线程运行</td>
</tr>
<tr>
<td>suspend()</td>
<td></td>
<td>挂起（暂停）线程运行</td>
</tr>
<tr>
<td>resume()</td>
<td></td>
<td>恢复线程运行</td>
</tr>
</tbody></table>
<h3 id="主线程与守护线程"><a href="#主线程与守护线程" class="headerlink" title="主线程与守护线程"></a>主线程与守护线程</h3><p>默认情况下，Java进程要等待所有线程都运行结束，才会结束，但对于守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.setDaemon(true);</span><br></pre></td></tr></table></figure>

<ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat中的Acceptor和Poller线程都是守护线程，Tomcat接收到shutdown命令后，不会等待它们处理完当前请求</li>
</ul>
<h2 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h2><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250103140716422.png" alt="image-20250103140716422"></p>
<ul>
<li><strong>初始状态</strong>：仅在语言层面创建了线程对象，未与操作系统线程关联</li>
<li><strong>可运行状态</strong>：该线程已经被创建，与操作系统线程关联，可以由CPU调度执行</li>
<li><strong>运行状态</strong>：获取了CPU时间片运行中的状态，当CPU时间片用完，会从<strong>运行状态</strong>转换至<strong>可运行状态</strong>，导致线程的上下文切换</li>
<li><strong>阻塞状态</strong>：调用了阻塞API，线程不使用CPU，上下文切换，进入阻塞状态。与可运行状态不同，阻塞状态的线程只要不唤醒，调度器就一直不会考虑调度它们。</li>
<li><strong>终止状态</strong>：表示线程已经执行完毕，声明周期已经结束，不会再转换为其它状态。</li>
</ul>
<h2 id="六种状态"><a href="#六种状态" class="headerlink" title="六种状态"></a>六种状态</h2><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250103141004317.png" alt="image-20250103141004317"></p>
<ul>
<li><p>NEW：线程刚被创建，但还没调用start()方法</p>
</li>
<li><p>RUNNABLE当调用了start()方法之后，注意Java API层面的RUNNABLE状态涵盖了操作系统层面的<strong>可运行状态</strong>，<strong>运行状态</strong>和<strong>阻塞状态</strong>（Java无法区分BIO导致的阻塞，仍认为是可运行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：idea中debug工具对RUNNABLE显示的是RUNNING</span><br></pre></td></tr></table></figure>
</li>
<li><p>BLOCKED,WAITTING,TIMED_WAITING都是Java API层面对<strong>阻塞状态</strong>的细分。</p>
</li>
<li><p>TERMINATED：当线程代码运行结束</p>
</li>
</ul>
<p><strong>状态转换的细致分析</strong></p>
<p>现有线程t</p>
<ul>
<li><p>NEW &#x3D;&#x3D;&gt; RUNNABLE</p>
<ul>
<li>调用t.start()方法</li>
</ul>
</li>
<li><p>RUNNABLE &lt;&#x3D;&#x3D;&gt; WAITING</p>
<p><strong>情况一</strong></p>
<ul>
<li><p>t线程使用synchronized(obj)获取对象锁后</p>
</li>
<li><p>调用obj.wait()方法，t线程RUNNABLE &#x3D;&#x3D;&gt; WAITING</p>
</li>
<li><p>调用obj.notify()方法，obj.notifyAll()方法，t.interrupt()方法</p>
<ul>
<li>若竞争锁成功，t线程WAITING &#x3D;&#x3D;&gt; RUNNABLE</li>
<li>若竞争锁失败，t线程WAITING &#x3D;&#x3D;&gt; BLOCKED</li>
</ul>
</li>
</ul>
<p><strong>情况二</strong></p>
<ul>
<li>当前线程调用t.join()方法时，当前线程RUNNABLE &#x3D;&#x3D;&gt; WAITING，在t线程对象的监视器上等待</li>
<li>t线程运行结束，或调用了当前线程Interrupt()方法时，当前线程WAITING &#x3D;&#x3D;&gt; RUNNABLE</li>
</ul>
<p><strong>情况三</strong></p>
<ul>
<li>当前线程调用LockSupport.park()方法可以时当前线程RUNNABLE &#x3D;&#x3D;&gt; WAITING</li>
<li>调用LockSupport.unpark(目标线程)或调用了线程的Interrupt()方法，会让目标线程WAITING &#x3D;&#x3D;&gt; RUNNABLE</li>
</ul>
</li>
<li><p>RUNNABLE &lt;&#x3D;&#x3D;&gt; TIMED_WAITING</p>
<p><strong>情况一</strong></p>
<ul>
<li>t线程调用synchronized(obj)获取对象锁后</li>
<li>调用obj.wait(long n)时，t线程RUNNABLE &#x3D;&#x3D;&gt; TIMED_WAITING</li>
<li>t线程等待时间超过n毫秒，或调用obj.notify()，obj.notifyAll()，t.interrupt()时<ul>
<li>若竞争锁成功，t线程TIMED_WAITING &#x3D;&#x3D;&gt; RUNNABLE</li>
<li>若竞争锁失败，t线程TIMED_WAITING &#x3D;&#x3D;&gt; BLOCKED</li>
</ul>
</li>
</ul>
<p><strong>情况二</strong></p>
<ul>
<li>当前线程调用t.join(long n)方法时，当前线程RUNNABLE &#x3D;&#x3D;&gt; TIMED_WAITING，当前线程在t线程对象的监视器上等待</li>
<li>当前线程等待时间超过了n毫秒，或t线程运行结束，或调用了当前线程的interrupt()时，当前线程TIMED_WAITING &#x3D;&#x3D;&gt; RUNNABLE</li>
</ul>
<p><strong>情况三</strong></p>
<ul>
<li>当前线程调用Thread.sleep(long n)，当前线程RUNNABLE &#x3D;&#x3D;&gt; TIMED_WAITING</li>
<li>当前线程等待时间超过n毫秒，当前线程TIMED_WAITING &#x3D;&#x3D;&gt; RUNNABLE</li>
</ul>
<p><strong>情况四</strong></p>
<ul>
<li>当前线程调用LockSupport.parkNanos(long nanos)或LockSupport.parkUntil(long millis)，当前线程RUNNABLE &#x3D;&#x3D;&gt; TIMED_WAITING</li>
<li>调用LockSupport.unpark(目标线程)或调用线程的interrupt()，或是等待超时，会让目标线程TIMED_WAITING &#x3D;&#x3D;&gt; RUNNABLE</li>
</ul>
</li>
<li><p>RUNNABLE &lt;&#x3D;&#x3D;&gt; BLOCKED</p>
<ul>
<li>t线程用synchronized(obj)获取对象锁<ul>
<li>若竞争失败，t线程RUNNABLE &#x3D;&#x3D;&gt; BLOCKED</li>
<li>持有obj锁线程的同步代码块执行完毕，唤醒对象上所有BLOCKED的线程重新竞争，若t线程竞争成功，从BLOCKED &#x3D;&#x3D;&gt; RUNNABLE，其它失败线程仍然BLOCKED</li>
</ul>
</li>
</ul>
</li>
<li><p>RUNNABLE &lt;&#x3D;&#x3D;&gt; TERMINATED</p>
<ul>
<li>当前线程所有代码运行完毕</li>
</ul>
</li>
</ul>
<h1 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h1><h2 id="共享问题"><a href="#共享问题" class="headerlink" title="共享问题"></a>共享问题</h2><p>单个程序运行多个线程本身没有问题</p>
<p>问题出在多个线程访问共享资源时发生指令交错</p>
<ul>
<li>临界区（Critical Section）：含有对共享资源的多线程读写操作的代码块</li>
<li>竞态条件（Race Condition）：多个线程在临界区内执行，由于代码执行序列不同而导致结果无法预测</li>
</ul>
<h2 id="syncronized解决方案"><a href="#syncronized解决方案" class="headerlink" title="syncronized解决方案"></a>syncronized解决方案</h2><p>synchronized实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换打断</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(共享对象)&#123;</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>









<h2 id="方法上的syncronized"><a href="#方法上的syncronized" class="headerlink" title="方法上的syncronized"></a>方法上的syncronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非静态方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="线程八锁问题"><a href="#线程八锁问题" class="headerlink" title="线程八锁问题"></a>线程八锁问题</h2><ul>
<li>起到隔离作用，锁定的是对象本身</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208103701823.png" alt="image-20250208103701823"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果为12</span><br><span class="line">或者21</span><br></pre></td></tr></table></figure>

<ul>
<li>起到隔离作用，锁定的是对象本身</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208103818486.png" alt="image-20250208103818486"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果是2，一秒后1</span><br><span class="line">或者一秒后12</span><br></pre></td></tr></table></figure>

<ul>
<li>只对ab方法隔离，锁定对象本身</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208104045754.png" alt="image-20250208104045754"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果是32/23，一秒后1</span><br><span class="line">或者3,一秒后12</span><br></pre></td></tr></table></figure>

<ul>
<li>分别对两个对象进行锁定</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208110513171.png" alt="image-20250208110513171"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果为2，一秒后1</span><br></pre></td></tr></table></figure>

<ul>
<li>一个锁定当前类，一个锁定类对象</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208111346173.png" alt="image-20250208111346173"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果为2，一秒后1</span><br></pre></td></tr></table></figure>

<ul>
<li>两个均锁定当前类</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208112218995.png" alt="image-20250208112218995"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果为一秒后12</span><br><span class="line">或者2，一秒后1</span><br></pre></td></tr></table></figure>

<ul>
<li>一个锁定当前类，一个锁定类对象</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208120820278.png" alt="image-20250208120820278"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果为2，一秒后1</span><br><span class="line">锁的对象不一样</span><br></pre></td></tr></table></figure>

<ul>
<li>均锁定类对象</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208121553245.png" alt="image-20250208121553245"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果为一秒后12</span><br><span class="line">或者2，一秒后1</span><br></pre></td></tr></table></figure>





<h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><p><strong>成员变量和静态变量</strong></p>
<ul>
<li>如果未共享，则线程安全</li>
<li>若共享，只有读操作时线程安全，而如果有读写操作，则代码是临界区，要考虑线程安全</li>
</ul>
<p><strong>局部变量</strong></p>
<ul>
<li>局部变量是线程安全的</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208123133316.png" alt="image-20250208123133316"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208123007935.png" alt="image-20250208123007935"></p>
<ul>
<li><p>局部变量引用的对象若没有超出方法的作用访问就是线程安全的，若逃离方法的作用范围，就需要考虑线程安全。</p>
<ul>
<li>将ArrayList变为局部变量</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208122816313.png" alt="image-20250208122816313"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208122825590.png" alt="image-20250208122825590"></p>
<ul>
<li>为ThreadSafe创建一个子类</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208123711250.png" alt="image-20250208123711250"></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类的行为无法控制，尽量在方法上添加final防止子类重写</span><br></pre></td></tr></table></figure>







<h3 id="final和private提供线程安全性"><a href="#final和private提供线程安全性" class="headerlink" title="final和private提供线程安全性"></a>final和private提供线程安全性</h3><p>如果父类中方法为public类型，则可能出现线程冲突，这里需要父类方法为private类型，并且可以将公有方法设为final以防止子类覆写引起线程问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*final*/</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++)&#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>(<span class="keyword">private</span>) <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>(<span class="keyword">private</span>) <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title class_">ThreadSafe</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; List)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="常见的线程安全类"><a href="#常见的线程安全类" class="headerlink" title="常见的线程安全类"></a>常见的线程安全类</h3><ul>
<li>String</li>
<li>Integer</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String和Integer都是不可变类，其内部的状态不可以改变，故方法都是线程安全的</span><br><span class="line"></span><br><span class="line">String中的replace、substring等方法是通过创建一个新的对象来实现的 </span><br></pre></td></tr></table></figure>

<ul>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种线程安全的map，HashMap并不是线程安全的类</span><br></pre></td></tr></table></figure>

<ul>
<li>java.util.concurrent包下的类</li>
</ul>
<p><strong>为什么说是线程安全的</strong></p>
<ul>
<li>多个线程调用下面类同一个实例的某个方法时，是线程安全的</li>
<li>即它们的每个方法是原子的，但是多个方法的组合不是原子的</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>线程安全对象的判断</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208125323372.png" alt="image-20250208125323372"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n/y/y/n/n</span><br><span class="line">可能需要解释是第五个，虽然添加了final，但只是限制了D2的引用对象不能改变，其中的年月日还是可以改变的</span><br></pre></td></tr></table></figure>

<ul>
<li>局部变量的线程安全性</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208125450628.png" alt="image-20250208125450628"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n/n</span><br><span class="line">均不满足线程安全</span><br></pre></td></tr></table></figure>

<ul>
<li>Spring中的对象</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208125604137.png" alt="image-20250208125604137"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n</span><br><span class="line">Spring中的对象都是单例的，即被共享。解决方案就是将start通过环绕通知等方案变为局部变量</span><br></pre></td></tr></table></figure>

<ul>
<li>典型业务代码的线程安全性</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208125902742.png" alt="image-20250208125902742"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y/y/y</span><br><span class="line">userService中的成员变量是私有的，且没有能改变其成员变量的方法，所以也是线程安全的</span><br><span class="line">userDao虽然不是局部变量，被作为单例类中的成员而参与共享，但是它其中没有可以修改的内部成员变量，和String和Integer这样的不可变类相似</span><br><span class="line">update方法中均为局部变量</span><br></pre></td></tr></table></figure>

<ul>
<li>数据库访问代码</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208130549284.png" alt="image-20250208130549284"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n/n/n</span><br><span class="line"></span><br><span class="line">conn是共享变量，且可能会出现一个线程获取到conn，另一个线程就调用了conn.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>数据库访问代码</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208131813089.png" alt="image-20250208131813089"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y/y/y</span><br><span class="line">每个线程调用update方法都创建一个新的userDao对象，其中的conn不会被共享，所以可以满足线程安全</span><br></pre></td></tr></table></figure>

<ul>
<li>外星方法对线程安全的影响</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208132923495.png" alt="image-20250208132923495"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208133006476.png" alt="image-20250208133006476"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n</span><br><span class="line">foo的行为不确定，可能导致线程不安全</span><br></pre></td></tr></table></figure>

<p>部分抽象方法的行为不确定，可能导致不安全的发生，被称为外星方法，String类为了保证线程安全就在类定义上添加了final</p>
<h2 id="Monitor概念"><a href="#Monitor概念" class="headerlink" title="Monitor概念"></a>Monitor概念</h2><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>Java对象在内存中通常是由Java对象头和Java成员变量组成</p>
<p><strong>普通对象</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250103204056215.png" alt="image-20250103204056215"></p>
<ul>
<li>Klass Word是一个指向该对象所从属的类对象的指针</li>
</ul>
<p><strong>数组对象</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250103204113654.png" alt="image-20250103204113654"></p>
<p><strong>Mark Word结构</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250103204226877.png" alt="image-20250103204226877"></p>
<ul>
<li><p>hashcode：对象的哈希值</p>
</li>
<li><p>age：垃圾回收的分代年龄</p>
</li>
<li><p>biased_lock：是否是偏向锁</p>
</li>
<li><p>2bit的标记位</p>
<ul>
<li>Normal无锁状态下为01</li>
<li>Heavyweight Locked有锁状态下转为10，并且MarkWord的其它部分转换成指向Monitor的指针</li>
</ul>
</li>
</ul>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">监视器或管程，Java中syncronized锁底层的原理</span><br></pre></td></tr></table></figure>

<p>每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁，对象头中的MarkWord中就被设置指向Monitor对象的指针</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250103210021372.png" alt="image-20250103210021372"></p>
<ul>
<li>synchronized必须是进入同一个对象的monitor才有上述的效果</li>
<li>不加synchronized的对象不会关联监视器，不遵从以上规则</li>
<li>流程<ul>
<li>开始Monitor中Owner为null</li>
<li>某个Thread执行syncronized(obj)就会将Monitor的Owner置为该Thread</li>
<li>当某个Thread持有锁时，其它Thread执行syncronized(obj)，就会进入EntryList阻塞状态</li>
<li>当持有锁的Thread释放锁后，会唤醒EntryList中等待的线程竞争锁，竞争结果并非一定是处于等待队列最前端的线程</li>
<li>处于WaitSet的线程是之前获得过锁，但是条件不满足进入WAITING状态的线程</li>
</ul>
</li>
</ul>
<h3 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简单synchronized程序对应的字节码如下</span><br><span class="line"></span><br><span class="line">异常表是表示在某个范围之间出现异常后跳转执行的代码行</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208161817479.png" alt="image-20250208161817479"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250103213328415.png" alt="image-20250103213328415"></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h4><ul>
<li><p>当一个对象虽然有多线程访问，但是多线程访问时间是错开的，即无竞争，就可以用轻量级锁来优化</p>
</li>
<li><p>对使用者透明，语法仍是synchronized</p>
</li>
</ul>
<p><strong>创建流程</strong></p>
<ul>
<li>在线程的栈帧中创建锁记录（Lock Record）对象<ul>
<li>锁记录是JVM层面的</li>
<li>锁记录中可以存储对象的Mark Word</li>
<li>锁记录中可以存储对象的指针</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208165240598.png" alt="image-20250208165240598"></p>
<ul>
<li><p>让锁记录中的Object Reference指向锁对象，并且尝试用CAS交换Object的Mark Word，将Mark Word的值存入锁记录</p>
<ul>
<li>如果CAS交换成功，即成功添加了轻量级锁，对象头中存储锁记录地址和状态00</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208172535547.png" alt="image-20250208172535547"></p>
<ul>
<li><p>两种情况下CAS会失败</p>
<ul>
<li>其它线程已经持有了该Object的轻量级锁，出现竞争，进入锁膨胀过程</li>
<li>若当前线程自己执行了synchronized锁重入，就再添加一条Lock Record作为重入的计数，加入的新LR无需存储对象的MarkWord</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208172850323.png" alt="image-20250208172850323"></p>
</li>
</ul>
</li>
<li><p>当退出synchronized代码块时</p>
<ul>
<li>若由取值为null的锁记录，表示有重入，重置锁记录，表示重入计数减一</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208173229602.png" alt="image-20250208173229602"></p>
<ul>
<li>若锁记录值不为null，此时使用CAS将MarkWord的值恢复给对象<ul>
<li>成功就解锁成功</li>
<li>失败说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>当尝试加轻量级锁的过程中，CAS操作无法成功，有一种情况就是其它线程为该对象加上了轻量级锁，即出现竞争，此时需要进行锁膨胀，将轻量级锁变为重量级锁</p>
<p><strong>流程详解</strong></p>
<ul>
<li>当t1进行轻量级加锁时，t0已经对该对象加了轻量级锁</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208173902951.png" alt="image-20250208173902951"></p>
<ul>
<li><p>此时t1加锁失败，进入锁膨胀</p>
<ul>
<li>为Object对象申请Monitor锁，让Object指向重量级锁地址</li>
<li>然后自己进入Monitor的EntryList BLOCKED</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208174426194.png" alt="image-20250208174426194"></p>
</li>
<li><p>当t0退出同步块解锁时，使用CAS将Mark Word的值恢复给对象头，失败</p>
</li>
<li><p>此时进入重量级解锁流程，根据Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中BLOCKED线程</p>
</li>
</ul>
<h4 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h4><p>重量级锁竞争时，还可以使用自旋进行优化，若当前线程自旋成功（即此时持锁线程已经退出同步块，释放了锁），这时当前线程就可以避免阻塞</p>
<p>自旋是一种获取锁的思想，不管是轻量级锁还是重量级锁</p>
<p>上下文切换是比较消耗资源的，所以采用自旋进行优化</p>
<p><strong>自旋尝试成功的情况</strong></p>
<ul>
<li>自旋要使用CPU，所以适于多核CPU下进行</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208180048393.png" alt="image-20250208180048393"></p>
<p><strong>自旋尝试失败的情况</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208180201413.png" alt="image-20250208180201413"></p>
<p><strong>一些注意</strong></p>
<ul>
<li>在Java6之后自旋锁是自适应的<ul>
<li>比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，能够多自旋几次</li>
<li>反之就少自旋，或者不自旋</li>
</ul>
</li>
<li>自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU才能发挥又是</li>
<li>Java7之后不能控制是否开启自旋功能</li>
</ul>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁在没有竞争时，每次重入仍然需要执行CAS操作</p>
<p>Java6中引入了偏向锁做进一步优化，只有第一次使用CAS线程将线程ID设置到对象的Mark Word头，之后发现该线程ID是自己的就表示无竞争，不用重新CAS，只要不竞争，该对象就归该线程所有</p>
<h5 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h5><p><strong>tips</strong></p>
<ul>
<li>偏向锁不能计算hash值，只要计算hash值就会发生锁升级，因为hashcode占用了部分线程ID的空间，所以就不能再维持偏向锁状态</li>
<li>Java15中，偏向锁默认关闭，对于使用了新类库的 Java 应用来说，偏向锁带来的收益已不如过去那么明显，而且在当下多线程应用越来越普遍的情况下，偏向锁带来的锁升级操作反而会影响应用的性能。</li>
<li>Java18中，偏向锁已经被彻底废弃，无法通过命令打开</li>
</ul>
<p><strong>一个对象创建时</strong></p>
<ul>
<li>若开启偏向锁（默认开启），对象创建后，markword值为0x05，即后三位为101，其thread，epoch，age均为0</li>
<li>偏向锁默认存在延迟，不会在程序启动时立即生效</li>
<li>如果想要避免延迟，可以添加VM参数<code>-XX :BiasedLockingStartupDelay=0</code>来禁用延迟</li>
<li>若没有开启偏向锁，在对象创建后，markword值为0x01，最后三位为001，此时它的hashcode，age均为0，第一次用到hashcode时才会赋值</li>
<li>可以使用<code>-XX:-UseBiasedLocking</code>禁用偏向锁</li>
</ul>
<h5 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h5><ul>
<li><p><strong>调用对象hashCode</strong>：调用对象hashCode，但是偏向锁的对象MarkWord中存储的是线程id，若调用hashCode会导致偏向锁被撤销</p>
<ul>
<li>轻量级锁会在锁记录中记录hashCode</li>
<li>重量级锁会在Monitor中记录hashCode</li>
</ul>
</li>
<li><p><strong>其它线程使用对象</strong>：当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
</li>
<li><p><strong>调用wait&#x2F;notify</strong>：只有重量级锁才能使用wait&#x2F;notify操作，所以偏向锁或者轻量级锁都会升级成为重量级锁</p>
</li>
</ul>
<h5 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h5><p>如果对象虽然被多个线程访问，但没有竞争，此时偏向了t1的对象仍会有机会重新偏向t2，冲偏向会重置对象的Thread ID</p>
<p>当撤销偏向锁阈值超过20次后，JVM会思考自己是不是出现了偏向错误，就会再给这些对象加锁时重新偏向至加锁线程</p>
<h5 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h5><p>若撤销偏向锁阈值超过40次，即一个类的所有对象中出现了40个偏向撤销的对象实例，JVM就会觉得自己确实偏向错了，根本就不该偏向，整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>当多个方法重复调用锁syncronized，可以看做在该锁中依次进行这个方法的执行</p>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>JIT（Just In Time）即时编译器，对JVM进行即时优化操作，当出现加锁对象并非是共享对象，就会发生锁消除，对热点代码进行即时编译，提高代码编译速度</p>
<p>控制是否打开锁消除的JVM参数为<code>-XX:-EliminateLocks</code></p>
<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait&#x2F;notify"></a>wait&#x2F;notify</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208194743358.png" alt="image-20250208194743358"></p>
<p><strong>流程详解</strong></p>
<ul>
<li>Owner线程发现条件不满足，调用wait方法，即可进入WaitSet变为WAITING状态</li>
<li>BLOCKED和WAITING的线程均处于阻塞状态，不占用CPU时间片</li>
<li>BLOCKED线程在Owner线程释放锁时被唤醒</li>
<li>WAITING线程会Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味着立刻获得锁，仍需要进入EntryList重新竞争</li>
</ul>
<h3 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h3><ul>
<li>obj.wait()：让进入object的Monitor的线程到waitSet等待，无限期等待，直到等到notify位置<ul>
<li>相当于wait(0)</li>
</ul>
</li>
<li>obj.wait(n)：有时限的等待，到n毫秒后结束等待，或被notify<ul>
<li>wait(timeout, nano)相当于wait(timeout+1)</li>
</ul>
</li>
<li>obj.notify()：让object上正在waitSet等待的线程中挑一个唤醒，该选择是任意的，由JVM决定，如hotspot虚拟机是进行顺序唤醒</li>
<li>obj.notifyAll()：让object上正在waitSet等待的线程全部唤醒，可以避免虚假唤醒，使得当前满足的条件无法通知到该通知的线程</li>
</ul>
<p>这些都是线程之间进行写作的手段，均属于object对象的方法，必须要获取该对象的锁才能调用</p>
<p><strong>sleep(long n)和wait(long n)的区别</strong></p>
<p><code>状态都是TIMED_WAITING</code></p>
<ul>
<li>sleep是Thread的静态方法；而wait是Object的方法，即所有对象都有的方法</li>
<li>sleep不需要强制和synchronized配合使用；但是wait需要和synchronized一起使用</li>
<li>sleep调用后，是不会释放对象锁的；但是wait在等待的时候会释放对象锁</li>
</ul>
<h3 id="一个比较成熟的wait-notify方案"><a href="#一个比较成熟的wait-notify方案" class="headerlink" title="一个比较成熟的wait&#x2F;notify方案"></a>一个比较成熟的wait&#x2F;notify方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	<span class="keyword">while</span>(条件不成立)&#123;</span><br><span class="line">		lock.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="join的原理"><a href="#join的原理" class="headerlink" title="join的原理"></a>join的原理</h3><p><strong>与保护性暂停的区别</strong></p>
<ul>
<li>保护性暂停是一个线程等待另一个线程的结果，join是一个线程等待另一个线程的结束</li>
</ul>
<p><strong>源码分析</strong></p>
<p>底层与保护性暂停是及其相似的，同样会处理超时</p>
<p>join()：无参时相当于join(0)，永久等待直至线程结束</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208222808599.png" alt="image-20250208222808599"></p>
<h2 id="Park-Unpark"><a href="#Park-Unpark" class="headerlink" title="Park&#x2F;Unpark"></a>Park&#x2F;Unpark</h2><p>均为LockSupport类中的方法</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>每个线程都有自己的一个Parker对象，由<code>_counter, _cond, _mutex</code>组成</p>
<p>流程</p>
<ul>
<li><p>先调用park再调用unpark</p>
<ul>
<li>当前线程调用park方法，检查<code>_counter</code>为0，此时获得<code>_mutex</code>互斥锁，线程进入<code>_cond</code>条件变量阻塞，设置<code>_counter</code>为0</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209115519290.png" alt="image-20250209115519290"></p>
<ul>
<li>再调用unpark(<code>Thread_0</code>)方法，设置<code>_counter</code>为1，唤醒<code>_cond</code>条件变量中的<code>Thread_0</code>，<code>Thread_0</code>恢复运行，设置<code>_counter</code>为0</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209115902461.png" alt="image-20250209115902461"></p>
</li>
<li><p>先调用unpark再调用park</p>
<ul>
<li>调用unpark(<code>Thread_0</code>)方法，设置<code>_counter</code>为1，当前线程调用park()方法，检查<code>_counter</code>，当前为1，此时线程无需阻塞，继续运行，设置<code>_counter</code>为0</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209120552191.png" alt="image-20250209120552191"></p>
</li>
</ul>
<h3 id="API介绍-1"><a href="#API介绍-1" class="headerlink" title="API介绍"></a>API介绍</h3><ul>
<li>LockSupport.park()：暂停当前线程</li>
<li>LockSupport.unpark(暂停线程对象)：恢复某个线程的运行</li>
</ul>
<h3 id="与wait-notify相比"><a href="#与wait-notify相比" class="headerlink" title="与wait&amp;notify相比"></a>与wait&amp;notify相比</h3><ul>
<li><p>wait，notify和notifyAll必须配合Object Monitor一起使用，而unpark不必</p>
</li>
<li><p>park&amp;unpark是以线程为单位来阻塞和唤醒线程，而notify只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，不那么精确</p>
</li>
<li><p>unpark既可以在park前调用，也可以在park之后调用</p>
<p>park()方法不会释放锁资源，只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。</p>
</li>
</ul>
<p><strong>一些补充</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tong-yuan/p/11768904.html">面试 LockSupport.park()会释放锁资源吗？ - 彤哥读源码 - 博客园</a></p>
<h2 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h2><p><strong>细化锁的粒度的利弊</strong></p>
<ul>
<li>好处是可以增强并发度</li>
<li>坏处是如果一个线程需要同时获得多吧锁，容易发生死锁</li>
</ul>
<h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个或多个线程中的每个线程都在等待另外的线程释放资源，导致所有的线程都无法执行，相互等待。</p>
<h3 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h3><p><strong>检测死锁</strong></p>
<ul>
<li>可以使用jconsole（基于图形界面）工具</li>
<li>或者使用jps定位进程id，再用jstack（基于命令行）定位死锁</li>
</ul>
<p><strong>解决死锁的方式</strong></p>
<ul>
<li>顺序加锁<ul>
<li>实例：t0, t1两个线程，t0获取A，t1获取B，然后t0尝试获取B，t12尝试获取A，改进为同时都先试图获取A，然后得到A的再试图获取B，即可解决</li>
</ul>
</li>
</ul>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>出现在两个线程互相改变对方的结束条件，最后谁也无法结束</p>
<p><strong>解决方案</strong></p>
<ul>
<li>使产生活锁的多个线程交错执行</li>
</ul>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个线程由于优先级过低，或者始终等待不到某个资源，使得其不能被CPU调度执行，使得其产生的结果已经不能用于呢</p>
<p>解决死锁的顺序加锁有可能会引起线程饥饿问题</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><strong>相较于synchronized的特点</strong></p>
<p>与synchronized一样都支持可重入</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量，即有多个不同的WaitSet</li>
</ul>
<p><strong>基本语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁，放在try块内外都可以</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>同一个线程如果首次获得了这把锁，应为它是这把锁的拥有者，所以有权利再次获取该锁</p>
<p>若是不可重入锁，则一个线程不能重复获取其已经获取的锁</p>
<h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p>当前线程在等待锁的过程中，其它线程可以用interrupt方法终止当前线程的等待</p>
<p>前提被打断的锁调用的获取锁的方法是lockInterruptibly()</p>
<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p><strong>tryLock方法</strong></p>
<ul>
<li>无参数：获取不到锁立即放弃</li>
<li>有时间参数，等待一段时间后如果还不能成功获取锁即放弃</li>
</ul>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p><strong>一些补充</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/115543000">面试官：说一下公平锁和非公平锁的区别？ - 知乎</a></p>
<p><strong>公平锁和非公平锁比较</strong></p>
<p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p>
<ul>
<li>优点：所有的线程都能得到资源，不会饿死在队列中。</li>
<li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li>
</ul>
<p>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p>
<ul>
<li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，可能有的线程减少了等待时间，提高了利用率。CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li>
<li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li>
</ul>
<p>基于Monitor的锁是不公平的锁：当一个线程获取到锁时，其它的线程就只能进入阻塞队列进行等待，若信道</p>
<p>ReentrantLock默认也是不公平的，而如果选择公平锁，即在阻塞队列的线程维持先进先获取锁的顺序</p>
<p><strong>源码实现</strong></p>
<ul>
<li>fair &#x3D; true时<ul>
<li>new FairSync()</li>
</ul>
</li>
<li>fair &#x3D; false时<ul>
<li>new NonfairSync</li>
</ul>
</li>
</ul>
<p>公平锁一般没有必要，会降低并发度</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p><strong>ReentrantLock与synchronized的比较</strong></p>
<ul>
<li>ReentrantLock支持多个条件变量</li>
</ul>
<p><strong>使用流程</strong></p>
<ul>
<li>线程先获取锁</li>
<li>执行await()方法，释放锁，进入conditionObject等待</li>
<li>await的线程被唤醒（或打断，或超时），重新竞争lock锁</li>
<li>竞争lock锁成功后，从await后继续执行</li>
</ul>
<p><strong>API介绍</strong></p>
<ul>
<li>awaitSignal.newCondition()：创建一个新的条件变量</li>
<li>condition.await()：当前线程调用，等待condition</li>
<li>condition.signal()：叫醒一个需要当前condition的线程</li>
<li>condition.signalAll()：叫醒所有需要当前condition的线程</li>
</ul>
<h1 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h1><p>上一章Monitor主要关注的是访问共享变量时临界区代码的原子性</p>
<h2 id="JAVA内存模型"><a href="#JAVA内存模型" class="headerlink" title="JAVA内存模型"></a>JAVA内存模型</h2><p>JMM，即Java Memory Model</p>
<p>定义了主存、工作内存等抽象概念</p>
<p>底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等</p>
<p><strong>JMM体现在以下方面</strong></p>
<ul>
<li>原子性：保证指令不会收到线程上下文切换的影响</li>
<li>可见性：保证指令不会受CPU缓存的影响</li>
<li>有序性：保证指令不会受CPU指令并行优化的影响</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><ul>
<li>下面代码中是否可以实现修改run让线程t停止运行</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209181912635.png" alt="image-20250209181912635"></p>
<ul>
<li>初始状态，t线程从主内存读取run的值到工作内存</li>
</ul>
<p><code>主内存保存共享变量，工作内存保存各线程的私有变量</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209182055658.png" alt="image-20250209182055658"></p>
<ul>
<li>JIT编译器检测到t线程频繁地从驻内存中读取run的值，所以将run的值缓存到自己工作内存的高速cache中，以减少对主存中run的访问，提高效率</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209182414353.png" alt="image-20250209182414353"></p>
<ul>
<li>后续虽然主线程修改run的值，且同步至主内存，t线程仍然从自己的高速Cache中读取该变量，所以不会退出while循环</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209182541312.png" alt="image-20250209182541312"></p>
<ul>
<li><p>解决方案</p>
<ul>
<li>volatile修饰run</li>
<li>引入synchronized</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209184301246.png" alt="image-20250209184301246"></p>
</li>
<li><p>两种方案的比较</p>
<ul>
<li>synchronized要创建Monitor，属于比较重量的操作</li>
<li>volatile相对更轻量</li>
<li>在while()循环中加入一个打印语句（println()方法底层的write()方法使用了synchronized(this)锁住了当前对象，是原子方法，会清空工作内存）</li>
</ul>
</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>易变关键字</p>
<p>可以用来修饰成员变量和静态成员变量，可以避免线程从自己的工作缓存中查找变量的值，必须到主内存中获取，线程操作volatile变量都是直接操作主存</p>
<h3 id="可见性vs原子性"><a href="#可见性vs原子性" class="headerlink" title="可见性vs原子性"></a>可见性vs原子性</h3><ul>
<li>满足可见性不一定满足原子性，只能保证线程看到的是读取时的最新值，而不能解决指令交错的问题</li>
<li>synchronized两者均可满足，但是操作比较重</li>
<li>volatile仅在单个写线程，多个读线程时才能同时满足两者</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>JVM会在不影响正确性的前提下，可以调整语句的执行顺序。</p>
<h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><p>现代处理器设计为一个始终周期完成一条执行时间最长的CPU指令</p>
<p>指令重排序能够优化</p>
<p>每条指令还可以分为五个阶段</p>
<ul>
<li>取指令 instruction fetch</li>
<li>指令译码 instruction decode</li>
<li>执行指令 execute</li>
<li>内存访问 memory access</li>
<li>数据写回 register write back</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209195521157.png" alt="image-20250209195521157"></p>
<p>在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来进行指令级并行</p>
<p><code>一个实例在05011</code></p>
<p>在某个变量上加volatile修饰，可以添加一层写屏障，防止对该变量修改语句前面的语句重排序到该语句后</p>
<h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代CPU支持多级指令流水线</p>
<p>可以同时执行以上五个阶段的处理器成为五级指令流水线，这样CPU可以在一个时钟周期内同时运行五条指令的不同阶段，相当于一条执行时间最长的复杂指令</p>
<p>本质上，流水线计数并不能缩短单挑指令的执行时间，但是变相地提高了指令的吞吐率</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209205403714.png" alt="image-20250209205403714"></p>
<h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>volatile的底层实现原理是内存屏障 Memory Barrier</p>
<ul>
<li>对volatile变量的写指令后会加入写屏障</li>
<li>对volatile变量的读指令前会加入读屏障</li>
</ul>
<h4 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h4><p>写屏障（sfence）保证在该屏障之前的，对于共享变量的改动都同步到主存当中</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209214827224.png" alt="image-20250209214827224"></p>
<p>而读屏障保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209214908747.png" alt="image-20250209214908747"></p>
<h4 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h4><p>写屏障会确保指令重排序时，不会讲写屏障之前的代码排在写屏障之后</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209215235689.png" alt="image-20250209215235689"></p>
<p>读屏障会确保指令重排序时，不会将读屏障以后的代码排在读屏障前</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209215250375.png" alt="image-20250209215250375"></p>
<p><strong>不能解决指令交错</strong></p>
<ul>
<li>写屏障仅仅是保证之后的读能读到最新的结果，但是不能保证读跑到屏障前面</li>
<li>而有序性的保证也是仅保证了本线程内相关代码不被重排序</li>
</ul>
<h4 id="double-checked-locking问题"><a href="#double-checked-locking问题" class="headerlink" title="double-checked locking问题"></a>double-checked locking问题</h4><p><strong>实例：单例模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">					INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//懒惰实例化</span></span><br><span class="line"><span class="comment">//首次使用getInstance()才使用synchronized加锁，后续无需加锁</span></span><br><span class="line"><span class="comment">//隐含且关键的一点是，第一个if使用了INSTANCE变量，是在同步块之外使用的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在多线程下上述的实现实际是错误的</li>
<li>getInstance方法对应的字节码如下</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209224052678.png" alt="image-20250209224052678"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209225008402.png" alt="image-20250209225008402"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209224634503.png" alt="image-20250209224634503"></p>
<ul>
<li><p>t2可能拿到一个还没有初始化完毕的单例！</p>
</li>
<li><p>对INSTANCE使用volatile修饰即可，可以禁用指令重排，但注意在JDK5以上的版本的volatile才能真正有效</p>
</li>
<li><p>补充一个注意：只要将一个对象完全交给syncronized管理，就不会出现原子，有序，可见性的问题</p>
</li>
</ul>
<h4 id="double-checked-locking解决"><a href="#double-checked-locking解决" class="headerlink" title="double-checked locking解决"></a>double-checked locking解决</h4><ul>
<li>为什么用volatile修饰INSTANCE就可以解决问题呢，从字节码上看不出volatile的效果，但是可以从读写屏障分析</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209230352308.png" alt="image-20250209230352308"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209230426031.png" alt="image-20250209230426031"></p>
<ul>
<li>写屏障使得21必须在24之前执行</li>
</ul>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before规定了对共享变量的写操作，对其他线程的读操作可见</p>
<p>是可见性与有序性的一套规则总结</p>
<p>抛开以下happens-before规则，JMM并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p>
<p><strong>具体规则</strong></p>
<ul>
<li>线程解锁m之前对变量的写，对于接下来对m加锁的其它线程对该变量的读可见</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210124900024.png" alt="image-20250210124900024"></p>
<ul>
<li>线程对volatile变量的写，对接下来其它线程对该变量的读可见</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210124946436.png" alt="image-20250210124946436"></p>
<ul>
<li>线程开始前对变量的写，对该线程开始后对变量的读可见</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210125100625.png" alt="image-20250210125100625"></p>
<ul>
<li>线程结束前对线程的写，对其它线程得知它结束后的读可见（比如其它线程调用isAlive()或t.join()等待它结束）</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210125257872.png" alt="image-20250210125257872"></p>
<ul>
<li>线程t1打断t2（Interrupt）前对变量的写，对于其它线程得知t2被打断后对变量的读可见（通过t2.interrupted或t2.isInterrupted）</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210125440896.png" alt="image-20250210125440896"></p>
<ul>
<li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p>
</li>
<li><p>具有传递性，如果x hb&#x3D;&gt; y并且y hb&#x3D;&gt; z，则有x hb&#x3D;&gt; z</p>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210125812279.png" alt="image-20250210125812279"></p>
<h2 id="线程安全实例习题"><a href="#线程安全实例习题" class="headerlink" title="线程安全实例习题"></a>线程安全实例习题</h2><p><strong>实例一</strong>（饿汉单例）</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210130320251.png" alt="image-20250210130320251"></p>
<ol>
<li><p>final防止子类不适当地覆盖父类中的方法，破坏了单例</p>
</li>
<li><p>在类中添加方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能，反射可以得到constructor构造器，设置构造器对象的setAceessible为true，就可以暴力反射得到实例</p>
</li>
<li><p>能保证线程安全，静态成员变量的初始化操作是在类加载的阶段完成的，类加载阶段对这些成员变量进行赋值都是线程安全的。由JVM保证线程安全性</p>
</li>
<li><p>可以增加代码扩展性，后续方便修改成懒惰单例。还可以提供泛型的支持。可以在创建单例对象时提供更多的支持</p>
</li>
</ol>
<p><strong>实例二</strong>（枚举单例）</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210132017232.png" alt="image-20250210132017232"></p>
<ol>
<li>定义时有几个，使用时就有几个</li>
<li>没有，同样是静态成员变量，在类加载阶段初始化，由JVM保证其线程安全性</li>
<li>不会被反射破坏单例</li>
<li>不会被反序列化破坏单例</li>
<li>饿汉式</li>
<li>给枚举类中添加构造方法即可</li>
</ol>
<p><strong>实例三</strong>（懒汉单例）</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210135631902.png" alt="image-20250210135631902"></p>
<ul>
<li>性能比较低，因为后面每次想要获取duixiangdouxuyo</li>
</ul>
<p><strong>实例四（DCL懒汉单例）</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210142426808.png" alt="image-20250210142426808"></p>
<ol>
<li>防止在synchronized块中重排序</li>
<li>后续调用getInstance时不需要重复加锁</li>
<li>防止并发访问下单例对象不被重复创建</li>
</ol>
<p><strong>实例五</strong>（静态内部类实现懒汉式单例）</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210143406677.png" alt="image-20250210143406677"></p>
<ol>
<li>属于懒汉式，静态变量只有在调用方法时才被初始化</li>
<li>由JVM保证了线程安全性</li>
</ol>
<h1 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h1><p><strong>引入实例</strong></p>
<ul>
<li>加锁实现保护共享资源</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210180348673.png" alt="image-20250210180348673"></p>
<ul>
<li>无锁实现保护共享资源</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210181121221.png" alt="image-20250210181121221"></p>
<h2 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h2><p>Compare And Swap</p>
<p><strong>注意</strong></p>
<ul>
<li><p>AtomicInteger内部并没有用锁来保护共享变量的线程安全</p>
</li>
<li><p>底层是X86架构中的lock cmpxchg指令，在单核CPU和多核CPU下都能够保证CAS的原子性</p>
</li>
<li><p>多核状态下，某核执行到带lock的指令时，CPU就会让总线锁住，当这个核把此指令执行完毕再开启总线，这个过程中不会被线程调度机制打断，保证了多个线程对内存操作的准确性，是原子的</p>
</li>
</ul>
<p><strong>关于volatile</strong></p>
<ul>
<li>获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰</li>
<li>线程操作volatile变量必须直接操作主存，一个线程对该变量的修改对其它线程是可见的</li>
<li>CAS必须借助volatile才能读取到共享变量的最新值来实现功能</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210183311815.png" alt="image-20250210183311815"></p>
<p><strong>为什么无锁效率高</strong></p>
<ul>
<li>无锁状态下，即使重试失败，线程仍在运行，而syncronized会让线程没有获取锁时发生上下文切换进入阻塞，上下文切换代价较大</li>
<li>但是无锁状态下，线程保持运行需要额外CPU支持，虽然不会阻塞，但是由于没有时间片可用，仍然会进入可运行状态</li>
<li>线程数尽量要大于CPU核心数</li>
</ul>
<p><strong>CAS特点</strong></p>
<p>结合CAS和volatile可以实现无锁并发，适用于线程数少，多核CPU的场景</p>
<ul>
<li>CAS基于乐观锁的思想，假设其他线程不会修改共享变量</li>
<li>synchronized基于悲观锁的思想，假设其他线程会修改共享变量</li>
<li>CAS体现的是无锁并发，无阻塞并发<ul>
<li>没有使用synchronized就不会陷入阻塞，提升效率</li>
<li>若竞争激烈重试会频繁发生，反而效率受影响</li>
</ul>
</li>
</ul>
<h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p>JUC提供</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<p><code>AtomicInteger</code>常用 API 包括</p>
<p>其它两个类的API大致相似，所以只用此类做示范</p>
<ol>
<li><p><strong><code>get()</code></strong><br> 获取当前值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaint value = atomicInteger.get();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>set(int newValue)</code></strong><br> 设置新的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaatomicInteger.set(10);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>getAndSet(int newValue)</code></strong><br> 获取当前值并设置为新的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaint oldValue = atomicInteger.getAndSet(20);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>incrementAndGet()</code></strong><br> 将当前值加1并返回新值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaint newValue = atomicInteger.incrementAndGet();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>getAndIncrement()</code></strong><br> 获取当前值并将值加1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaint oldValue = atomicInteger.getAndIncrement();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>decrementAndGet()</code></strong><br> 将当前值减1并返回新值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaint newValue = atomicInteger.decrementAndGet();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>getAndDecrement()</code></strong><br> 获取当前值并将值减1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaint oldValue = atomicInteger.getAndDecrement();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>addAndGet(int)</code></strong><br> 将当前值加上指定的增量并返回新值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaint newValue = atomicInteger.addAndGet(5);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>getAndAdd(int)</code></strong><br> 获取当前值并将指定增量加到当前值上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaint oldValue = atomicInteger.getAndAdd(5);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>compareAndSet(int expect, int update)</code></strong><br> 如果当前值等于预期值，则将当前值设置为更新值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaboolean success = atomicInteger.compareAndSet(10, 20);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>weakCompareAndSet(int expect, int update)</code></strong><br> 类似于 <code>compareAndSet()</code>，但不是原子的，常用于高效处理一些并发场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaboolean success = atomicInteger.weakCompareAndSet(10, 20);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
<p><strong>ABA问题</strong></p>
<p>实例：t1线程将A修改为C，t2线程A先将A修改为B，再将B修改为A。如果t2线程在t1线程运行期间运行，使用AtomicReference维护共享变量，t1线程无法察觉字符实际已经被修改过，会将字符成功修改为C</p>
<p><strong>ABA解决方式</strong></p>
<p>不能仅比较值，还要比较版本号</p>
<ul>
<li>使用AtomicStampedReference，每次更改版本号都加一</li>
</ul>
<p>有时并不需要知道修改了几次，而是只需要知道是否更改过</p>
<ul>
<li>使用AtomicMarkableReference，维护一个Boolean值</li>
</ul>
<h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><ul>
<li><p>AtomicIntgerArray</p>
</li>
<li><p>AtomicLongArray</p>
</li>
<li><p>AtomicReferenceArray</p>
</li>
<li><p>Supplier</p>
<ul>
<li>提供者</li>
<li>() -&gt;结果</li>
</ul>
</li>
<li><p>Function</p>
<ul>
<li>单参数函数</li>
<li>(参数)-&gt;结果</li>
</ul>
</li>
<li><p>BiFunction</p>
<ul>
<li>双参数函数</li>
<li>(参数1，参数2)-&gt;结果</li>
</ul>
</li>
<li><p>Consumer</p>
<ul>
<li>单参数消费者</li>
<li>(参数)-&gt;void</li>
</ul>
</li>
<li><p>BiConsumer</p>
<ul>
<li>双参数消费者</li>
<li>(参数，参数)-&gt;void</li>
</ul>
</li>
</ul>
<h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><ul>
<li>AtomicReferenceFieldUpdater</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
</ul>
<p>利用字段更新器，可以针对对象某个域进行原子操作，只能在用public volatile修饰的字段使用，否则出现异常</p>
<h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><p>效率较原子整数的累加效率高</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210211758931.png" alt="image-20250210211758931"></p>
<ul>
<li>Supplier<ul>
<li>提供累加器对象</li>
<li>() -&gt; 结果</li>
</ul>
</li>
<li>Consumer<ul>
<li>执行累加造作</li>
<li>(参数) -&gt;</li>
</ul>
</li>
</ul>
<p><strong>性能提升的原因</strong></p>
<p>再有竞争时，设置多个累加单元，Thread[i]累加cell[i]，最后将结果汇总，所以在累加时操作不同的cell变量，减少了CAS重试失败，从而提高性能，核心数越高性能提升越明显</p>
<h2 id="LongAdder源码"><a href="#LongAdder源码" class="headerlink" title="LongAdder源码"></a>LongAdder源码</h2><p><strong>几个关键域</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210212936339.png" alt="image-20250210212936339"></p>
<p><strong>Cas锁仿源码实现</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210213556447.png" alt="image-20250210213556447"></p>
<h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p>Cell为累加单元</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210214002868.png" alt="image-20250210214002868"></p>
<p><strong>从缓存角度分析</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210214109211.png" alt="image-20250210214109211"></p>
<ul>
<li>缓存以缓存行为单位，每个缓存行对应一块内存，一般是64byte</li>
<li>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中</li>
<li>CPU为保证数据的一致性，如果某个CPU核心更改数据，其它CPU核心对应的整个缓存行必须失效</li>
</ul>
<p><strong>累加单元内存中结构模拟</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210214934808.png" alt="image-20250210214934808"></p>
<ul>
<li>一个Cell为24byte，所以一个缓存行可以存储两个Cell对象，当CPU1对Cell1修改，CPU2对Cell2修改时，相当于两个CPU缓存的两个缓存行都会失效</li>
<li>@sun.misc.Contended可以解决这个问题，原理是在使用此出街的对象或字段的前后各增加128字节大小的padding，从而让CPU将对象预读至缓存时占用不同的缓存行，这样，就不会造成对方缓存行失效</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210220351680.png" alt="image-20250210220351680"></p>
<p><strong>add源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210220439648.png" alt="image-20250210220439648"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210221111775.png" alt="image-20250210221111775"></p>
<ul>
<li>cell数组懒惰初始化</li>
</ul>
<p><strong>longAccmulate源码</strong></p>
<ul>
<li>cells未创建</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210221235684.png" alt="image-20250210221235684"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210221227650.png" alt="image-20250210221227650"></p>
<ul>
<li>cell未创建</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210222904348.png" alt="image-20250210222904348"></p>
<ul>
<li>cell已创建</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250210223108741.png" alt="image-20250210223108741"></p>
<p><strong>sum源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211001535128.png" alt="image-20250211001535128"></p>
<p>LongAdder 在低并发情况下其实和 AtomicLong一样，使用 base 记录 value值，但是在高并发下就不一样，在高并发下，LongAdder 采用分散热点 的方式，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><ul>
<li>Unsafe对象提供非常底层，操作内存、线程的方法，Unsafe对象不能直接调用，只能通过反射获得</li>
<li>单例类</li>
<li>之所以说是Unsafe，是指该类直接操作内存，线程，不建议程序员直接调用</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211001957513.png" alt="image-20250211001957513"></p>
<p><strong>CAS相关方法</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211094205104.png" alt="image-20250211094205104"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211094227690.png" alt="image-20250211094227690"></p>
<p><strong>原子整数类模拟实现</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211094702132.png" alt="image-20250211094702132"></p>
<p><strong>参考博客</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/aetawt/article/details/128103592">深入解析：Java并发利器LongAdder与LongAccumulator性能优化-CSDN博客</a></p>
<h1 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h1><h2 id="日期转换的问题"><a href="#日期转换的问题" class="headerlink" title="日期转换的问题"></a>日期转换的问题</h2><p><strong>同步锁</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211095316088.png" alt="image-20250211095316088"></p>
<p>SimpleDateFormat在多线程并发访问下存在问题</p>
<p><strong>不可变</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211095824670.png" alt="image-20250211095824670"></p>
<p>SimpleDateFormat加锁可以在多线程并发下使用</p>
<p>DateTimeFormatter是一个不可变且线程安全的类，可以在是</p>
<h2 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h2><p>以String类为例</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211101851180.png" alt="image-20250211101851180"></p>
<ul>
<li><p>final：该类及类中所有属性都是final的</p>
<ul>
<li>属性用final修饰确保了该属性只读，不能修改</li>
<li>类用final修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li>
<li>hash值是在首次调用hashcode时计算得出，没有暴露给外界修改的接口，所以不会被修改</li>
</ul>
</li>
<li><p>保护性拷贝：创建副本对象来避免共享的手段</p>
<ul>
<li>初始化构造函数时如果传参为char数组，即对char数组进行深拷贝出一个String对象</li>
<li>substring方法，内部调用String的构造方法创建了一个新字符串</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211105511143.png" alt="image-20250211105511143"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211105624776.png" alt="image-20250211105624776"></p>
</li>
</ul>
<h2 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h2><h3 id="设置final变量的原理"><a href="#设置final变量的原理" class="headerlink" title="设置final变量的原理"></a>设置final变量的原理</h3><p>理解volatile原理，理解final实现就比较简单</p>
<p><strong>字节码实现</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211123303069.png" alt="image-20250211123303069"></p>
<p>final变量的赋值通过putfield指令来完成，这条指令之后也会加入写屏障，保证在其它线程对他的值可见</p>
<p><strong>写final域的重排序规则</strong></p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障，该屏障禁止处理器把final域的写重排序到构造函数之外</li>
<li>对引用类型，写final域的重排序对编译器和处理器增加了以下约束：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作不能重排序</li>
</ul>
<p><strong>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障</strong></p>
<h3 id="获取final变量的原理"><a href="#获取final变量的原理" class="headerlink" title="获取final变量的原理"></a>获取final变量的原理</h3><p>加入final后通过LDC（读取常量池）或BIPUSH（栈替换）来替代getstatic。</p>
<p><strong>读final域的重排序规则</strong></p>
<ul>
<li>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作，编译器会在读final域操作的前面插入一个LoadLoad屏障</li>
<li>对于引用类型，在原规则基础上，额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后讲这个被构造的对象的引用赋值给引用变量重排序</li>
</ul>
<p><strong>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用</strong>。</p>
<p><strong>对于引用对象，可以确保其它线程至少能看到写线程在构造函数中对final引用对象的成员域的写入</strong></p>
<h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>成员变量保存的数据也可以成为状态信息，因此没有成员变量就称之为无状态</p>
<p>Servlet为保证线程安全，不设置成员变量，这样没有任何成员变量的类是线程安全的</p>
<h1 id="共享模型之工具"><a href="#共享模型之工具" class="headerlink" title="共享模型之工具"></a>共享模型之工具</h1><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211190424777.png" alt="image-20250211190424777"></p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>ThreadPoolExecutor使用int的高3位来表示线程池状态，低29位表示线程数量</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211190923215.png" alt="image-20250211190923215"></p>
<p>这些信息存储在一个原子变量ctl中，目的是将线程池状态与线程个数合二为一，这样就可以用一次CAS原子操作进行赋值</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211192442484.png" alt="image-20250211192442484"></p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params"><span class="type">int</span> maximumPoolsize,</span></span><br><span class="line"><span class="params"><span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">TimeUnit unit,</span></span><br><span class="line"><span class="params">BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize：核心线程数目（最多保留的线程数）</li>
<li>maximumPoolsize：最大线程数目，核心+救急</li>
<li>keepAliveTime：生存时间，针对救济线程</li>
<li>unit：时间单位，针对救急线程</li>
<li>workQueue：阻塞队列</li>
<li>threadFactory：线程工厂，可以明明线程</li>
<li>handler：拒绝策略</li>
</ul>
<p><strong>线程池使用顺序</strong></p>
<ul>
<li><p>初始无线程，当有任务提交到线程池，创建一个新线程来执行任务</p>
</li>
<li><p>当线程数达到corePoolSize且无线程空闲，此时提交到线程池的任务会被加入workQueue队列，直至有空闲线程</p>
</li>
<li><p>若队列选择有界队列，当任务超出队列大小时，创建maximumPoolsize - corePoolSize数目的线程来救急</p>
</li>
<li><p>若线程到达maximumPoolsize仍有新任务，此时执行拒绝策略，JDK提供四种实现，还有其它著名框架提供实现</p>
<ul>
<li>AbortPolicy：让调用者抛出RejectedExecutionException异常，<strong>默认策略</strong></li>
<li>CallerRunPolicy：让调用者运行任务</li>
<li>DiscardPolicy：放弃本次任务</li>
<li>DiscardOldestPolicy：放弃队列中最早的任务，使用当前任务取代</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211195031353.png" alt="image-20250211195031353"></p>
<ul>
<li>Dubbo的实现：抛出RejectedExecutionException异常之前会记录日志，并dump线程栈信息，方便定位问题</li>
<li>Netty的实现，是创建一个新线程来执行任务</li>
<li>ActiveMQ的实现，带超时等待（60s）尝试放入队列，类似之前自定义的拒绝策略</li>
<li>PinPoint的实现，使用一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul>
</li>
<li><p>高峰过去后，超过corePoolSize的救急线程若一段时间没有任务，结束节省资源，这个时间由keepAliveTime和unit来控制</p>
</li>
</ul>
<p><strong>根据构造方法，JDK Executors类中提供众多工厂方法来创建各种用途的线程池</strong></p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads,</span><br><span class="line">	nThreads.</span><br><span class="line">	<span class="number">0L</span>,</span><br><span class="line">	TimeUnit.MILLISECONDS,</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<ul>
<li>核心线程数即最大线程数，无需超时时间</li>
<li>阻塞队列无界，可以存放任意数量的任务</li>
<li>适用于任务量已知，相对耗时的任务</li>
</ul>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">	<span class="number">60L</span>,</span><br><span class="line">	TimeUnit.SECONDS,</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<ul>
<li><p>核心线程数为0，最大线程数是Integer.MAX_VALUE，救急线程的空闲生存时间是60s</p>
<ul>
<li>全部都是救急线程（60s后可回收）</li>
<li>救急线程可以无限创建</li>
</ul>
</li>
<li><p>队列采用了SynchronousQueue，实现特点是没有容量，没有线程来取是放不进去的</p>
</li>
<li><p>整个线程池表现为线程数会根据任务量不断增长，无上限，当任务执行完毕，空闲一分钟后释放线程</p>
</li>
<li><p>适合任务数比较密集，但每个任务执行时间较短的情况</p>
</li>
</ul>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor()&#123;</span><br><span class="line">	return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1,</span><br><span class="line">	1,</span><br><span class="line">	0L,</span><br><span class="line">	TimeUnit.MILLISECONDS,</span><br><span class="line">	new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>希望多个任务排队执行，线程数固定为1，任务数多于1时，会放入无界队列排队，任务执行完毕，唯一的线程也不会释放</li>
</ul>
<p><strong>与自己创建的线程的区别</strong></p>
<ul>
<li>自己创建一个单线程串行执行任务，若任务执行失败而终止，不会有任何补救措施。而线程池还会新建一个线程，保证池的正常工作</li>
<li>Executors.newFixedThreadExecutor()线程个数始终为1，不能修改<ul>
<li>Fin</li>
</ul>
</li>
</ul>
<p><strong>与前面其它线程池的区别</strong></p>
<ul>
<li>Executors.newSingleThreadExecutor()线程个数始终未1，不能修改<ul>
<li>FinalizableDelegatedExecutorService应用的是装饰器模式，只对外暴露ExecutorService接口，因此不能调用ThreadPoolExecutor中特有的方法</li>
<li>Executors.newFixedThreadPool(1)初始化为1，后期还可以修改<ul>
<li>对外暴露的是ThreadPoolExecutor对象，可以墙砖后调用setCorePoolSize等方法进行修改</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p><strong>相关API</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211214844598.png" alt="image-20250211214844598"></p>
<ul>
<li>submit</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211221950951.png" alt="image-20250211221950951"></p>
<ul>
<li>invokeAll</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211222142194.png" alt="image-20250211222142194"></p>
<ul>
<li>invokeAny</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211223653154.png" alt="image-20250211223653154"></p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p><strong>shutdown</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211224125851.png" alt="image-20250211224125851"></p>
<ul>
<li>在shutdown前提交的任务都会等待其运行结束再终结线程池</li>
<li>而在shutdown调用后提交的任务就不会等待了</li>
<li>调用shutdown的线程不会因shutdown运行而阻塞，如果想要等待，可以调用awaitTermination()，但实际等待的时间是shutdown方法执行的时间，适用于需要执行回调操作的场景</li>
</ul>
<p><strong>shutdownNow</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211224528964.png" alt="image-20250211224528964"></p>
<p><strong>其它方法</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211224754104.png" alt="image-20250211224754104"></p>
<h3 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h3><p><strong>ScheduleExecutorService</strong></p>
<p>在该功能加入之前，可以使用java.util.Timer来实现定时功能，Timer的优点在于简单易用，但所有的任务均由同一个线程调度，导致所有任务都是串行执行的，同一时间只能有一个任务执行，单一任务延迟或异常都会影响到之后的任务</p>
<p><strong>Timer示例</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212012723146.png" alt="image-20250212012723146"></p>
<p><strong>ScheduleExecutorService示例</strong></p>
<ul>
<li>延时任务</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212014801652.png" alt="image-20250212014801652"></p>
<ul>
<li>定时任务<ul>
<li>第一个方法中的period是指相邻两次任务开始执行的时间的间隔，但实际会和单词&#x3D;次任务实际执行的时间有关，即前一次任务执行完毕才会执行下一次任务</li>
<li>第二个方法中的period是指当一次任务执行完毕后距离下次执行的时间间隔</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212015308066.png" alt="image-20250212015308066"></p>
<p><strong>正确处理线程池异常</strong></p>
<ul>
<li>直接用try - catch块手动处理</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212020409173.png" alt="image-20250212020409173"></p>
<ul>
<li>使用submit配合Future类，返回的Future对象会携带异常信息</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212020326507.png" alt="image-20250212020326507"></p>
<h3 id="Tomcat线程池"><a href="#Tomcat线程池" class="headerlink" title="Tomcat线程池"></a>Tomcat线程池</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212021929231.png" alt="image-20250212021929231"></p>
<ul>
<li>LimitLatch用来限流，可以控制最大连接个数，类似JUC中的Semaphore</li>
<li>Acceptor只负责接受新的socket连接</li>
<li>Poller只负责监听socket channel是否有可读的IO时间，一旦可读，封装一个任务对象（socketProcessor），提交给Executor线程池处理</li>
<li>Executor线程池中的工作线程最终负责处理请求，该线程池与java中线程池功能相仿</li>
</ul>
<p>Tomcat线程池扩展ThreadPoolExecutor，行为稍有不同</p>
<ul>
<li>若总线程数达到maximumPoolSize<ul>
<li>不会立刻抛出RejectedExecutionException异常</li>
<li>而是再次尝试将任务放入队列，若还失败，再抛出异常</li>
</ul>
</li>
</ul>
<p><strong>execute方法源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212023111315.png" alt="image-20250212023111315"></p>
<p><strong>force方法</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212023350152.png" alt="image-20250212023350152"></p>
<p><strong>Connector配置</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212102833947.png" alt="image-20250212102833947"></p>
<ul>
<li>若声明了executor，则会覆盖上面的核心线程数和最大线程数两个参数</li>
</ul>
<p><strong>Executor线程配置</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212102901477.png" alt="image-20250212102901477"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212103442662.png" alt="image-20250212103442662"></p>
<h2 id="Fork-Join线程池"><a href="#Fork-Join线程池" class="headerlink" title="Fork&#x2F;Join线程池"></a>Fork&#x2F;Join线程池</h2><p>体现一种分治思想，适用于能够进行任务拆分的CPU密集型运算</p>
<p>任务拆分是指将一个大任务拆分为算法上相同的小任务，直到不能拆分可以直接求解</p>
<p>Fork&#x2F;Join在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率。</p>
<p>Fork&#x2F;Join默认会创建与CPU核心数大小相同的线程池</p>
<p>JDK8后任务拆分和合并的工作交给Stream流API来做</p>
<p><strong>使用</strong></p>
<p>提交给Fork&#x2F;Join线程池的任务需要继承RecursiveTask（有返回值）或者RecursiveAction（无返回值）</p>
<p><strong>实例</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212111405894.png" alt="image-20250212111405894"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212111350802.png" alt="image-20250212111350802"></p>
<ul>
<li>任务流程改进</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212111619090.png" alt="image-20250212111619090"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212112034046.png" alt="image-20250212112034046"></p>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><p><strong>AbstractQueuedSynchronizer</strong>，是阻塞式锁和相关的同步器工具的框架（父类）</p>
<p><strong>特点</strong></p>
<ul>
<li>用state属性来表示资源的状态（独占模式&#x2F;共享模式），子类需要定义如何维护state，控制如何获取锁和释放锁<ul>
<li>getState：获取state状态</li>
<li>setState：设置state状态</li>
<li>compareAndSetState：乐观锁机制设置state状态，但由于AQS是阻塞式的锁</li>
<li>独占模式是只有一个线程能访问资源</li>
<li>共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>提供了基于FIFO的等待队列，类似于Monitor的EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似Monitor的WaitSet</li>
</ul>
<p><strong>子类主要实现的方法</strong></p>
<p>默认抛出UnsupportedOperationException</p>
<ul>
<li>tryAcquire</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212122250284.png" alt="image-20250212122250284"></p>
<ul>
<li>tryRelease</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212122303945.png" alt="image-20250212122303945"></p>
<ul>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<p><strong>自定义锁代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS自定义锁（不可重入锁）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//独占</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">//可以使用arg来实现可重入锁</span></span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//加锁成功,设置Owner为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//state是volatile的变量，而exclusiveOwner不是，将setState放在后面，可以使得前面的写操作对所有线程可见</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁，不成功进入等待队列</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁，可打断</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试加锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//tryRelease仅仅是将owner线程置为null，将state置为0</span></span><br><span class="line">    <span class="comment">//release还会将阻塞队列中等待的线程唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212125430325.png" alt="image-20250212125430325"></p>
<h4 id="非公平锁原理"><a href="#非公平锁原理" class="headerlink" title="非公平锁原理"></a>非公平锁原理</h4><p><strong>加锁解锁流程</strong></p>
<ul>
<li>构造器中，ReentrantLock默认为非公平锁实现，NonfairSync继承自AQS</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212143727428.png" alt="image-20250212143727428"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212143925079.png" alt="image-20250212143925079"></p>
<ul>
<li>没有竞争时</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212143811826.png" alt="image-20250212143811826"></p>
<ul>
<li>第一个竞争出现时</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212143945498.png" alt="image-20250212143945498"></p>
<p> <img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212144034277.png" alt="image-20250212144034277"></p>
<ul>
<li>Thread-1执行</li>
<li>CAS尝试将state由0改为1，失败</li>
<li>进入tryAcquire逻辑，此时state为1，结果仍然失败</li>
<li>然后进入addWaiter逻辑，构造Node队列<ul>
<li>图中黄色三角表示该Node的waitStatus状态，其中0为默认正常状态</li>
<li>Node的创建是懒惰的</li>
<li>其中第一个Node为Dummy或哨兵，用来占位，并不关联线程</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212145915389.png" alt="image-20250212145915389"></p>
<ul>
<li><p>当前线程进入acquireQueued逻辑</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212151331687.png" alt="image-20250212151331687"></p>
<ul>
<li>acquireQueued会在一个死循环中不断尝试获得锁，失败后进入park阻塞</li>
<li>如果自己是紧邻着head（排第二位），那么再次tryAcquire尝试获取锁，当然这是state仍为1，失败</li>
<li>进入shouldParkAfterFailedAcquired逻辑，将前驱node，即head的waitStatus改为-1（为-1的含义是有责任唤醒它的下一个节点），这次返回false</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212151750088.png" alt="image-20250212151750088"></p>
<ul>
<li>shouldParkAfterFailedAcquired执行完后回到acquireQueued，再次tryAcquire尝试获取锁，当然这时state仍为1，失败</li>
<li>当再次进入shouldParkAfterFailedAcquired时，这是应为其前驱node的waitStatus为-1，所以返回true</li>
<li>进入parkAndCheckInterrupt，Thread-1 park，灰色表示</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212151939225.png" alt="image-20250212151939225"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212152042932.png" alt="image-20250212152042932"></p>
<ul>
<li>再次由多个线程经历上述过程竞争失败</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212152407685.png" alt="image-20250212152407685"></p>
<ul>
<li>Thread-0释放锁，进入tryRelease流程，若成功<ul>
<li>设置exclusiveOwnerThread为null</li>
<li>state &#x3D; 0</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212152620432.png" alt="image-20250212152620432"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212152659373.png" alt="image-20250212152659373"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212152729095.png" alt="image-20250212152729095"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212152740703.png" alt="image-20250212152740703"></p>
<ul>
<li>当前队列不为null，且head的waitStatus &#x3D; -1，进入unparkSuccessor流程</li>
<li>找到队列中离head最近的一个Node（未取消的）,unpark恢复其运行</li>
<li>本例中即为Thread-1，回到Thread-1的acquireQueued流程</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212153354386.png" alt="image-20250212153354386"></p>
<ul>
<li><p>若加锁成功（无竞争），会进行设置</p>
<ul>
<li>exclusiveOwnerThread为Thread-1，state &#x3D; 1</li>
<li>head指向刚刚Thread-1所在的Node，该Node清空Thread</li>
<li>原来的head因为从链表断开，而可被垃圾回收</li>
</ul>
</li>
<li><p>若此时有其它线程来竞争（非公平锁），若Thread-4抢占</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212154041517.png" alt="image-20250212154041517"></p>
<ul>
<li>Thread-4被设置为exclusiveOwnerThread，state &#x3D; 1</li>
<li>Thread-1再次进入acquireQueued流程，获取锁失败，重新进入park阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><p><strong>源码分析（NonfairSync）</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212154352022.png" alt="image-20250212154352022"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212154848460.png" alt="image-20250212154848460"></p>
<h4 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h4><p><strong>不可打断模式</strong></p>
<p>该模式下，线程即使被打断，仍会驻留在AQS队列中，等获得锁后方能继续运行（只是打断标记被设置为true）</p>
<p><strong>源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212155546620.png" alt="image-20250212155546620"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212155559792.png" alt="image-20250212155559792"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212155618989.png" alt="image-20250212155618989"></p>
<p><strong>可打断模式</strong></p>
<p><strong>源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212155709990.png" alt="image-20250212155709990"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212155822590.png" alt="image-20250212155822590"></p>
<h4 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h4><p>FairSync源码</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212160114980.png" alt="image-20250212160114980"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212160259561.png" alt="image-20250212160259561"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212160323014.png" alt="image-20250212160323014"></p>
<h4 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h4><p>每个条件变量其实就对应着一个等待队列，其实现类是ConditionObject</p>
<p><strong>await流程</strong></p>
<ul>
<li>开始Thread-0持有锁，调用await，进入ConditionObject的addConditionWaiter（<strong>这里源码实现是单向的FIFO链表</strong>）流程，创建新的Node状态为-2（Node.CONDITION），关联Thread-0，加入等待队列尾部</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212162754143.png" alt="image-20250212162754143"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212162949162.png" alt="image-20250212162949162"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212162619261.png" alt="image-20250212162619261"></p>
<ul>
<li>接下来进入AQS的fullyRelease流程，释放同步器上的锁</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212163606433.png" alt="image-20250212163606433"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212163617581.png" alt="image-20250212163617581"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212163228303.png" alt="image-20250212163228303"></p>
<ul>
<li>unpark AQS队列的下一个节点，竞争锁，假设无其它竞争线程，Thread-1竞争成功</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212163549260.png" alt="image-20250212163549260"></p>
<ul>
<li>park阻塞Thread-0</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212163731563.png" alt="image-20250212163731563"></p>
<p><strong>Signal流程</strong></p>
<ul>
<li>假设Thread-1要来唤醒Thread-0</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212163829076.png" alt="image-20250212163829076"></p>
<ul>
<li>进入ConditionObject的doSignal流程，取得等待队列中第一个Node，即Thread-0所在Node，且总是调用首节点进行doSignal</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212164112411.png" alt="image-20250212164112411"></p>
<ul>
<li>执行transferForSignal流程，将该Node加入AQS队列尾部，使用enq方法（<strong>enq若成功执行返回当前节点在阻塞队列的前驱节点</strong>）将Thread-0的waitStatus改为0，Thread-3的waitStatus改为-1，转移失败有可能是因为该任务已经取消了</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212164712366.png" alt="image-20250212164712366"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212164926266.png" alt="image-20250212164926266"></p>
<ul>
<li>Thread-1释放锁，进入unlock流程</li>
</ul>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>可以有多个读同时发生，读写或谢谢互斥，不能同时发生</p>
<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>在频繁读的场景下，读-读操作可以并发以提高性能</p>
<p>类似数据库中的select … from … lock in share mode</p>
<p>提供一个<strong>数据容器类</strong>内部分使用<strong>读锁</strong>保护数据的read()方法，<strong>写锁</strong>保护数据的write()方法</p>
<p><strong>一个简单的使用实例</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212170355767.png" alt="image-20250212170355767"></p>
<p><strong>注意事项</strong></p>
<ul>
<li>读锁不支持条件变量</li>
<li>重入时升级不迟至，即持有读锁的情况下获取写锁，会导致获取写锁永久等待</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212170639824.png" alt="image-20250212170639824"></p>
<ul>
<li>重入时降级支持：既可以在持有写锁的情况下获取读锁</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212170917215.png" alt="image-20250212170917215"></p>
<h4 id="读写锁原理"><a href="#读写锁原理" class="headerlink" title="读写锁原理"></a>读写锁原理</h4><p><strong>流程</strong></p>
<p>读写锁用的是同一个Sync同步器，故等待队列，state等也是同一个</p>
<p><strong>场景</strong>：t1申请写锁，t2申请读锁</p>
<ul>
<li><strong>t1执行w.lock</strong>，流程与ReentrantLock加锁相比没有特殊之处，不同的是写锁状态占了state的低16位，而读锁使用的是state的高16位<ul>
<li>对于写锁，0表示无锁，1表示加锁，&gt;1表示重入</li>
<li>对于读锁，&gt;1时可能不止表示同一个线程发生重入，也有可能是多个线程同时加读锁</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212174628352.png" alt="image-20250212174628352"></p>
<ul>
<li>ReentrantReadWriteLock的tryAcquire方法</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212175522105.png" alt="image-20250212175522105"></p>
<ul>
<li><p><strong>t2执行r.lock</strong>，这时进入读锁的sync.acquireShared(1)流程，首先会进入tryAcquireShared流程，若有写锁占据，则tryAcquireShared返回-1表示失败</p>
<ul>
<li><p>tryAcquireShared返回值表示</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212181527281.png" alt="image-20250212181527281"></p>
<ul>
<li>-1表示失败</li>
<li>0表示成功，但后继节点不会继续唤醒</li>
<li>正数表示成功，且数值是还有几个后记节点需要唤醒，读写锁返回1</li>
</ul>
</li>
<li><p>返回值对于读写锁只有-1和1两种情况，分别表示失败和成功</p>
</li>
</ul>
</li>
<li><p>此时进入sync.doAccquireShared(1)流程，首先调用addWaiter添加节点，不同之外在于节点被设置为Node.SHARED模式而非Node.EXCLUSIVE模式，注意此时t2仍处于活跃状态</p>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212182653530.png" alt="image-20250212182653530"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212182222539.png" alt="image-20250212182222539"></p>
<ul>
<li><p>t2查看自己节点是否为老二，如果是，再次调用tryAcquireShared来尝试获取锁</p>
</li>
<li><p>若没有成功，在doAcquireShared内for(;;)循环一次，把前驱节点的waitStatus改为-1，再for(;;)循环一次尝试tryAcquireShared(1)如果还不成功，那么在parkAndCheckInterrupt()初park</p>
</li>
<li><p><strong>t3执行r.lcok，t4执行w.lock</strong>：在当前状态下，假设又有t3加读锁和t4加写锁，此时t1仍持有锁，情况如下</p>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212190439828.png" alt="image-20250212190439828"></p>
<ul>
<li><strong>t1执行w.unlock</strong>，此时会走到写锁的sync.release(1)流程，调用sync.tryRelease(1)成功，情况如下</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212190721423.png" alt="image-20250212190721423"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212190737468.png" alt="image-20250212190737468"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212190920014.png" alt="image-20250212190920014"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212190828948.png" alt="image-20250212190828948"></p>
<ul>
<li>接下来执行唤醒流程sync.unparkSuccessor，即恢复二号节点的运行，此时t2在doAcquireShared内parkAndCheckInterrupt()处恢复运行</li>
<li>此时再来一次for(;;)执行tryAcquireShared成功让读锁计数+1</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212191857663.png" alt="image-20250212191857663"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212191625618.png" alt="image-20250212191625618"></p>
<ul>
<li>此时t2恢复运行，接下来t2调用setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212192045525.png" alt="image-20250212192045525"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212192033421.png" alt="image-20250212192033421"></p>
<ul>
<li>在setHeadAndPropagate方法内还会检查下一个节点是否是shared，如果是则调用doReleaseShared()将head的状态从-1改为0并唤醒二号节点（<strong>这里是防止防止读共享锁情况下，当前线程还没唤醒后面的读线程的时候，来了一个新的读线程把后面的读线程唤醒了，等刚开始的读线程结束又会唤醒，避免重复唤醒。</strong>），此时t3在doAcquireShared内parkAndCheckInterrupt()处恢复运行</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212192337163.png" alt="image-20250212192337163"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212192630376.png" alt="image-20250212192630376"></p>
<ul>
<li>这回再来一次for(;;)执行tryAcquireShared成功让读锁+1</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212192823752.png" alt="image-20250212192823752"></p>
<ul>
<li>此时t3已经恢复运行，接下来t3调用setHeadAndPropagate(node, 1)，它原来所在节点被置为头节点</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212192951432.png" alt="image-20250212192951432"></p>
<ul>
<li><strong>t2和t3执行r.unlock</strong></li>
<li>t2进入sync.releaseShared(1)中，调用tryReleaseShared(1)让计数减一，但由于计数还不为零</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212193350546.png" alt="image-20250212193350546"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212193138759.png" alt="image-20250212193138759"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212193407559.png" alt="image-20250212193407559"></p>
<ul>
<li>所以上面的函数返回false</li>
<li>t3进入sync.releaseShared(1)中，调用tryReleaseShared(1)让计数减一，此时计数为0，进入doReleaseShared()将头节点从-1改为0并唤醒二号节点</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212193559372.png" alt="image-20250212193559372"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212193826687.png" alt="image-20250212193826687"></p>
<ul>
<li>之后t4在acquireQueued中parkAndCheckInterrupt出恢复运行，再次for(;;)，此时自己是二号节点，并且无其它竞争，tryAcquire(1)成功，修改头节点，流程结束</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212193905700.png" alt="image-20250212193905700"></p>
<h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><p>该类自JDK8加入，是为了进一步优化读性能，因为使用AQS来并发读的性能还是没有不加锁要好</p>
<p><strong>特点</strong></p>
<ul>
<li>在使用读锁、写锁时都必须配合<strong>戳</strong>使用</li>
</ul>
<p><strong>读锁的加锁和解锁</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212201155169.png" alt="image-20250212201155169"></p>
<p><strong>写锁的加锁和解锁</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212201203308.png" alt="image-20250212201203308"></p>
<p><strong>乐观读</strong></p>
<ul>
<li><p>tryOptimisticRead()</p>
</li>
<li><p>StampedLock支持乐观读，读取完毕后需要做一次戳校验，如果校验通过，表示期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全</p>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212201728341.png" alt="image-20250212201728341"></p>
<p><strong>实例代码</strong></p>
<p>提供一个数据容器类内部分别使用读锁保护数据的read()方法，写锁保护数据的write()方法</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212205118787.png" alt="image-20250212205118787"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212205752549.png" alt="image-20250212205752549"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212205814951.png" alt="image-20250212205814951"></p>
<p><strong>缺点</strong></p>
<ul>
<li>不支持条件变量</li>
<li>不支持可重入</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量，用来限制能同时访问共享资源的上限 </p>
<p><strong>实例代码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212211222649.png" alt="image-20250212211222649"></p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h4><ul>
<li><p>限流，在访问高峰期，阻塞请求线程，待高峰期过去再释放。只适合限制单机线程数，而且仅是限制线程数，而不是限制资源数（例如连接数，对比Tomcat LimitLatch实现）</p>
</li>
<li><p>用Semaphore实现简单连接池（资源数 &#x3D; 连接数），对比享元模式（wait&#x2F;notify）下的实现，性能和可读性显然更好</p>
<ul>
<li>borrow方法</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212212549706.png" alt="image-20250212212549706"></p>
<ul>
<li>free方法</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212212702641.png" alt="image-20250212212702641"></p>
</li>
</ul>
<h4 id="Semaphore原理"><a href="#Semaphore原理" class="headerlink" title="Semaphore原理"></a>Semaphore原理</h4><p><strong>加锁解锁流程</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212212856187.png" alt="image-20250212212856187"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212213046228.png" alt="image-20250212213046228"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212213115014.png" alt="image-20250212213115014"></p>
<ul>
<li>实际上就是将permits赋值给了AQS中的state中</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212213232078.png" alt="image-20250212213232078"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212213248336.png" alt="image-20250212213248336"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212213327046.png" alt="image-20250212213327046"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212213344211.png" alt="image-20250212213344211"></p>
<p>实例：5个线程获取3个资源</p>
<p><strong>acquire</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212213523154.png" alt="image-20250212213523154"></p>
<ul>
<li>假设1，2，4竞争成功，0，3竞争失败，进入AQS队列park阻塞</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212213751215.png" alt="image-20250212213751215"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212213925323.png" alt="image-20250212213925323"></p>
<p><strong>release</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212214002242.png" alt="image-20250212214002242"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212214024949.png" alt="image-20250212214024949"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212214057575.png" alt="image-20250212214057575"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212214143630.png" alt="image-20250212214143630"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212214234218.png" alt="image-20250212214234218"></p>
<ul>
<li>此时Thread-4释放permits，状态如下</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212214436926.png" alt="image-20250212214436926"></p>
<ul>
<li>接下来Thread-0竞争成功，permits再次设置为0，设置自身为head节点，断开原来的head节点，unpark接下来的Thread-3节点，但由于permits为0，所以Thread-3再尝试不成功后再次进入park状态</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212214645735.png" alt="image-20250212214645735"></p>
<h3 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h3><p>用于进行线程同步写作，等待所有线程完成倒计时</p>
<p>其中构造参数初始化等待计数值</p>
<ul>
<li>await()用来等待计数归零</li>
<li>countDown()用来让计数减一</li>
</ul>
<p><strong>源码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212215008644.png" alt="image-20250212215008644"></p>
<p><strong>与join()方法的比较</strong></p>
<ul>
<li>在等待线程处对所有需要等待的线程采取join操作可以达到与CountDownLatch相同的结果</li>
<li>但是如果涉及到线程池等灵活多变的场景，join()的使用就不太方便了</li>
<li>Join是偏底层的API，而CountDownLatch则是一个较为高层的API</li>
</ul>
<p><strong>CountdownLatch应用</strong></p>
<ul>
<li>等待多线程准备完毕</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212221305819.png" alt="image-20250212221305819"></p>
<ul>
<li>等待多个远程调用结束</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212221851651.png" alt="image-20250212221851651"></p>
<p><strong>Future应用</strong></p>
<p>对上面等待多个远程调用结束的改进，可以让主线程获取子线程执行的结果</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212222047412.png" alt="image-20250212222047412"></p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>循环栅栏，用于线程协作</p>
<p>实际上与CountdownLatch的主要区别就是CountdownLatch对象不能重用，而CyclicBarrier可以在设置值减为0后让计数恢复到设置值重新工作</p>
<p><strong>实例代码</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212223934615.png" alt="image-20250212223934615"></p>
<p><strong>注意</strong></p>
<ul>
<li>若任务数和CB设置的值不同，那么可能实现不了你想实现的任务执行效果</li>
</ul>
<h3 id="线程安全类集合概述"><a href="#线程安全类集合概述" class="headerlink" title="线程安全类集合概述"></a>线程安全类集合概述</h3><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212224248219.png" alt="image-20250212224248219"></p>
<ul>
<li>第一类：出现较早，且所有方法均使用synchronized修饰，并发性较低<ul>
<li>Hashtable是线程安全的map实现</li>
<li>Vector是线程安全的List实现</li>
</ul>
</li>
<li>第二类：使用Collections装饰的线程安全集合，具体实现部分方法本质上就是使用synchronized锁住本对象，然后调用原线程不安全类的方法，性能提升不明显（使用<strong>装饰器模式</strong>）<ul>
<li>Collections.synchronizedCollection</li>
<li>Collections.synchronizedList</li>
<li>Collections.synchronizedMap</li>
<li>Collections.synchronizedSet</li>
<li>Collections.synchronizedNavigableMap</li>
<li>Collections.synchronizedNavigableSet</li>
<li>Collections.synchronizedSortedMap</li>
<li>Collections.synchronizedSortedSet</li>
</ul>
</li>
<li>第三类：java.util.current.*  (JUC)<ul>
<li>Blocking：大部分实现基于锁（一般使用ReentrantLock），且提供用来阻塞的方法</li>
<li>CopyOnWrite：使用拷贝方式来保证多线程并发的安全，适用于读多写少的场景，修改开销相对较重</li>
<li>Concurrent类型的容器<ul>
<li>内部很多操作适用CAS优化，一般吞吐量较高</li>
<li>弱一致性<ul>
<li>遍历时弱一致性，当利用迭代器遍历时，若容器发生修改，迭代器仍可以继续进行遍历，但此时内容是旧的</li>
<li>求大小弱一致性，size操作未必准确</li>
<li>读取弱一致性</li>
</ul>
</li>
<li>遍历时如果发生修改，对非线程安全容器来讲，适用fail-fast机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历</li>
<li>对于线程安全的集合则为fail-safe机制，即正在遍历的集合遭遇修改会继续遍历</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><strong>错误用法实例</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212231204554.png" alt="image-20250212231204554"></p>
<ul>
<li><p>还是老问题，线程安全类单个操作能保证原子性，但是多个操作组合就不能保证原子性了</p>
</li>
<li><p>适用computeIfAbsent()方法和原子累加器的increment()方法</p>
</li>
</ul>
<h4 id="ConcurrentHashMap原理——JDK8"><a href="#ConcurrentHashMap原理——JDK8" class="headerlink" title="ConcurrentHashMap原理——JDK8"></a>ConcurrentHashMap原理——JDK8</h4><h5 id="JDK7并发死链问题"><a href="#JDK7并发死链问题" class="headerlink" title="JDK7并发死链问题"></a>JDK7并发死链问题</h5><p>在多线程环境下进行HashMap扩容时可能导致OOM的一种情况</p>
<p>JDK7中HashMap解决冲突是使用头插法，而JDK8中使用尾插法</p>
<p>要在JDK7下才能复现该问题，否则扩容机制和hash计算方法全改变了</p>
<p><strong>本质原因</strong>是多线程环境下使用了非线程安全的map集合</p>
<p>JDK8虽然调整了扩容算法，不再将元素加入链表头，而是保持与扩容前一样的顺序，但并不意味着能在多线程环境下安全扩容，还可能出现扩容丢数据的问题</p>
<h5 id="与HashTable和HashMap的比较"><a href="#与HashTable和HashMap的比较" class="headerlink" title="与HashTable和HashMap的比较"></a>与HashTable和HashMap的比较</h5><ul>
<li><p>HashMap是线程不安全的，因为HashMap中操作都没有加锁，因此在多线程环境下会导致数据覆盖之类的问题，所以，在多线程中使用HashMap是会抛出异常的。</p>
</li>
<li><p>HashTable是线程安全的,但是HashTable只是单纯的在put()方法上加上synchronized。保证插入时阻塞其他线程的插入操作。虽然安全，但因为设计简单，所以性能低下。HashTable不允许key和value为null（HashMap允许）</p>
</li>
<li><p>ConcurrentHashMap是线程安全的，ConcurrentHashMap并非锁住整个方法，而是通过原子操作和局部加锁的方法保证了多线程的线程安全，且尽可能减少了性能损耗。</p>
</li>
</ul>
<h5 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h5><p><strong>属性</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213003748666.png" alt="image-20250213003748666"></p>
<p><strong>注意</strong></p>
<ul>
<li>ForwardingNode是指在HashMap扩容时，每处理完一个bin，在bin上挂载一个此节点，以使得其它线程对当前bin处理完成可见</li>
<li>单个bin上链表长度超过8时会先进行扩容，待bin数目超过64还存在某个bin上的链表长度超过8，该bin的链表就会被转换成一颗红黑树</li>
</ul>
<p><strong>方法</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213012911061.png" alt="image-20250213012911061"></p>
<h5 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a><strong>构造器分析</strong></h5><p>懒惰初始化，构造方法中仅计算table的大小，以后在第一次使用时才会真正创建</p>
<p>而JDK7会在初始化时直接生成segement数组，对资源消耗比较大</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213013009891.png" alt="image-20250213013009891"></p>
<ul>
<li>参数分别为数组初始大小，扩容阈值因子（默认0.75），并发度</li>
<li>大小是需要进行计算的，并非一定与自己设定的initialCapacity相同，这是与HashMap的一个区别</li>
</ul>
<h5 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a><strong>get流程</strong></h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213014213975.png" alt="image-20250213014213975"></p>
<ul>
<li>判断头节点Hash值时，之所以有两种比较相同的方式，是为了满足判断基本数据类型和引用数据类型</li>
<li>处于扩容状态链表被完全迁移后添加的标识ForwardingNode的hash是负数</li>
<li>不加锁是因为使用了volatile</li>
</ul>
<h5 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a><strong>put流程</strong></h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213015032261.png" alt="image-20250213015032261"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213015855553.png" alt="image-20250213015855553"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213015951321.png" alt="image-20250213015951321"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213020107390.png" alt="image-20250213020107390"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213020625687.png" alt="image-20250213020625687"></p>
<ul>
<li>默认put方法重复插入相同Key时用新值覆盖旧值，但是也可以通过设置onlyIfAbsent来修改为不能覆盖</li>
<li>initTable底层使用CAS来保证不会有多个线程同时初始化</li>
<li>MOVED就是ForwardingNode的Hash值</li>
<li>帮助扩容就是帮助扩容的HashMap锁住其某个还未完成扩容的bin上链表，以保证其线程安全性</li>
<li>binCount不为0说为链表存在冲突</li>
<li>使用类似LongAdder的多个累加单元进行计数，以提升在多线程下的并发度</li>
<li>synchronized没有加在整个hashMap上，而是加载需要添加元素的链表头f上</li>
</ul>
<h5 id="初始化table流程"><a href="#初始化table流程" class="headerlink" title="初始化table流程"></a><strong>初始化table流程</strong></h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213020659161.png" alt="image-20250213020659161"></p>
<ul>
<li>sizeCtl值为-1代表正在创建Hash表</li>
<li>sc会赋值成下一次扩容的阈值</li>
</ul>
<h5 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a><strong>addCount方法</strong></h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213021109520.png" alt="image-20250213021109520"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213021403320.png" alt="image-20250213021403320"></p>
<ul>
<li><p>addCount主要作用</p>
<ul>
<li>维护HashMapSize的计数</li>
<li>当size超过扩容阈值后进行扩容操作</li>
</ul>
</li>
<li><p>借鉴LongAdder思想，减少多线程冲突</p>
</li>
</ul>
<h5 id="size计算流程"><a href="#size计算流程" class="headerlink" title="size计算流程"></a><strong>size计算流程</strong></h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213021911669.png" alt="image-20250213021911669"></p>
<ul>
<li>size计算实际发生在put，remove改变集合元素的操作中<ul>
<li>无竞争发生，向baseCount累加计数</li>
<li>有竞争发生，新建couterCells，向其中的一个cell累加计数<ul>
<li>couterCells初始有两个cell</li>
<li>若计数竞争比较激烈，会创建新的cell来累加计数</li>
</ul>
</li>
</ul>
</li>
<li>得到的是一个大概值而非精确值，即可以理解为不满足过程一致性，但是满足最终一致性</li>
</ul>
<h5 id="transfer流程"><a href="#transfer流程" class="headerlink" title="transfer流程"></a><strong>transfer流程</strong></h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213022115594.png" alt="image-20250213022115594"></p>
<p><code>if(nextTab == null)分支</code></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213022158576.png" alt="image-20250213022158576"></p>
<ul>
<li>完成扩容时bin上链表或树的迁移</li>
</ul>
<h4 id="ConcurrentHashMap原理——JDK7"><a href="#ConcurrentHashMap原理——JDK7" class="headerlink" title="ConcurrentHashMap原理——JDK7"></a>ConcurrentHashMap原理——JDK7</h4><p>维护一个segment数组，每个segment对应一把锁（继承自ReentrantLock）</p>
<ul>
<li>优点：若多个线程访问不同的segment，不会出现冲突</li>
<li>缺点：segment数组默认大小为16，且该容量初始化指定后就不能改变，且不是懒惰初始化</li>
</ul>
<h5 id="构造器分析-1"><a href="#构造器分析-1" class="headerlink" title="构造器分析"></a>构造器分析</h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213023144254.png" alt="image-20250213023144254"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213023153593.png" alt="image-20250213023153593"></p>
<ul>
<li>直接完成创建，对内存占用较大</li>
<li>会直接创建出下标为0的元素</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213023325887.png" alt="image-20250213023325887"></p>
<ul>
<li>每个Segment对应的以链表为元素的HashEntry数组，所以可以理解为JDK7中的segment锁住了多个链表头，而JDK8中只锁住了一个链表头</li>
<li>segmentShift和segmentMask的作用是决定将key的hash结果匹配到哪个segment</li>
</ul>
<h5 id="put流程-1"><a href="#put流程-1" class="headerlink" title="put流程"></a><strong>put流程</strong></h5><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213023717498.png" alt="image-20250213023717498"></p>
<ul>
<li>segment[0]的元素不是懒惰加载，但其他是，ensureSegment用来创建segment</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213023912647.png" alt="image-20250213023912647"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213024221497.png" alt="image-20250213024221497"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213024318877.png" alt="image-20250213024318877"></p>
<h5 id="扩容流程"><a href="#扩容流程" class="headerlink" title="扩容流程"></a><strong>扩容流程</strong></h5><p>rehash无需考虑线程安全，因为是在put中被调用的，此时已经获取了锁</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213024458411.png" alt="image-20250213024458411"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213024855025.png" alt="image-20250213024855025"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213024947990.png" alt="image-20250213024947990"></p>
<ul>
<li>有的节点是直接移动到新的表中，但有的节点是进行拷贝后再加入新的表中</li>
<li>扩容后加入新的节点</li>
</ul>
<h5 id="get流程-1"><a href="#get流程-1" class="headerlink" title="get流程"></a><strong>get流程</strong></h5><p>get时未加锁，使用UNSAFE方法保证可见性</p>
<p>扩容过程中</p>
<ul>
<li>get先发生就从旧表取内容</li>
<li>get后发生就从新表取内容</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213025146713.png" alt="image-20250213025146713"></p>
<ul>
<li>数组元素光加锁是不行的，所以使用getObjectVolatile来保证安全性</li>
</ul>
<h5 id="size计算流程-1"><a href="#size计算流程-1" class="headerlink" title="size计算流程"></a><strong>size计算流程</strong></h5><ul>
<li>计算元素个数前，先不加锁计算两次，若前后两次结果一样，认为个数正确返回</li>
<li>若不一样，进行重试，重试次数超过3，锁住所有segment，重新计算个数返回</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213025458952.png" alt="image-20250213025458952"></p>
<p> <img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213025719103.png" alt="image-20250213025719103"></p>
<h3 id="LinkerBlockingQueue原理"><a href="#LinkerBlockingQueue原理" class="headerlink" title="LinkerBlockingQueue原理"></a>LinkerBlockingQueue原理</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213025929186.png" alt="image-20250213025929186"></p>
<h4 id="初始化链表"><a href="#初始化链表" class="headerlink" title="初始化链表"></a><strong>初始化链表</strong></h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213030029022.png" alt="image-20250213030029022"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">last = head = new Node&lt;E&gt;(null);</span><br><span class="line">Dummy节点用来占位，item为null</span><br></pre></td></tr></table></figure>



<h4 id="节点入队"><a href="#节点入队" class="headerlink" title="节点入队"></a>节点入队</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213030050192.png" alt="image-20250213030050192"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last = last.next = node</span><br></pre></td></tr></table></figure>





<h4 id="节点出队"><a href="#节点出队" class="headerlink" title="节点出队"></a>节点出队</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213030242784.png" alt="image-20250213030242784"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213030302757.png" alt="image-20250213030302757"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213030332874.png" alt="image-20250213030332874"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213030351139.png" alt="image-20250213030351139"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213030420292.png" alt="image-20250213030420292"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213030514752.png" alt="image-20250213030514752"></p>
<h4 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a><strong>加锁分析</strong></h4><p>使用两把锁和dummy节点</p>
<ul>
<li>用一把锁，同一时刻最多只允许有一个线程（生产者或消费者）执行</li>
<li>用两把锁，同一时刻，可以允许两个线程（生产者和消费者）同时执行<ul>
<li>消费者与消费者，生产者与生产者线程仍然串行</li>
</ul>
</li>
</ul>
<p><strong>线程安全分析</strong></p>
<ul>
<li>当节点总数大于2时（包括dummy节点）,putLock保证Last节点的线程安全，takeLock保证head节点的线程安全，两把锁保证入队和出队无竞争</li>
<li>当节点总数等于2时（一个dummy节点，一个正常节点），此时仍是两把锁锁两个对象，不会竞争</li>
<li>当节点总数为1（仅有一个dummy节点），此时take线程会被notEmpty条件阻塞，有竞争，会阻塞</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213031113135.png" alt="image-20250213031113135"></p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213031244635.png" alt="image-20250213031244635"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213031446791.png" alt="image-20250213031446791"></p>
<ul>
<li>使用signal而非signalAll是为了防止惊群，导致更多的线程竞争</li>
</ul>
<h4 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213031639184.png" alt="image-20250213031639184"></p>
<h4 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h4><p>LinkedBlockingQueue与ArrayBlockingQueue性能比较</p>
<ul>
<li>Linked支持有界，Array强制有界</li>
<li>Linked实现是链表，Array实现是数组</li>
<li>Linked是懒惰的，而Array需要提前初始化Node数组</li>
<li>Linked每次入队会生成新Node，而Array的Node初始化时就创建好了</li>
<li>Linked两把锁，Array一把锁</li>
</ul>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>设计与LinkerBlockingQueue非常像</p>
<ul>
<li>两把锁，同一时刻允许两个线程执行</li>
<li>dummy节点的引入使得两把锁锁住的是不同对象，避免竞争</li>
<li>只是锁使用的是CAS进行实现</li>
</ul>
<p>ConcurrentLinkedQueue应用广泛，Tomcat的Connecter结构中Acceptor作为生产者向Poller消费者传递事件信息时，就是采用了ConcurrentLinkedQueue将SocketChannel给Poller使用</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213032634029.png" alt="image-20250213032634029"></p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArraySet是它的马甲</p>
<p>底层采用写入时拷贝的思想，增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，不影响其它线程的并发读，读写分离</p>
<h4 id="新增流程"><a href="#新增流程" class="headerlink" title="新增流程"></a>新增流程</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213033045653.png" alt="image-20250213033045653"></p>
<h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><p>不加锁，适合读多写少的应用场景</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250213033233839.png" alt="image-20250213033233839"></p>
<h4 id="get弱一致性"><a href="#get弱一致性" class="headerlink" title="get弱一致性"></a>get弱一致性</h4><p>JUC包下的容器都存在</p>
<h4 id="迭代器弱一致性"><a href="#迭代器弱一致性" class="headerlink" title="迭代器弱一致性"></a>迭代器弱一致性</h4><p>就是在迭代器遍历过程中可能出现的数据不一致情况，采用fail-safe继续遍历</p>
<p>弱一致性不一定不好</p>
<ul>
<li>数据库的MVCC就是弱一致性的表现</li>
<li>并发高和一致性是矛盾的，需要权衡</li>
</ul>
<h1 id="应用篇"><a href="#应用篇" class="headerlink" title="应用篇"></a>应用篇</h1><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="防止CPU占有100"><a href="#防止CPU占有100" class="headerlink" title="防止CPU占有100%"></a>防止CPU占有100%</h3><p><strong>sleep实现</strong></p>
<p>在没有CPU计算时，不能让while(true)空转浪费CPU，此时使用yield或sleep来让出CPU的使用权给其它程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		Thread.sleep(<span class="number">50</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用wait或条件变量达到类似的效果，但这两种方法需要加锁且需要相应的唤醒操作，一般适用于要进行同步的场景</li>
<li>sleep适用无需锁同步的场景</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h2 id="统筹"><a href="#统筹" class="headerlink" title="统筹"></a>统筹</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是对要完成的事情合理调度，能够并行的要并行</span><br></pre></td></tr></table></figure>









<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>为避免临界区的竞态条件发生</p>
<ul>
<li>阻塞式的解决方案，即<strong>对象锁</strong>，synchronized，lock。采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，且只有拥有锁的线程可以安全的执行临界区中的代码，不必担心线程的上下文切换</li>
<li>非阻塞式的解决方案：<strong>原子变量</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：Java中互斥和同步都可以用synchronized关键字来完成，但还是有区别的</span><br></pre></td></tr></table></figure>

<ul>
<li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li>
<li>同步是由于线程执行的先后、顺序不同，需要一个线程等待其它线程运行到某个点</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>对·DAO对象数据库查询缓存类的实现</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212171646583.png" alt="image-20250212171646583"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212171703770.png" alt="image-20250212171703770"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212171722368.png" alt="image-20250212171722368"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212171738568.png" alt="image-20250212171738568"></p>
<ul>
<li>HashMap首先就是一个线程不安全的容器</li>
<li>即使使用了线程安全的HashMap，也会出现多个线程写缓存或者缓存更新策略导致的错误</li>
</ul>
<p><strong>缓存更新策略</strong></p>
<ul>
<li>先清缓存<ul>
<li>不一致性会持续比较久</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212172518987.png" alt="image-20250212172518987"></p>
<ul>
<li>先更新数据库（<strong>较为合理</strong>）<ul>
<li>不一致性仅发生在更新线程清除缓存前进行读操作的线程上</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212172747202.png" alt="image-20250212172747202"></p>
<p><strong>使用ReentrantReadWriteLock进行改写</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212173541295.png" alt="image-20250212173541295"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212173445057.png" alt="image-20250212173445057"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212173411493.png" alt="image-20250212173411493"></p>
<p><strong>注意</strong></p>
<ul>
<li>以上实例体现的是读写锁的应用，保证缓存和数据库的一致性，但没有考虑下面的问题<ul>
<li>适合读多写少，若写操作频繁，以上实现性能低</li>
<li>没有考虑缓存容量</li>
<li>没有考虑缓存过期</li>
<li>只适合单机，不适合分布式系统</li>
<li>并发性比较低，目前只会用一把锁，可以针对不同的库对锁进行细粒化</li>
<li>更新过于简单粗暴，直接清空所有key，考虑按类型分区或重新设计key</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弹幕看到的tips:</span><br><span class="line">不上锁&lt;aqs&lt;读写锁&lt;sync&lt;分布式</span><br></pre></td></tr></table></figure>







































































































<h1 id="模式篇"><a href="#模式篇" class="headerlink" title="模式篇"></a>模式篇</h1><h2 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个线程中T1中如何完善地终止T2</span><br></pre></td></tr></table></figure>

<p><strong>错误思路</strong></p>
<ul>
<li>使用线程对象的stop()方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop方法有机会真正杀死线程，若此时线程在共享资源上存在锁，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</span><br></pre></td></tr></table></figure>

<ul>
<li>使用System.exit(int)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目的仅仅是停止一个线程，这种做法会停止整个程序</span><br></pre></td></tr></table></figure>

<p><strong>正确做法</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250102210922598.png" alt="image-20250102210922598"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitorThread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//启动遥控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitorThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(current.isInterrupted())&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    Log.debug(<span class="string">&quot;执行监控记录&quot;</span>)</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printTraceStack();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;monitor&quot;</span>);</span><br><span class="line">        monitorThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        monitorThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="两阶段终止模式——volatile"><a href="#两阶段终止模式——volatile" class="headerlink" title="两阶段终止模式——volatile"></a>两阶段终止模式——volatile</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitorThread;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> stop;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//启动遥控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitorThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(stop)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    Log.debug(<span class="string">&quot;执行监控记录&quot;</span>)</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;monitor&quot;</span>);</span><br><span class="line">        monitorThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        monitorThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="同步模式之Balking"><a href="#同步模式之Balking" class="headerlink" title="同步模式之Balking"></a>同步模式之Balking</h2><p>Balking（犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做，直接结束返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xService</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> starting;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        	log.info(<span class="string">&quot;任务开始&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(starting)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用Balking模式实现线程安全的单例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="保护性暂停模式"><a href="#保护性暂停模式" class="headerlink" title="保护性暂停模式"></a>保护性暂停模式</h2><p><strong>Guarded Suspension</strong></p>
<p>用在一个线程等待另一个线程的执行结果</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208205202139.png" alt="image-20250208205202139"></p>
<p><strong>要点</strong></p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，就让他们关联同一个GuardedObject</li>
<li>若有结果不断从一个线程到另一个线程，可以使用消息队列</li>
<li>JDK中，join的实现，Future的实现，采用的即此模式</li>
<li>因为需要等待另一方的结果，因此可以归类为同步模式</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>join，FutureTask必须等待待进行的线程结束才能继续</li>
<li>如果使用join，想要获取的执行结果只能是全局变量而不能是局部的变量</li>
</ul>
<p>进一步优化时，设计中间类进行解耦生产和消费者，并且能支持多组生产消费的管理</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250208224232778.png" alt="image-20250208224232778"></p>
<p><strong>实现</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209002415705.png" alt="image-20250209002415705"><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209002350228.png" alt="image-20250209002350228"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209002453557.png" alt="image-20250209002453557"></p>
<h2 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者&#x2F;消费者"></a>异步模式之生产者&#x2F;消费者</h2><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209010409464.png" alt="image-20250209010409464"></p>
<p><strong>要点</strong></p>
<ul>
<li>与保护性暂停不同，不需要产生结果和消费结果的线程一一对应</li>
<li>消费队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据如何处理，而消费者专心处理结果数据</li>
<li>消息队列有容量限制</li>
<li>JDK中各种阻塞队列采用的即是本模式</li>
</ul>
<p><strong>实现</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209014736989.png" alt="image-20250209014736989"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209014829313.png" alt="image-20250209014829313"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209014849708.png" alt="image-20250209014849708"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209014923800.png" alt="image-20250209014923800"></p>
<h2 id="异步模式之工作流程"><a href="#异步模式之工作流程" class="headerlink" title="异步模式之工作流程"></a>异步模式之工作流程</h2><p>让有限的工作流程（Worker Thread）轮流异步处理无限多的任务，也可以将其归类为分工模式，典型实现就是线程池，也体现了经典设计模式中的享元模式</p>
<p><strong>饥饿</strong></p>
<p>固定大小线程池存在饥饿现象</p>
<p><strong>实例</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212000405272.png" alt="image-20250212000405272"></p>
<p>不同任务类型应该使用不同的线程池，来避免饥饿并且提升效率</p>
<p><strong>创建多少线程池合适</strong></p>
<ul>
<li>过小会导致程序不能充分地利用系统资源，容易导致饥饿</li>
<li>过大会导致更多的线程上下文切换，占用更多内存</li>
</ul>
<p><strong>针对CPU密集型计算</strong></p>
<p>通常采用CPU核数 + 1能实现最优的CPU利用</p>
<p>+1是保证当线程由于页确实故障或其他原因导致暂停时，额外的线程可以救急，保证CPU时钟周期不被浪费</p>
<p><strong>针对IO密集型运算</strong></p>
<p>CPU不总是处于繁忙状态，执行IO操作或远程RPC调用时或进行数据库操作时</p>
<p>此时可以利用多线程来提高CPU的利用率</p>
<ul>
<li>经验公式如下</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250212005817010.png" alt="image-20250212005817010"></p>
<h2 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h2><h3 id="固定运行顺序"><a href="#固定运行顺序" class="headerlink" title="固定运行顺序"></a>固定运行顺序</h3><h4 id="wait-notify版"><a href="#wait-notify版" class="headerlink" title="wait&#x2F;notify版"></a>wait&#x2F;notify版</h4><p>保证t2线程执行一定在t1线程之前</p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209172603455.png" alt="image-20250209172603455"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209172729979.png" alt="image-20250209172729979"></p>
<h4 id="ReentrantLock版"><a href="#ReentrantLock版" class="headerlink" title="ReentrantLock版"></a>ReentrantLock版</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实就是将wait和notify改成await和signal，同时将</span><br></pre></td></tr></table></figure>



<h4 id="Park-Unpark版"><a href="#Park-Unpark版" class="headerlink" title="Park&#x2F;Unpark版"></a>Park&#x2F;Unpark版</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209173403033.png" alt="image-20250209173403033"></p>
<h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><h4 id="wait-notify版-1"><a href="#wait-notify版-1" class="headerlink" title="wait&#x2F;notify版"></a>wait&#x2F;notify版</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209174223455.png" alt="image-20250209174223455"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209174320655.png" alt="image-20250209174320655"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209174259384.png" alt="image-20250209174259384"></p>
<h4 id="Lock条件变量版"><a href="#Lock条件变量版" class="headerlink" title="Lock条件变量版"></a>Lock条件变量版</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209174705813.png" alt="image-20250209174705813"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209174756566.png" alt="image-20250209174756566"></p>
<h4 id="Park-Unpark版-1"><a href="#Park-Unpark版-1" class="headerlink" title="Park&#x2F;Unpark版"></a>Park&#x2F;Unpark版</h4><p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209175652855.png" alt="image-20250209175652855"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250209175718646.png" alt="image-20250209175718646"></p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>Flyweight pattern：当需要重用数量有限的同一类对象时</p>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p><strong>包装类</strong></p>
<ul>
<li><p>JDK中Boolean，Byte，Short，Integer，Long，Character等包装类提供了valueOf方法</p>
</li>
<li><p>例如Long的valueOf会缓存-128~127之间的Long对象，在这个范围之间会宠用对象，大于该返回才会新建Long对象</p>
</li>
</ul>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211110337747.png" alt="image-20250211110337747"></p>
<ul>
<li>Byte，short，Long缓存的范围都是-128~127</li>
<li>Character缓存的范围是0~127</li>
<li>Integer的默认范围是-128~127，最小值不能变，但最大值可以通过调整虚拟机参数-D java.lang.IntegerCache.high来改变</li>
<li>Boolean缓存了TRUE和FALSE</li>
</ul>
<p><strong>String串池</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面JVM课</span><br></pre></td></tr></table></figure>



<p><strong>BigDecimal&#x2F;BigInteger</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211112411065.png" alt="image-20250211112411065"></p>
<ul>
<li>也是有一部分数字提前保存在缓存中</li>
<li>Decimal也是不可变类，但是在多线程条件下，多个原子操作的组合可能不能保证原子性</li>
</ul>
<h3 id="自定义线程池实现"><a href="#自定义线程池实现" class="headerlink" title="自定义线程池实现"></a>自定义线程池实现</h3><p><strong>初步实现</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211121235399.png" alt="image-20250211121235399"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211121559323.png" alt="image-20250211121559323"></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211121615743.png" alt="image-20250211121615743"></p>
<ul>
<li>borrow方法中通过CAS和wait配合使用来确保线程不会过度占用CPU</li>
<li>没有考虑的实现<ul>
<li>连接的动态增长与收缩</li>
<li>连接保活（可用性检测）</li>
<li>等待超时处理</li>
<li>分布式hash</li>
</ul>
</li>
</ul>
<p><strong>阻塞队列</strong></p>
<p><img src="C:\Users\THECHOSEN\AppData\Roaming\Typora\typora-user-images\image-20250211152626035.png" alt="image-20250211152626035"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pool</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, Runnable task)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取任务的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span>&#123;</span><br><span class="line">        <span class="comment">//当任务书没有超过coreSize时，直接交给worker对象执行</span></span><br><span class="line">        <span class="comment">//若任务超过coreSize时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize) &#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                taskQueue.put(task);</span><br><span class="line">                <span class="comment">//队列已满的可用策略</span></span><br><span class="line">                <span class="comment">//死等</span></span><br><span class="line">                <span class="comment">//带超时等待</span></span><br><span class="line">                <span class="comment">//让调用者放弃任务执行</span></span><br><span class="line">                <span class="comment">//让调用者抛出异常</span></span><br><span class="line">                <span class="comment">//让调用者自己执行任务</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                * 调用方式</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                //队列已满的可用策略</span></span><br><span class="line"><span class="comment">                //死等</span></span><br><span class="line"><span class="comment">                *(queue, task) -&gt; &#123;queue.put(task);&#125;</span></span><br><span class="line"><span class="comment">                //带超时等待</span></span><br><span class="line"><span class="comment">                *(queue, task) -&gt; &#123;queue.offer(task, 500, TimeUnit.MILLISECOND);&#125;</span></span><br><span class="line"><span class="comment">                //让调用者放弃任务执行</span></span><br><span class="line"><span class="comment">                * (queue, task) -&gt; &#123;sout(&quot;放弃任务&quot;);&#125;</span></span><br><span class="line"><span class="comment">                //让调用者抛出异常</span></span><br><span class="line"><span class="comment">                * (queue, task) -&gt; &#123;throw new RuntimeException(&quot;任务执行失败&quot;);&#125;</span></span><br><span class="line"><span class="comment">                //让调用者自己执行任务</span></span><br><span class="line"><span class="comment">                * (queue, task) -&gt; &#123;task.run();&#125;</span></span><br><span class="line"><span class="comment">                * */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">long</span> timeout,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span> coreSize,</span></span><br><span class="line"><span class="params">                      TimeUnit timeUnit,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span> queueCapcity,</span></span><br><span class="line"><span class="params">                      RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//task不为空，执行任务</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//task执行完毕，从任务队列获取任务并执行</span></span><br><span class="line">            <span class="keyword">while</span>(task != <span class="literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件变量：生产</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件变量：消费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capcity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//带超时的阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//返回值就是总时长-已等待的时间</span></span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T element)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.size() == capcity)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(element);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task, <span class="type">long</span> timeout, TimeUnit timeUnit)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span>(queue.size() == capcity)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>(queue.size() == capcity)&#123;</span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>, (Runnable) task);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//有空闲</span></span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/01/29/JUC/">http://example.com/2025/01/29/JUC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">开发技术</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/29/java%E7%BC%96%E7%A8%8Bapi/" title="Java刷题一些常见的api"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java刷题一些常见的api</div></div><div class="info-2"><div class="info-item-1">Stack常用的 Stack API：1. push(E item) 功能：将元素推入栈中。 参数：item - 要推入栈中的元素。 返回值：没有返回值。  1javastack.push(10); // 将 10 推入栈  2. pop() 功能：移除并返回栈顶元素。 返回值：栈顶元素。 异常：如果栈为空，抛出 EmptyStackException。  1javaInteger poppedElement = stack.pop(); // 返回并移除栈顶元素  3. peek() 功能：返回栈顶元素，但不移除它。 返回值：栈顶元素。 异常：如果栈为空，抛出 EmptyStackException。  1javaInteger topElement = stack.peek(); // 返回栈顶元素但不移除  4. empty() 功能：检查栈是否为空。 返回值：如果栈为空，返回 true，否则返回 false。  1javaboolean isEmpty = stack.empty(); // 返回栈是否为空  5. search(Object...</div></div></div></a><a class="pagination-related" href="/2025/04/18/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0/" title="左程云算法思想学习笔记——B站视频（待更新）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">左程云算法思想学习笔记——B站视频（待更新）</div></div><div class="info-2"><div class="info-item-1">左程云算法思想学习ep3 二进制和位运算123456789101112&lt;&lt; 左移补零&gt;&gt; 右移补符号位&gt;&gt;&gt; 右移补零| 或&amp; 与^ 异或运算~ 取反如何输出一个int型数字的二进制形式for(int i = 31; i &gt;= 0; i++)&#123;	cout&lt;&lt; (num &amp; (1 &lt;&lt; i)) == 0 ? 0 : 1;//判断该数在某一位是否为1&#125;  ep5 对数器的使用1核心思想是用一个已知绝对正确但时空复杂度较高的方法与自己写的代码以随机数生成器生成的数据集为输入，比对输出结果相同与否以验证自己代码是否在所有情况下均为正确  ep6...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/04/30/JDBC/" title="JDBC学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-30</div><div class="info-item-2">JDBC学习笔记</div></div><div class="info-2"><div class="info-item-1">基础篇引言1通过Java程序对数据库中数据做增删改查的需求催生了JDBC的出现    JDBC概念123Java DataBase Connectivityjava提供的一组独立于任何数据库管理系统的API，厂商根据规范提供数据库驱动jar包    核心组成接口规范123保持JAVA代码的一致性接口存储在java.sql和javax.sql包下    实现规范1厂商自行实现，并将内容封装为jar包        快速入门 核心API理解forName123456forName(&quot;com.mysql.cj.jbdc.Driver&quot;)方法也可以替换为forName(new...</div></div></div></a><a class="pagination-related" href="/2025/01/21/rabbitMQ/" title="黑马程序员RabbitMQ学习笔记（待更新）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-21</div><div class="info-item-2">黑马程序员RabbitMQ学习笔记（待更新）</div></div><div class="info-2"><div class="info-item-1">基础篇同步与异步同步调用1234567优势：时效性强，等待到结果才返回问题：拓展性差性能下降级联失败问题（调用的服务迟迟不响应导致当前服务资源耗尽）    异步调用1234三个角色消息发送者：调用方信息代理：管理、暂存、转发消息消息接收者：服务提供方   12345678910优势：解除耦合，扩展性强无需等待，性能好故障隔离缓存信息，流量的削峰填谷问题：不能立即得到调用结果，时效性差不确定下游业务执行是否成功业务安全依赖于Broker的可靠性        MQ技术选型1存放消息的队列。异步调用中的Broker   123456789ErLang是面向并发的语言RabbitMQ和ActiveMQ连接的微服务可以是其他语言，而RocketMQ只能使用java语言Kafka以吞吐量为优势，但可靠性一般，可以解决大量日志信息部署到日志平台的需求RabbitMQ可靠性强，消息延迟非常短RabbitMQ与RocketMQ使用较多    数据隔离1下面是基础架构   SpringAMQP12345678AMQP Advanced Message Queuing...</div></div></div></a><a class="pagination-related" href="/2025/01/29/netty/" title="黑马程序员Netty学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-29</div><div class="info-item-2">黑马程序员Netty学习笔记</div></div><div class="info-2"><div class="info-item-1">认真的 Netty 源码解析（一）本文又是一篇源码分析文章，其实除了 Doug Lea 的并发包源码，我是不太爱写源码分 - 掘金 1没准以后有用  C10K问题解析-CSDN博客 NIO基础non-blocking io...</div></div></div></a><a class="pagination-related" href="/2023/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="黑马程序员Mysql学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="info-item-2">黑马程序员Mysql学习笔记</div></div><div class="info-2"><div class="info-item-1">数据库学习笔记基本学习要求![屏幕截图 2023-07-25 092220](C:\Users\THECHOSEN\Desktop\数据库笔记图片\屏幕截图 2023-07-25 092220.png)    基础篇MySQL概述概念1234567数据库是存储数据的仓库，数据有组织的进行存储关系型数据库是建立在关系模型基础上，用多张相互连接的二维表组成的数据库数据库管理系统，操纵和管理数据库的大型软件SQL，操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准    配置并连接1234方法一：打开“服务”，找到MySQL80，将其启动方法二：用系统自带的命令行工具执行指令（需要先配置PATH环境变量，在path内添加一个到mysql server 8.0/bin/的路径）mysql [-h 127.0.0.1] [-p 3306] -u root...</div></div></div></a><a class="pagination-related" href="/2024/11/20/ssm%E6%A1%86%E6%9E%B6/" title="黑马程序员ssm框架学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">黑马程序员ssm框架学习笔记</div></div><div class="info-2"><div class="info-item-1">Spring12345其实是在学习SpringFrameWorkSpring5.0需要jdk8及以上进行支持Spring中的配置学习是为了熟悉原理，而注解的学习是为了简便开发  Spring Framework系统架构 1AOP可以在不影响程序的前提下增强程序的功能  核心容器核心概念（IoC&#x2F;DI）1目的是充分解耦，使用对象时可以直接从IoC容器中获取到绑定好所有依赖关系的bean    IoC12345Inversion of Control...</div></div></div></a><a class="pagination-related" href="/2025/01/12/redis/" title="黑马程序员Redis学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="info-item-2">黑马程序员Redis学习笔记</div></div><div class="info-2"><div class="info-item-1">基础篇认识NoSQL对比SQL和NoSQL123456789扩展性处：主要是说	SQL型数据库的性能主要取决于其所处机器的性能（若要分库需要引入第三方组件）	NoSQL型数据库天然支持数据在多个节点上的存储（会对每条数据生成唯一HASHID来判断该数据应该存储在哪个结点）	BASE是指:	BA: Basically Availible(是指允许分布式系统中某些部分出现故障，系统的其余部分依然可以用)	S: Soft State(在数据处理过程中，允许这个过程，存在数据状态暂时不一致的情况。但经过纠错处理，最终会一致)	E: Eventually Consistent(NoSQL的软状态允许数据处理过程的暂时不一致，但是最终处理结果将是一致的，说明NoSQL对数据处理过程可以有短暂的时间间隔，也允许分更细的步骤一个一个地处理，最后数据达到一致即可)	   认识Redis12345678910111213141516Remote Dictionary...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Doe</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.</span> <span class="toc-text">进程与线程对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">1.4.</span> <span class="toc-text">并行与并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%93%E8%AE%BA"><span class="toc-number">1.5.</span> <span class="toc-text">多线程效率提升的一些结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">Java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">创建和运行线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E4%B8%8ERunnable%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.</span> <span class="toc-text">Thread与Runnable的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">查看进程线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jconsole%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.1.</span> <span class="toc-text">jconsole远程监控配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">线程运行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7"><span class="toc-number">2.4.1.</span> <span class="toc-text">栈帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">2.4.3.</span> <span class="toc-text">线程上下文切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#start%E5%92%8Crun%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.5.1.</span> <span class="toc-text">start和run的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep%E5%92%8Cyield%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.5.2.</span> <span class="toc-text">sleep和yield的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.5.3.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.4.</span> <span class="toc-text">join方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.5.5.</span> <span class="toc-text">interrupt方法详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.6.</span> <span class="toc-text">不推荐的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.5.7.</span> <span class="toc-text">主线程与守护线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.6.</span> <span class="toc-text">五种状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.7.</span> <span class="toc-text">六种状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">共享模型之管程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">共享问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#syncronized%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.</span> <span class="toc-text">syncronized解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84syncronized"><span class="toc-number">3.3.</span> <span class="toc-text">方法上的syncronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%AB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">线程八锁问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-number">3.5.</span> <span class="toc-text">变量的线程安全分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%92%8Cprivate%E6%8F%90%E4%BE%9B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">3.5.1.</span> <span class="toc-text">final和private提供线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="toc-number">3.5.2.</span> <span class="toc-text">常见的线程安全类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.5.3.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Monitor%E6%A6%82%E5%BF%B5"><span class="toc-number">3.6.</span> <span class="toc-text">Monitor概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">3.6.1.</span> <span class="toc-text">Java对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitor"><span class="toc-number">3.6.2.</span> <span class="toc-text">Monitor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.3.</span> <span class="toc-text">synchronized原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-number">3.6.3.2.</span> <span class="toc-text">锁膨胀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96"><span class="toc-number">3.6.3.3.</span> <span class="toc-text">自旋优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">3.6.3.4.</span> <span class="toc-text">偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E7%8A%B6%E6%80%81"><span class="toc-number">3.6.3.4.1.</span> <span class="toc-text">偏向状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%92%A4%E9%94%80"><span class="toc-number">3.6.3.4.2.</span> <span class="toc-text">撤销</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91"><span class="toc-number">3.6.3.4.3.</span> <span class="toc-text">批量重偏向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="toc-number">3.6.3.4.4.</span> <span class="toc-text">批量撤销</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">3.6.3.4.5.</span> <span class="toc-text">锁粗化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">3.6.3.4.6.</span> <span class="toc-text">锁消除</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-notify"><span class="toc-number">3.7.</span> <span class="toc-text">wait&#x2F;notify</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">3.7.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.7.2.</span> <span class="toc-text">API介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E6%88%90%E7%86%9F%E7%9A%84wait-notify%E6%96%B9%E6%A1%88"><span class="toc-number">3.7.3.</span> <span class="toc-text">一个比较成熟的wait&#x2F;notify方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.7.4.</span> <span class="toc-text">join的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Park-Unpark"><span class="toc-number">3.8.</span> <span class="toc-text">Park&#x2F;Unpark</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">3.8.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">3.8.2.</span> <span class="toc-text">API介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Ewait-notify%E7%9B%B8%E6%AF%94"><span class="toc-number">3.8.3.</span> <span class="toc-text">与wait&amp;notify相比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%8A%8A%E9%94%81"><span class="toc-number">3.9.</span> <span class="toc-text">多把锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="toc-number">3.10.</span> <span class="toc-text">活跃性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.10.1.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81"><span class="toc-number">3.10.2.</span> <span class="toc-text">定位死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E9%94%81"><span class="toc-number">3.10.3.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF"><span class="toc-number">3.10.4.</span> <span class="toc-text">饥饿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">3.11.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">3.11.1.</span> <span class="toc-text">可重入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD"><span class="toc-number">3.11.2.</span> <span class="toc-text">可打断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%B6%85%E6%97%B6"><span class="toc-number">3.11.3.</span> <span class="toc-text">锁超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">3.11.4.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.11.5.</span> <span class="toc-text">条件变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">共享模型之内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">JAVA内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.2.1.</span> <span class="toc-text">实例分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">4.2.2.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7vs%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">4.2.3.</span> <span class="toc-text">可见性vs原子性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.1.</span> <span class="toc-text">指令重排序优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">支持流水线的处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.3.</span> <span class="toc-text">volatile原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">如何保证可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">如何保证有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#double-checked-locking%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">double-checked locking问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#double-checked-locking%E8%A7%A3%E5%86%B3"><span class="toc-number">4.3.3.4.</span> <span class="toc-text">double-checked locking解决</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before"><span class="toc-number">4.3.4.</span> <span class="toc-text">happens-before</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AE%9E%E4%BE%8B%E4%B9%A0%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">线程安全实例习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">共享模型之无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E4%B8%8Evolatile"><span class="toc-number">5.1.</span> <span class="toc-text">CAS与volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">原子整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">原子引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">5.4.</span> <span class="toc-text">原子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">字段更新器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="toc-number">5.6.</span> <span class="toc-text">原子累加器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LongAdder%E6%BA%90%E7%A0%81"><span class="toc-number">5.7.</span> <span class="toc-text">LongAdder源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="toc-number">5.7.1.</span> <span class="toc-text">原理之伪共享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsafe"><span class="toc-number">5.8.</span> <span class="toc-text">Unsafe</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">6.</span> <span class="toc-text">共享模型之不可变</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">日期转换的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.2.</span> <span class="toc-text">不可变设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">final原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEfinal%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.1.</span> <span class="toc-text">设置final变量的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96final%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.2.</span> <span class="toc-text">获取final变量的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">6.4.</span> <span class="toc-text">无状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7"><span class="toc-number">7.</span> <span class="toc-text">共享模型之工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">7.1.</span> <span class="toc-text">ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">7.1.1.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-number">7.1.3.</span> <span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-number">7.1.4.</span> <span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-number">7.1.5.</span> <span class="toc-text">newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.1.6.</span> <span class="toc-text">提交任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.7.</span> <span class="toc-text">关闭线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.8.</span> <span class="toc-text">任务调度线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.9.</span> <span class="toc-text">Tomcat线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-Join%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.2.</span> <span class="toc-text">Fork&#x2F;Join线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC"><span class="toc-number">7.3.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.1.</span> <span class="toc-text">AQS原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.2.</span> <span class="toc-text">ReentrantLock原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">非公平锁原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">可重入原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.2.3.</span> <span class="toc-text">可打断原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.2.4.</span> <span class="toc-text">公平锁实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.2.5.</span> <span class="toc-text">条件变量实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">7.3.3.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.3.2.</span> <span class="toc-text">读写锁原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StampedLock"><span class="toc-number">7.3.3.3.</span> <span class="toc-text">StampedLock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">7.3.4.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.4.2.</span> <span class="toc-text">Semaphore原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountdownLatch"><span class="toc-number">7.3.5.</span> <span class="toc-text">CountdownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">7.3.6.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">7.3.7.</span> <span class="toc-text">线程安全类集合概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">7.3.8.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94JDK8"><span class="toc-number">7.3.8.1.</span> <span class="toc-text">ConcurrentHashMap原理——JDK8</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK7%E5%B9%B6%E5%8F%91%E6%AD%BB%E9%93%BE%E9%97%AE%E9%A2%98"><span class="toc-number">7.3.8.1.1.</span> <span class="toc-text">JDK7并发死链问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8EHashTable%E5%92%8CHashMap%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">7.3.8.1.2.</span> <span class="toc-text">与HashTable和HashMap的比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">7.3.8.1.3.</span> <span class="toc-text">重要属性和内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%86%E6%9E%90"><span class="toc-number">7.3.8.1.4.</span> <span class="toc-text">构造器分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.8.1.5.</span> <span class="toc-text">get流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#put%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.8.1.6.</span> <span class="toc-text">put流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96table%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.8.1.7.</span> <span class="toc-text">初始化table流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#addCount%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.8.1.8.</span> <span class="toc-text">addCount方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#size%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.8.1.9.</span> <span class="toc-text">size计算流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transfer%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.8.1.10.</span> <span class="toc-text">transfer流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94JDK7"><span class="toc-number">7.3.8.2.</span> <span class="toc-text">ConcurrentHashMap原理——JDK7</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%86%E6%9E%90-1"><span class="toc-number">7.3.8.2.1.</span> <span class="toc-text">构造器分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#put%E6%B5%81%E7%A8%8B-1"><span class="toc-number">7.3.8.2.2.</span> <span class="toc-text">put流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.8.2.3.</span> <span class="toc-text">扩容流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get%E6%B5%81%E7%A8%8B-1"><span class="toc-number">7.3.8.2.4.</span> <span class="toc-text">get流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#size%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B-1"><span class="toc-number">7.3.8.2.5.</span> <span class="toc-text">size计算流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkerBlockingQueue%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.9.</span> <span class="toc-text">LinkerBlockingQueue原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">7.3.9.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E8%A1%A8"><span class="toc-number">7.3.9.2.</span> <span class="toc-text">初始化链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%85%A5%E9%98%9F"><span class="toc-number">7.3.9.3.</span> <span class="toc-text">节点入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%87%BA%E9%98%9F"><span class="toc-number">7.3.9.4.</span> <span class="toc-text">节点出队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-number">7.3.9.5.</span> <span class="toc-text">加锁分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put%E6%93%8D%E4%BD%9C"><span class="toc-number">7.3.9.6.</span> <span class="toc-text">put操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#take%E6%93%8D%E4%BD%9C"><span class="toc-number">7.3.9.7.</span> <span class="toc-text">take操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">7.3.9.8.</span> <span class="toc-text">性能比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-number">7.3.10.</span> <span class="toc-text">ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">7.3.11.</span> <span class="toc-text">CopyOnWriteArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.11.1.</span> <span class="toc-text">新增流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">7.3.11.2.</span> <span class="toc-text">读操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">7.3.11.3.</span> <span class="toc-text">get弱一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">7.3.11.4.</span> <span class="toc-text">迭代器弱一致性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%AF%87"><span class="toc-number">8.</span> <span class="toc-text">应用篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E7%8E%87"><span class="toc-number">8.1.</span> <span class="toc-text">效率</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2CPU%E5%8D%A0%E6%9C%89100"><span class="toc-number">8.1.1.</span> <span class="toc-text">防止CPU占有100%</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">8.2.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E7%AD%B9"><span class="toc-number">8.3.</span> <span class="toc-text">统筹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">8.4.</span> <span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">8.5.</span> <span class="toc-text">缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%AF%87"><span class="toc-number">9.</span> <span class="toc-text">模式篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.1.</span> <span class="toc-text">两阶段终止模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94volatile"><span class="toc-number">9.2.</span> <span class="toc-text">两阶段终止模式——volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8BBalking"><span class="toc-number">9.3.</span> <span class="toc-text">同步模式之Balking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">保护性暂停模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">9.5.</span> <span class="toc-text">异步模式之生产者&#x2F;消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">9.6.</span> <span class="toc-text">异步模式之工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">9.7.</span> <span class="toc-text">同步模式之顺序控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">9.7.1.</span> <span class="toc-text">固定运行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-notify%E7%89%88"><span class="toc-number">9.7.1.1.</span> <span class="toc-text">wait&#x2F;notify版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock%E7%89%88"><span class="toc-number">9.7.1.2.</span> <span class="toc-text">ReentrantLock版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Park-Unpark%E7%89%88"><span class="toc-number">9.7.1.3.</span> <span class="toc-text">Park&#x2F;Unpark版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BA"><span class="toc-number">9.7.2.</span> <span class="toc-text">交替输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-notify%E7%89%88-1"><span class="toc-number">9.7.2.1.</span> <span class="toc-text">wait&#x2F;notify版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%89%88"><span class="toc-number">9.7.2.2.</span> <span class="toc-text">Lock条件变量版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Park-Unpark%E7%89%88-1"><span class="toc-number">9.7.2.3.</span> <span class="toc-text">Park&#x2F;Unpark版</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.8.</span> <span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">9.8.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.8.2.</span> <span class="toc-text">自定义线程池实现</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/29/hello-world/" title="Hello World">Hello World</a><time datetime="2025-05-29T10:41:10.390Z" title="发表于 2025-05-29 18:41:10">2025-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0/" title="左程云算法思想学习笔记——B站视频（待更新）">左程云算法思想学习笔记——B站视频（待更新）</a><time datetime="2025-04-18T14:16:13.000Z" title="发表于 2025-04-18 22:16:13">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/java%E7%BC%96%E7%A8%8Bapi/" title="Java刷题一些常见的api">Java刷题一些常见的api</a><time datetime="2025-01-29T14:14:24.000Z" title="发表于 2025-01-29 22:14:24">2025-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/JUC/" title="黑马程序员JUC学习笔记">黑马程序员JUC学习笔记</a><time datetime="2025-01-29T14:14:24.000Z" title="发表于 2025-01-29 22:14:24">2025-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/netty/" title="黑马程序员Netty学习笔记">黑马程序员Netty学习笔记</a><time datetime="2025-01-29T14:12:24.000Z" title="发表于 2025-01-29 22:12:24">2025-01-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By John Doe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>